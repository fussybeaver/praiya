//! Method, error and parameter types for the Services endpoint.
#![allow(
    unused_imports,
)]
/* 
 * PagerDuty API
 *
 * This document describes the PagerDuty REST APIs.  For guides and examples please visit our [Documentation.](https://developer.pagerduty.com/docs/get-started/getting-started/)  Our REST APIs are defined in OpenAPI v3.x. You can view the schema at [github.com/PagerDuty/api-schema](https://github.com/PagerDuty/api-schema). 
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@pagerduty.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::models::*;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct ServicesClient {
    pub(crate) api_endpoint: String,
    pub(crate) client: PagerDuty,
}



impl BaseOption for ServicesCreateServiceParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for ServicesCreateServiceIntegrationParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for ServicesDeleteServiceParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}
/// Query parameters for the [Get a service](Services::get_service()) endpoint.
#[derive(Default, Serialize)]
pub struct ServicesGetServiceParams<'req> {
    pub(crate) qs: String,
}

pub struct ServicesGetServiceParamsBuilder {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> ServicesGetServiceParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    /// Array of additional details to include.
    pub fn include<I: IntoIterator<Item = &'req str>>(&mut self, include: I) -> &mut Self {
        for item in include {
            self.qs.append_pair("include[]", serde_urlencoded::to_string(item));
        }
        self
    }
}


impl BaseOption for ServicesGetServiceParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}
/// Query parameters for the [View an integration](Services::get_service_integration()) endpoint.
#[derive(Default, Serialize)]
pub struct ServicesGetServiceIntegrationParams<'req> {
    pub(crate) qs: String,
}

pub struct ServicesGetServiceIntegrationParamsBuilder {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> ServicesGetServiceIntegrationParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    /// Array of additional details to include.
    pub fn include<I: IntoIterator<Item = &'req str>>(&mut self, include: I) -> &mut Self {
        for item in include {
            self.qs.append_pair("include[]", serde_urlencoded::to_string(item));
        }
        self
    }
}


impl BaseOption for ServicesGetServiceIntegrationParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for ServicesListServiceAuditRecordsParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}
/// Query parameters for the [List services](Services::list_services()) endpoint.
#[derive(Default, Serialize)]
pub struct ServicesListServicesParams<'req> {
    pub(crate) qs: String,
}

pub struct ServicesListServicesParamsBuilder {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> ServicesListServicesParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    /// An array of team IDs. Only results related to these teams will be returned. Account must have the `teams` ability to use this parameter.
    pub fn team_ids<I: IntoIterator<Item = &'req str>>(&mut self, team_ids: I) -> &mut Self {
        for item in team_ids {
            self.qs.append_pair("team_ids[]", serde_urlencoded::to_string(item));
        }
        self
    }

    /// Time zone in which dates in the result will be rendered.
    pub fn time_zone(&mut self, time_zone: &'req str) -> &mut Self {
        self.qs.append_pair("time_zone", serde_urlencoded::to_string(time_zone));

        self
    }

    /// Used to specify the field you wish to sort the results on.
    pub fn sort_by(&mut self, sort_by: &'req str) -> &mut Self {
        self.qs.append_pair("sort_by", serde_urlencoded::to_string(sort_by));

        self
    }

    /// Filters the result, showing only the services whose name or service_key matches the query.
    pub fn query(&mut self, query: &'req str) -> &mut Self {
        self.qs.append_pair("query", serde_urlencoded::to_string(query));

        self
    }

    /// Array of additional details to include.
    pub fn include<I: IntoIterator<Item = &'req str>>(&mut self, include: I) -> &mut Self {
        for item in include {
            self.qs.append_pair("include[]", serde_urlencoded::to_string(item));
        }
        self
    }
}


impl BaseOption for ServicesListServicesParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for ServicesUpdateServiceParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for ServicesUpdateServiceIntegrationParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl ServicesClient {
    /// ---
    ///
    /// # Create a service
    ///
    /// Create a new service.
    /// 
    /// A service may represent an application, component, or team you wish to open incidents against.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#services)
    /// 
    /// 
    /// ---
    pub async fn create_service(&self, body: Service) -> Result<ServicesBody, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, &self.path(), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Some(PagerDuty::serialize_payload(Service)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Create a new integration
    ///
    /// Create a new integration belonging to a Service.
    /// 
    /// A service may represent an application, component, or team you wish to open incidents against.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#services)
    /// 
    /// 
    /// ---
    pub async fn create_service_integration(&self, id: &str, body: ServiceIntegration) -> Result<IdIntegrationsBody, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Some(PagerDuty::serialize_payload(ServiceIntegration)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Delete a service
    ///
    /// Delete an existing service. 
    /// 
    /// Once the service is deleted, it will not be accessible from the web UI and new incidents won't be able to be created for this service.
    /// 
    /// A service may represent an application, component, or team you wish to open incidents against.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#services)
    /// 
    /// 
    /// ---
    pub async fn delete_service(&self, id: &str) -> Result<(), Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::DELETE),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Get a service
    ///
    /// Get details about an existing service.
    /// 
    /// A service may represent an application, component, or team you wish to open incidents against.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#services)
    /// 
    /// 
    /// ---
    pub async fn get_service(&self, id: &str, query_params: ServicesGetServiceParams) -> Result<ServicesBody, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), ServicesGetServiceParamsBuilder::new().build().qs)?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::GET),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # View an integration
    ///
    /// Get details about an integration belonging to a service.
    /// 
    /// A service may represent an application, component, or team you wish to open incidents against.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#services)
    /// 
    /// 
    /// ---
    pub async fn get_service_integration(&self, id: &str, integration_id: &str, query_params: ServicesGetServiceIntegrationParams) -> Result<IdIntegrationsBody, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id&integration_id), ServicesGetServiceIntegrationParamsBuilder::new().build().qs)?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::GET),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # List audit records for a service
    ///
    /// The returned records are sorted by the `execution_time` from newest to oldest.
    /// 
    /// See [`Cursor-based pagination`](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for instructions on how to paginate through the result set.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#audit-record).
    /// 
    /// <!-- theme: warning -->
    /// > ### Early Access
    /// > This endpoint's interface is under development and subject to change. Do not use it in production systems.
    /// > Your request must set an X-EARLY-ACCESS header with value `audit-early-access` to acknowledge this.
    /// >
    /// > Audit records for escalation policies resource started in August 2020 and records may be purged while the API is in early access.
    /// 
    /// 
    /// ---
    pub async fn list_service_audit_records(&self, id: &str) -> Result<UsersAuditRecordsResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::GET),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # List services
    ///
    /// List existing Services.
    /// 
    /// A service may represent an application, component, or team you wish to open incidents against.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#services)
    /// 
    /// 
    /// ---
    pub fn list_services(&self, query_params: ServicesListServicesParams) -> impl Stream<Item = Result<Service, Error>> + '_ {
        let base_request = BaseRequest {
            host: String::clone(&self.api_endpoint),
            method: Method::GET,
            options: Arc::new(ServicesListServicesParamsBuilder::new().build()),
            path: self.path(),
        };

        self.client
            .process_into_paginated_stream::<ServicesResponse, >
    }

    /// ---
    ///
    /// # Update a service
    ///
    /// Update an existing service.
    /// 
    /// A service may represent an application, component, or team you wish to open incidents against.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#services)
    /// 
    /// 
    /// ---
    pub async fn update_service(&self, id: &str, body: Service) -> Result<ServicesIdBody, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::PUT),
            Some(PagerDuty::serialize_payload(Service)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Update an existing integration
    ///
    /// Update an integration belonging to a Service.
    /// 
    /// A service may represent an application, component, or team you wish to open incidents against.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#services)
    /// 
    /// 
    /// ---
    pub async fn update_service_integration(&self, id: &str, integration_id: &str, body: ServiceIntegration) -> Result<IntegrationsIntegrationIdBody, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id&integration_id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::PUT),
            Some(PagerDuty::serialize_payload(ServiceIntegration)?));


        self.client
            .process_into_value(req)
            .await
    }

}
