//! Method, error and parameter types for the ResponsePlays endpoint.
#![allow(
    unused_imports,
)]
/* 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


use crate::{
    BaseOption, BaseRequest, Praiya, PaginatedResponse, PaginationQueryComponent,
    SingleResponse, SubSystem, DEFAULT_PAGERDUTY_API_LIMIT
};
use crate::errors::Error;
use crate::models::*;

use std::collections::HashMap;
use std::sync::Arc;

use futures_core::Stream;
use futures_util::stream::StreamExt;
use http::request::Builder;
use hyper::{Body, Method};
use serde::{Deserialize, Serialize};
use serde_json::value::Value;
use url::form_urlencoded;

pub struct ResponsePlaysClient {
    pub(crate) api_endpoint: String,
    pub(crate) workspace: String,
    pub(crate) client: Praiya,
}


/// Query parameters for the [List Response Plays](ResponsePlays::list_response_plays()) endpoint.
#[derive(Default, Serialize)]
pub struct ResponsePlaysListResponsePlaysParams {
    pub(crate) qs: String,
}

pub struct ResponsePlaysListResponsePlaysParamsBuilder<'req> {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> ResponsePlaysListResponsePlaysParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    /// Filters the result, showing only the Response Plays whose name matches the query.
    pub fn query(&mut self, query: &'req str) -> &mut Self {
        self.qs.append_pair("query", &query);

        self
    }

    /// When this parameter is present, only those Response Plays that can be run manually will be returned.
    pub fn filter_for_manual_run(&mut self, filter_for_manual_run: bool) -> &mut Self {
        self.qs.append_pair("filter_for_manual_run", &serde_urlencoded::to_string(&filter_for_manual_run).unwrap_or_default());

        self
    }

    pub fn build(&mut self) -> ResponsePlaysListResponsePlaysParams {
        ResponsePlaysListResponsePlaysParams {
            qs: self.qs.finish(),
        }
    }
}

impl BaseOption for ResponsePlaysListResponsePlaysParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
      let mut query = form_urlencoded::Serializer::new(self.qs.clone());
      query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl ResponsePlaysClient {
    /// ---
    ///
    /// # Create a Response Play
    ///
    /// Creates a new Response Plays.
    /// 
    /// Response Plays allow you to create packages of Incident Actions that can be applied during an Incident's life cycle.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#response-plays)
    /// 
    /// 
    /// ---
    pub async fn create_response_play(&self, body: CreateResponsePlay) -> Result<, Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, "/response_plays", "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Praiya::serialize_payload(body)?);


        self.client
            .process_into_value::<, ResponsePlaysCreateResponsePlayResponse>(req)
            .await
    }

    /// ---
    ///
    /// # Delete a Response Play
    ///
    /// Delete an existing Response Play. Once the Response Play is deleted, the action cannot be undone.
    /// 
    /// WARNING: When the Response Play is deleted, it is also removed from any Services that were using it.
    /// 
    /// Response Plays allow you to create packages of Incident Actions that can be applied to an Incident.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#response-plays)
    /// 
    /// 
    /// ---
    pub async fn delete_response_play(&self, id: &str) -> Result<(), Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, &format!("/response_plays/{}", &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::DELETE),
            Body::empty());


        self.client
            .process_into_value::<, ResponsePlaysDeleteResponsePlayResponse>(req)
            .await
    }

    /// ---
    ///
    /// # Get a Response Play
    ///
    /// Get details about an existing Response Play.
    /// 
    /// Response Plays allow you to create packages of Incident Actions that can be applied during an Incident's life cycle.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#response-plays)
    /// 
    /// 
    /// ---
    pub async fn get_response_play(&self, id: &str) -> Result<, Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, &format!("/response_plays/{}", &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::GET),
            Body::empty());


        self.client
            .process_into_value::<, ResponsePlaysGetResponsePlayResponse>(req)
            .await
    }

    /// ---
    ///
    /// # List Response Plays
    ///
    /// List all of the existing Response Plays.
    /// 
    /// Response Plays allow you to create packages of Incident Actions that can be applied during an Incident's life cycle.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#response-plays)
    /// 
    /// 
    /// ---
    pub async fn list_response_plays(&self, query_params: ResponsePlaysListResponsePlaysParams) -> Result<, Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, "/response_plays", &ResponsePlaysListResponsePlaysParamsBuilder::new().build().qs)?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::GET),
            Body::empty());


        self.client
            .process_into_value::<, ResponsePlaysListResponsePlaysResponse>(req)
            .await
    }

    /// ---
    ///
    /// # Run a response play
    ///
    /// Run a specified response play on a given incident.
    /// 
    /// Response Plays are a package of Incident Actions that can be applied during an Incident's life cycle.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#response-plays)
    /// 
    /// 
    /// ---
    pub async fn run_response_play(&self, response_play_id: &str, body: RunResponsePlay) -> Result<, Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, &format!("/response_plays/{}/run", &response_play_id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Praiya::serialize_payload(body)?);


        self.client
            .process_into_value::<, ResponsePlaysRunResponsePlayResponse>(req)
            .await
    }

    /// ---
    ///
    /// # Update a Response Play
    ///
    /// Updates an existing Response Play.
    /// 
    /// Response Plays allow you to create packages of Incident Actions that can be applied during an Incident's life cycle.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#response-plays)
    /// 
    /// 
    /// ---
    pub async fn update_response_play(&self, id: &str, body: UpdateResponsePlay) -> Result<, Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, &format!("/response_plays/{}", &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::PUT),
            Praiya::serialize_payload(body)?);


        self.client
            .process_into_value::<, ResponsePlaysUpdateResponsePlayResponse>(req)
            .await
    }

}
