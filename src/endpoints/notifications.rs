//! Method, error and parameter types for the Notifications endpoint.
#![allow(
    unused_imports,
)]
/* 
 * PagerDuty API
 *
 * This document describes the PagerDuty REST APIs.  For guides and examples please visit our [Documentation.](https://developer.pagerduty.com/docs/get-started/getting-started/)  Our REST APIs are defined in OpenAPI v3.x. You can view the schema at [github.com/PagerDuty/api-schema](https://github.com/PagerDuty/api-schema). 
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@pagerduty.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::models::*;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct NotificationsClient {
    pub(crate) api_endpoint: String,
    pub(crate) client: PagerDuty,
}


/// Query parameters for the [List notifications](Notifications::list_notifications()) endpoint.
#[derive(Default, Serialize)]
pub struct NotificationsListNotificationsParams<'req> {
    pub(crate) qs: String,
}

pub struct NotificationsListNotificationsParamsBuilder {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> NotificationsListNotificationsParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    /// Time zone in which dates in the result will be rendered.
    pub fn time_zone(&mut self, time_zone: &'req str) -> &mut Self {
        self.qs.append_pair("time_zone", serde_urlencoded::to_string(time_zone));

        self
    }

    /// The start of the date range over which you want to search. The time element is optional.
    pub fn since(&mut self, since: chrono::DateTime<chrono::Utc>) -> &mut Self {
        self.qs.append_pair("since", serde_urlencoded::to_string(since));

        self
    }

    /// The end of the date range over which you want to search. This should be in the same format as since. The size of the date range must be less than 3 months.
    pub fn until(&mut self, until: chrono::DateTime<chrono::Utc>) -> &mut Self {
        self.qs.append_pair("until", serde_urlencoded::to_string(until));

        self
    }

    /// Return notification of this type only.
    pub fn filter(&mut self, filter: &'req str) -> &mut Self {
        self.qs.append_pair("filter", serde_urlencoded::to_string(filter));

        self
    }

    /// Array of additional details to include.
    pub fn include<I: IntoIterator<Item = &'req str>>(&mut self, include: I) -> &mut Self {
        for item in include {
            self.qs.append_pair("include[]", serde_urlencoded::to_string(item));
        }
        self
    }
}


impl BaseOption for NotificationsListNotificationsParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl NotificationsClient {
    /// ---
    ///
    /// # List notifications
    ///
    /// List notifications for a given time range, optionally filtered by type (sms_notification, email_notification, phone_notification, or push_notification).
    /// 
    /// A Notification is created when an Incident is triggered or escalated.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#notifications)
    /// 
    /// 
    /// ---
    pub fn list_notifications(&self, query_params: NotificationsListNotificationsParams) -> impl Stream<Item = Result<Notification, Error>> + '_ {
        let base_request = BaseRequest {
            host: String::clone(&self.api_endpoint),
            method: Method::GET,
            options: Arc::new(NotificationsListNotificationsParamsBuilder::new().build()),
            path: self.path(),
        };

        self.client
            .process_into_paginated_stream::<NotificationsResponse, >
    }

}
