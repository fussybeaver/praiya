//! Method, error and parameter types for the Teams endpoint.
#![allow(
    unused_imports,
)]
/* 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


use crate::{
    BaseOption, BaseRequest, Praiya, PaginatedResponse, PaginationQueryComponent,
    SingleResponse, SubSystem, DEFAULT_PAGERDUTY_API_LIMIT
};
use crate::errors::Error;
use crate::models::*;

use std::collections::HashMap;
use std::sync::Arc;

use futures_core::Stream;
use futures_util::stream::StreamExt;
use http::request::Builder;
use hyper::{Body, Method};
use serde::{Deserialize, Serialize};
use serde_json::value::Value;
use url::form_urlencoded;

pub struct TeamsClient {
    pub(crate) api_endpoint: String,
    pub(crate) workspace: String,
    pub(crate) client: Praiya,
}


/// Query parameters for the [Delete a team](Teams::delete_team()) endpoint.
#[derive(Default, Serialize)]
pub struct TeamsDeleteTeamParams {
    pub(crate) qs: String,
}

pub struct TeamsDeleteTeamParamsBuilder<'req> {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> TeamsDeleteTeamParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    /// Team to reassign unresolved incident to.  If an unresolved incident exists on both the reassignment team and  the team being deleted, a duplicate will not be made. If not supplied,  unresolved incidents will be made account-level. 
    pub fn reassignment_team(&mut self, reassignment_team: &'req str) -> &mut Self {
        self.qs.append_pair("reassignment_team", &reassignment_team);

        self
    }
}

impl BaseOption for TeamsDeleteTeamParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
      let mut query = form_urlencoded::Serializer::new(self.qs.clone());
      query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}
/// Query parameters for the [Get a team](Teams::get_team()) endpoint.
#[derive(Default, Serialize)]
pub struct TeamsGetTeamParams {
    pub(crate) qs: String,
}

pub struct TeamsGetTeamParamsBuilder<'req> {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> TeamsGetTeamParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    /// Array of additional Models to include in response.
    pub fn include<I: IntoIterator<Item = &'req str>>(&mut self, include: I) -> &mut Self {
        for item in include {
            self.qs.append_pair("include[]", &item);
        }
        self
    }
}

impl BaseOption for TeamsGetTeamParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
      let mut query = form_urlencoded::Serializer::new(self.qs.clone());
      query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct ListTeamUsersListResponse {
    pub offset: usize,
    pub more: bool,
    pub limit: usize,
    pub total: Option<u64>,
    pub list_team_users: Vec<InlineResponse20043Members>, //pub slack_connections: Vec<SlackConnection>
}

/// Query parameters for the [List members of a team](Teams::list_team_users()) endpoint.
#[derive(Default, Serialize)]
pub struct TeamsListTeamUsersParams {
    pub(crate) qs: String,
}

pub struct TeamsListTeamUsersParamsBuilder<'req> {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> TeamsListTeamUsersParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    /// Array of additional Models to include in response.
    pub fn include<I: IntoIterator<Item = &'req str>>(&mut self, include: I) -> &mut Self {
        for item in include {
            self.qs.append_pair("include[]", &item);
        }
        self
    }
}

impl BaseOption for TeamsListTeamUsersParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
      let mut query = form_urlencoded::Serializer::new(self.qs.clone());
      query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct ListTeamsListResponse {
    pub offset: usize,
    pub more: bool,
    pub limit: usize,
    pub total: Option<u64>,
    pub list_teams: Vec<Team>, //pub slack_connections: Vec<SlackConnection>
}

/// Query parameters for the [List teams](Teams::list_teams()) endpoint.
#[derive(Default, Serialize)]
pub struct TeamsListTeamsParams {
    pub(crate) qs: String,
}

pub struct TeamsListTeamsParamsBuilder<'req> {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> TeamsListTeamsParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    /// Filters the result, showing only the teams whose names or email addresses match the query.
    pub fn query(&mut self, query: &'req str) -> &mut Self {
        self.qs.append_pair("query", &query);

        self
    }
}

impl BaseOption for TeamsListTeamsParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
      let mut query = form_urlencoded::Serializer::new(self.qs.clone());
      query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl TeamsClient {
    /// ---
    ///
    /// # Create a team
    ///
    /// Create a new Team.
    /// 
    /// A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#teams)
    /// 
    /// 
    /// ---
    pub async fn create_team(&self, body: CreateTeamBody) -> Result<TeamsBody, Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, &self.path(), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Some(Praiya::serialize_payload(CreateTeamBody)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Delete a team
    ///
    /// Remove an existing team. 
    /// 
    /// Succeeds only if the team has no associated Escalation Policies, Services, Schedules and Subteams. 
    /// 
    /// All associated unresovled incidents will be reassigned to another team (if specified) or will loose team association, thus becoming account-level (with visibility implications). 
    /// 
    /// Note that the incidents reassignment process is asynchronous and has no guarantee to complete before the API call return.
    /// 
    /// A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#teams)
    /// 
    /// 
    /// ---
    pub async fn delete_team(&self, id: &str, query_params: TeamsDeleteTeamParams) -> Result<(), Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), TeamsDeleteTeamParamsBuilder::new().build().qs)?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::DELETE),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Remove an escalation policy from a team
    ///
    /// Remove an escalation policy from a team.
    /// 
    /// A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#teams)
    /// 
    /// 
    /// ---
    pub async fn delete_team_escalation_policy(&self, id: &str, escalation_policy_id: &str) -> Result<(), Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id&escalation_policy_id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::DELETE),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Remove a user from a team
    ///
    /// Remove a user from a team.
    /// 
    /// A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#teams)
    /// 
    /// 
    /// ---
    pub async fn delete_team_user(&self, id: &str, user_id: &str) -> Result<(), Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id&user_id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::DELETE),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Get a team
    ///
    /// Get details about an existing team.
    /// 
    /// A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#teams)
    /// 
    /// 
    /// ---
    pub async fn get_team(&self, id: &str, query_params: TeamsGetTeamParams) -> Result<TeamsBody, Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), TeamsGetTeamParamsBuilder::new().build().qs)?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::GET),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # List members of a team
    ///
    /// Get information about members on a team.
    /// 
    /// A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#teams)
    /// 
    /// 
    /// ---
    pub fn list_team_users(&self, id: &str, query_params: TeamsListTeamUsersParams) -> impl Stream<Item = Result<InlineResponse20043Members, Error>> + '_ {
        let base_request = BaseRequest {
            host: String::clone(&self.api_endpoint),
            method: Method::GET,
            options: Arc::new(TeamsListTeamUsersParamsBuilder::new().build()),
            path: self.path(),
        };

        self.client
            .process_into_paginated_stream::<ListTeamUsersResponse, ListTeamUsersListResponse>(
                base_request,
                PaginationQueryComponent {
                    offset: 0,
                    limit: DEFAULT_PAGERDUTY_API_LIMIT,
                },
            )
            .boxed()

    }

    /// ---
    ///
    /// # List teams
    ///
    /// List teams of your PagerDuty account, optionally filtered by a search query.
    /// 
    /// A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#teams)
    /// 
    /// 
    /// ---
    pub fn list_teams(&self, query_params: TeamsListTeamsParams) -> impl Stream<Item = Result<Team, Error>> + '_ {
        let base_request = BaseRequest {
            host: String::clone(&self.api_endpoint),
            method: Method::GET,
            options: Arc::new(TeamsListTeamsParamsBuilder::new().build()),
            path: self.path(),
        };

        self.client
            .process_into_paginated_stream::<ListTeamsResponse, ListTeamsListResponse>(
                base_request,
                PaginationQueryComponent {
                    offset: 0,
                    limit: DEFAULT_PAGERDUTY_API_LIMIT,
                },
            )
            .boxed()

    }

    /// ---
    ///
    /// # List audit records for a team
    ///
    /// The returned records are sorted by the `execution_time` from newest to oldest.
    /// 
    /// See [`Cursor-based pagination`](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for instructions on how to paginate through the result set.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#audit-record).
    /// 
    /// <!-- theme: warning -->
    /// > ### Early Access
    /// > This endpoint's interface is under development and subject to change. Do not use it in production systems.
    /// > Your request must set an X-EARLY-ACCESS header with value `audit-early-access` to acknowledge this.
    /// >
    /// > Audit records for user and team resources started in August 2020 and records may be purged while the API is in early access.
    /// 
    /// 
    /// ---
    pub async fn list_teams_audit_records(&self, id: &str) -> Result<ListUsersAuditRecordsResponse, Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::GET),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Update a team
    ///
    /// Update an existing team.
    /// 
    /// A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#teams)
    /// 
    /// 
    /// ---
    pub async fn update_team(&self, id: &str, body: UpdateTeamBody) -> Result<TeamsIdBody, Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::PUT),
            Some(Praiya::serialize_payload(UpdateTeamBody)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Add an escalation policy to a team
    ///
    /// Add an escalation policy to a team.
    /// 
    /// A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#teams)
    /// 
    /// 
    /// ---
    pub async fn update_team_escalation_policy(&self, id: &str, escalation_policy_id: &str) -> Result<(), Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id&escalation_policy_id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::PUT),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Add a user to a team
    ///
    /// Add a user to a team. Attempting to add a user with the `read_only_user` role will return a 400 error.
    /// 
    /// A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#teams)
    /// 
    /// 
    /// ---
    pub async fn update_team_user(&self, id: &str, user_id: &str, body: UpdateTeamUserBody) -> Result<(), Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id&user_id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::PUT),
            Some(Praiya::serialize_payload(UpdateTeamUserBody)?));


        self.client
            .process_into_value(req)
            .await
    }

}
