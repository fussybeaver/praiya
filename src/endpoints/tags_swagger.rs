//! Method, error and parameter types for the Tags endpoint.
#![allow(
    unused_imports,
)]
/* 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


use crate::{
    BaseOption, BaseRequest, Praiya, PaginatedResponse, PaginationQueryComponent,
    SingleResponse, SubSystem, DEFAULT_PAGERDUTY_API_LIMIT
};
use crate::errors::Error;
use crate::models::*;

use std::collections::HashMap;
use std::sync::Arc;

use futures_core::Stream;
use futures_util::stream::StreamExt;
use http::request::Builder;
use hyper::{Body, Method};
use serde::{Deserialize, Serialize};
use serde_json::value::Value;
use url::form_urlencoded;

pub struct TagsClient {
    pub(crate) api_endpoint: String,
    pub(crate) workspace: String,
    pub(crate) client: Praiya,
}



#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct InlineListResponse200 {
    pub offset: usize,
    pub more: bool,
    pub limit: usize,
    pub total: Option<u64>,
    pub inline200: Vec<Tag>,
}

/// Query parameters for the [Get tags for entities](Tags::get_entity_type_by_id_tags()) endpoint.
#[derive(Default, Serialize)]
pub struct TagsGetEntityTypeByIdTagsParams {
    pub(crate) qs: String,
}

pub struct TagsGetEntityTypeByIdTagsParamsBuilder<'req> {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> TagsGetEntityTypeByIdTagsParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    pub fn build(&mut self) -> TagsGetEntityTypeByIdTagsParams {
        TagsGetEntityTypeByIdTagsParams {
            qs: self.qs.finish(),
        }
    }
}

impl BaseOption for TagsGetEntityTypeByIdTagsParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
      let mut query = form_urlencoded::Serializer::new(self.qs.clone());
      query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct InlineListResponse20041 {
    pub offset: usize,
    pub more: bool,
    pub limit: usize,
    pub total: Option<u64>,
    pub inline20041: Vec<EntityReference>,
}

/// Query parameters for the [Get connected entities](Tags::get_tags_by_entity_type()) endpoint.
#[derive(Default, Serialize)]
pub struct TagsGetTagsByEntityTypeParams {
    pub(crate) qs: String,
}

pub struct TagsGetTagsByEntityTypeParamsBuilder<'req> {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> TagsGetTagsByEntityTypeParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    pub fn build(&mut self) -> TagsGetTagsByEntityTypeParams {
        TagsGetTagsByEntityTypeParams {
            qs: self.qs.finish(),
        }
    }
}

impl BaseOption for TagsGetTagsByEntityTypeParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
      let mut query = form_urlencoded::Serializer::new(self.qs.clone());
      query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct InlineListResponse200 {
    pub offset: usize,
    pub more: bool,
    pub limit: usize,
    pub total: Option<u64>,
    pub inline200: Vec<Tag>,
}

/// Query parameters for the [List tags](Tags::list_tags()) endpoint.
#[derive(Default, Serialize)]
pub struct TagsListTagsParams {
    pub(crate) qs: String,
}

pub struct TagsListTagsParamsBuilder<'req> {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> TagsListTagsParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    /// Filters the result, showing only the tags whose labels match the query.
    pub fn query(&mut self, query: &'req str) -> &mut Self {
        self.qs.append_pair("query", &query);

        self
    }

    pub fn build(&mut self) -> TagsListTagsParams {
        TagsListTagsParams {
            qs: self.qs.finish(),
        }
    }
}

impl BaseOption for TagsListTagsParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
      let mut query = form_urlencoded::Serializer::new(self.qs.clone());
      query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl TagsClient {
    /// ---
    ///
    /// # Assign tags
    ///
    /// Assign existing or new tags.
    /// 
    /// A Tag is applied to EScalation Policies, Teams or Users and can be used to filter them.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#tags)
    /// 
    /// 
    /// ---
    pub async fn create_entity_type_by_id_change_tags(&self, entity_type: &str, id: &str, body: CreateEntityTypeByIdChangeTags) -> Result<, Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, &format!("/{}/{}/change_tags", &entity_type, &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Praiya::serialize_payload(body)?);


        self.client
            .process_into_value::<, TagsCreateEntityTypeByIdChangeTagsResponse>(req)
            .await
    }

    /// ---
    ///
    /// # Create a tag
    ///
    /// Create a Tag.
    /// 
    /// A Tag is applied to EScalation Policies, Teams or Users and can be used to filter them.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#tags)
    /// 
    /// 
    /// ---
    pub async fn create_tags(&self, body: CreateTags) -> Result<, Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, "/tags", "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Praiya::serialize_payload(body)?);


        self.client
            .process_into_value::<, TagsCreateTagsResponse>(req)
            .await
    }

    /// ---
    ///
    /// # Delete a tag
    ///
    /// Remove an existing Tag.
    /// 
    /// A Tag is applied to EScalation Policies, Teams or Users and can be used to filter them.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#tags)
    /// 
    /// 
    /// ---
    pub async fn delete_tag(&self, id: &str) -> Result<(), Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, &format!("/tags/{}", &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::DELETE),
            Body::empty());


        self.client
            .process_into_value::<, TagsDeleteTagResponse>(req)
            .await
    }

    /// ---
    ///
    /// # Get tags for entities
    ///
    /// Get related tags for Users, Teams or Escalation Policies.
    /// 
    /// A Tag is applied to EScalation Policies, Teams or Users and can be used to filter them.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#tags)
    /// 
    /// 
    /// ---
    pub fn get_entity_type_by_id_tags(&self, entity_type: &str, id: &str, query_params: TagsGetEntityTypeByIdTagsParams) -> impl Stream<Item = Result<Tag, Error>> + '_ {
        let base_request = BaseRequest {
            host: String::clone(&self.api_endpoint),
            method: Method::GET,
            options: Arc::new(TagsGetEntityTypeByIdTagsParamsBuilder::new().build()),
            path: String::from("/{}/{}/tags"),
        };

        self.client
            .process_into_paginated_stream::<Tag, InlineListResponse200>(
                base_request,
                PaginationQueryComponent {
                    offset: 0,
                    limit: DEFAULT_PAGERDUTY_API_LIMIT,
                },
            )
            .boxed()

    }

    /// ---
    ///
    /// # Get a tag
    ///
    /// Get details about an existing Tag.
    /// 
    /// A Tag is applied to EScalation Policies, Teams or Users and can be used to filter them.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#tags)
    /// 
    /// 
    /// ---
    pub async fn get_tag(&self, id: &str) -> Result<, Error> {
        let uri = Praiya::parse_url(&self.api_endpoint, &format!("/tags/{}", &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::GET),
            Body::empty());


        self.client
            .process_into_value::<, TagsGetTagResponse>(req)
            .await
    }

    /// ---
    ///
    /// # Get connected entities
    ///
    /// Get related Users, Teams or Escalation Policies for the Tag.
    /// 
    /// A Tag is applied to EScalation Policies, Teams or Users and can be used to filter them.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#tags)
    /// 
    /// 
    /// ---
    pub fn get_tags_by_entity_type(&self, id: &str, entity_type: &str, query_params: TagsGetTagsByEntityTypeParams) -> impl Stream<Item = Result<EntityReference, Error>> + '_ {
        let base_request = BaseRequest {
            host: String::clone(&self.api_endpoint),
            method: Method::GET,
            options: Arc::new(TagsGetTagsByEntityTypeParamsBuilder::new().build()),
            path: String::from("/tags/{}/{}"),
        };

        self.client
            .process_into_paginated_stream::<EntityReference, InlineListResponse20041>(
                base_request,
                PaginationQueryComponent {
                    offset: 0,
                    limit: DEFAULT_PAGERDUTY_API_LIMIT,
                },
            )
            .boxed()

    }

    /// ---
    ///
    /// # List tags
    ///
    /// List all of your account's tags.
    /// 
    /// A Tag is applied to EScalation Policies, Teams or Users and can be used to filter them.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#tags)
    /// 
    /// 
    /// ---
    pub fn list_tags(&self, query_params: TagsListTagsParams) -> impl Stream<Item = Result<Tag, Error>> + '_ {
        let base_request = BaseRequest {
            host: String::clone(&self.api_endpoint),
            method: Method::GET,
            options: Arc::new(TagsListTagsParamsBuilder::new().build()),
            path: String::from("/tags"),
        };

        self.client
            .process_into_paginated_stream::<Tag, InlineListResponse200>(
                base_request,
                PaginationQueryComponent {
                    offset: 0,
                    limit: DEFAULT_PAGERDUTY_API_LIMIT,
                },
            )
            .boxed()

    }

}
