//! Method, error and parameter types for the Incidents endpoint.
#![allow(
    unused_imports,
)]
/* 
 * PagerDuty API
 *
 * This document describes the PagerDuty REST APIs.  For guides and examples please visit our [Documentation.](https://developer.pagerduty.com/docs/get-started/getting-started/)  Our REST APIs are defined in OpenAPI v3.x. You can view the schema at [github.com/PagerDuty/api-schema](https://github.com/PagerDuty/api-schema). 
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@pagerduty.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::models::*;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct IncidentsClient {
    pub(crate) api_endpoint: String,
    pub(crate) client: PagerDuty,
}



impl BaseOption for IncidentsCreateIncidentParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for IncidentsCreateIncidentNoteParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for IncidentsCreateIncidentNotificationSubscriberParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for IncidentsCreateIncidentResponderRequestParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for IncidentsCreateIncidentSnoozeParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for IncidentsCreateIncidentStatusUpdateParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for IncidentsGetIncidentParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for IncidentsGetIncidentAlertParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for IncidentsGetIncidentNotificationSubscribersParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}
/// Query parameters for the [List alerts for an incident](Incidents::list_incident_alerts()) endpoint.
#[derive(Default, Serialize)]
pub struct IncidentsListIncidentAlertsParams<'req> {
    pub(crate) qs: String,
}

pub struct IncidentsListIncidentAlertsParamsBuilder {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> IncidentsListIncidentAlertsParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    /// Return only alerts with the given statuses. (More status codes may be introduced in the future.)
    pub fn statuses<I: IntoIterator<Item = &'req str>>(&mut self, statuses: I) -> &mut Self {
        for item in statuses {
            self.qs.append_pair("statuses[]", serde_urlencoded::to_string(item));
        }
        self
    }

    /// Alert de-duplication key.
    pub fn alert_key(&mut self, alert_key: &'req str) -> &mut Self {
        self.qs.append_pair("alert_key", serde_urlencoded::to_string(alert_key));

        self
    }

    /// Used to specify both the field you wish to sort the results on (created_at/resolved_at), as well as the direction (asc/desc) of the results. The sort_by field and direction should be separated by a colon. A maximum of two fields can be included, separated by a comma. Sort direction defaults to ascending.
    pub fn sort_by<I: IntoIterator<Item = &'req str>>(&mut self, sort_by: I) -> &mut Self {
        for item in sort_by {
            self.qs.append_pair("sort_by[]", serde_urlencoded::to_string(item));
        }
        self
    }

    /// Array of additional details to include.
    pub fn include<I: IntoIterator<Item = &'req str>>(&mut self, include: I) -> &mut Self {
        for item in include {
            self.qs.append_pair("include[]", serde_urlencoded::to_string(item));
        }
        self
    }
}


impl BaseOption for IncidentsListIncidentAlertsParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}
/// Query parameters for the [List log entries for an incident](Incidents::list_incident_log_entries()) endpoint.
#[derive(Default, Serialize)]
pub struct IncidentsListIncidentLogEntriesParams<'req> {
    pub(crate) qs: String,
}

pub struct IncidentsListIncidentLogEntriesParamsBuilder {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> IncidentsListIncidentLogEntriesParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    /// Time zone in which dates in the result will be rendered.
    pub fn time_zone(&mut self, time_zone: &'req str) -> &mut Self {
        self.qs.append_pair("time_zone", serde_urlencoded::to_string(time_zone));

        self
    }

    /// The start of the date range over which you want to search.
    pub fn since(&mut self, since: chrono::DateTime<chrono::Utc>) -> &mut Self {
        self.qs.append_pair("since", serde_urlencoded::to_string(since));

        self
    }

    /// The end of the date range over which you want to search.
    pub fn until(&mut self, until: chrono::DateTime<chrono::Utc>) -> &mut Self {
        self.qs.append_pair("until", serde_urlencoded::to_string(until));

        self
    }

    /// If `true`, will return a subset of log entries that show only the most important changes to the incident.
    pub fn is_overview(&mut self, is_overview: bool) -> &mut Self {
        self.qs.append_pair("is_overview", serde_urlencoded::to_string(is_overview));

        self
    }

    /// Array of additional Models to include in response.
    pub fn include<I: IntoIterator<Item = &'req str>>(&mut self, include: I) -> &mut Self {
        for item in include {
            self.qs.append_pair("include[]", serde_urlencoded::to_string(item));
        }
        self
    }
}


impl BaseOption for IncidentsListIncidentLogEntriesParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for IncidentsListIncidentNotesParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}
/// Query parameters for the [List incidents](Incidents::list_incidents()) endpoint.
#[derive(Default, Serialize)]
pub struct IncidentsListIncidentsParams<'req> {
    pub(crate) qs: String,
}

pub struct IncidentsListIncidentsParamsBuilder {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> IncidentsListIncidentsParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }

    /// The start of the date range over which you want to search.
    pub fn since(&mut self, since: chrono::DateTime<chrono::Utc>) -> &mut Self {
        self.qs.append_pair("since", serde_urlencoded::to_string(since));

        self
    }

    /// The end of the date range over which you want to search.
    pub fn until(&mut self, until: chrono::DateTime<chrono::Utc>) -> &mut Self {
        self.qs.append_pair("until", serde_urlencoded::to_string(until));

        self
    }

    /// When set to all, the since and until parameters and defaults are ignored.
    pub fn date_range(&mut self, date_range: &'req str) -> &mut Self {
        self.qs.append_pair("date_range", serde_urlencoded::to_string(date_range));

        self
    }

    /// Return only incidents with the given statuses. (More status codes may be introduced in the future.)
    pub fn statuses<I: IntoIterator<Item = &'req str>>(&mut self, statuses: I) -> &mut Self {
        for item in statuses {
            self.qs.append_pair("statuses[]", serde_urlencoded::to_string(item));
        }
        self
    }

    /// Incident de-duplication key. Incidents with child alerts do not have an incident key; querying by incident key will return incidents whose alerts have alert_key matching the given incident key.
    pub fn incident_key(&mut self, incident_key: &'req str) -> &mut Self {
        self.qs.append_pair("incident_key", serde_urlencoded::to_string(incident_key));

        self
    }

    /// Returns only the incidents associated with the passed service(s). This expects one or more service IDs.
    pub fn service_ids<I: IntoIterator<Item = &'req str>>(&mut self, service_ids: I) -> &mut Self {
        for item in service_ids {
            self.qs.append_pair("service_ids[]", serde_urlencoded::to_string(item));
        }
        self
    }

    /// An array of team IDs. Only results related to these teams will be returned. Account must have the `teams` ability to use this parameter.
    pub fn team_ids<I: IntoIterator<Item = &'req str>>(&mut self, team_ids: I) -> &mut Self {
        for item in team_ids {
            self.qs.append_pair("team_ids[]", serde_urlencoded::to_string(item));
        }
        self
    }

    /// Returns only the incidents currently assigned to the passed user(s). This expects one or more user IDs. Note: When using the assigned_to_user filter, you will only receive incidents with statuses of triggered or acknowledged. This is because resolved incidents are not assigned to any user.
    pub fn user_ids<I: IntoIterator<Item = &'req str>>(&mut self, user_ids: I) -> &mut Self {
        for item in user_ids {
            self.qs.append_pair("user_ids[]", serde_urlencoded::to_string(item));
        }
        self
    }

    /// Array of the urgencies of the incidents to be returned. Defaults to all urgencies. Account must have the `urgencies` ability to do this.
    pub fn urgencies<I: IntoIterator<Item = &'req str>>(&mut self, urgencies: I) -> &mut Self {
        for item in urgencies {
            self.qs.append_pair("urgencies[]", serde_urlencoded::to_string(item));
        }
        self
    }

    /// Time zone in which dates in the result will be rendered.
    pub fn time_zone(&mut self, time_zone: &'req str) -> &mut Self {
        self.qs.append_pair("time_zone", serde_urlencoded::to_string(time_zone));

        self
    }

    /// Used to specify both the field you wish to sort the results on (incident_number/created_at/resolved_at/urgency), as well as the direction (asc/desc) of the results. The sort_by field and direction should be separated by a colon. A maximum of two fields can be included, separated by a comma. Sort direction defaults to ascending. The account must have the `urgencies` ability to sort by the urgency.
    pub fn sort_by<I: IntoIterator<Item = &'req str>>(&mut self, sort_by: I) -> &mut Self {
        for item in sort_by {
            self.qs.append_pair("sort_by[]", serde_urlencoded::to_string(item));
        }
        self
    }

    /// Array of additional details to include.
    pub fn include<I: IntoIterator<Item = &'req str>>(&mut self, include: I) -> &mut Self {
        for item in include {
            self.qs.append_pair("include[]", serde_urlencoded::to_string(item));
        }
        self
    }
}


impl BaseOption for IncidentsListIncidentsParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for IncidentsMergeIncidentsParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for IncidentsRemoveIncidentNotificationSubscriberParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for IncidentsUpdateIncidentParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl BaseOption for IncidentsUpdateIncidentAlertParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}
/// Query parameters for the [Manage alerts](Incidents::update_incident_alerts()) endpoint.
#[derive(Default, Serialize)]
pub struct IncidentsUpdateIncidentAlertsParams<'req> {
    pub(crate) qs: String,
}

pub struct IncidentsUpdateIncidentAlertsParamsBuilder {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> IncidentsUpdateIncidentAlertsParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }
}


impl BaseOption for IncidentsUpdateIncidentAlertsParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}
/// Query parameters for the [Manage incidents](Incidents::update_incidents()) endpoint.
#[derive(Default, Serialize)]
pub struct IncidentsUpdateIncidentsParams<'req> {
    pub(crate) qs: String,
}

pub struct IncidentsUpdateIncidentsParamsBuilder {
    qs: form_urlencoded::Serializer<'req, String>,
}

impl<'req> IncidentsUpdateIncidentsParamsBuilder<'req> {
    pub fn new() -> Self {
        Self {
            qs: form_urlencoded::Serializer::new(String::new())
        }
    }
}


impl BaseOption for IncidentsUpdateIncidentsParams {
    fn build_paginated_query_string(&self, pagination: PaginationQueryComponent) -> String {
        let mut query = form_urlencoded::Serializer::new(form_urlencoded::Serializer::Clone(&self.qs))
        query.append_pair("offset", &pagination.offset.to_string());
        query.append_pair("offset", &pagination.limit.to_string());
        query.finish()
    }
}

impl IncidentsClient {
    /// ---
    ///
    /// # Create an Incident
    ///
    /// Create an incident synchronously without a corresponding event from a monitoring service.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub async fn create_incident(&self, body: Incident) -> Result<IncidentSnoozeResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, &self.path(), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Some(PagerDuty::serialize_payload(Incident)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Create a note on an incident
    ///
    /// Create a new note for the specified incident.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub async fn create_incident_note(&self, id: &str, body: IncidentNote) -> Result<IdNotesBody, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Some(PagerDuty::serialize_payload(IncidentNote)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Add notification subscriber
    ///
    /// Subscribe the given entity to Incident Status Update Notifications.
    /// 
    /// <!-- theme: warning -->
    /// > ### Early Access
    /// > This endpoint is in Early Access and may change at any time. You must pass in the X-EARLY-ACCESS header to access it.
    /// 
    /// ---
    pub async fn create_incident_notification_subscriber(&self, id: &str, body: IncidentNotificationSubscriber) -> Result<IncidentNotificationSubscriberResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Some(PagerDuty::serialize_payload(IncidentNotificationSubscriber)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Create a responder request for an incident
    ///
    /// Send a new responder request for the specified incident.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub async fn create_incident_responder_request(&self, id: &str, body: IncidentResponderRequest) -> Result<IncidentResponderRequestResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Some(PagerDuty::serialize_payload(IncidentResponderRequest)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Snooze an incident
    ///
    /// Snooze an incident.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub async fn create_incident_snooze(&self, id: &str, body: IncidentSnooze) -> Result<IncidentSnoozeResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Some(PagerDuty::serialize_payload(IncidentSnooze)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Create a status update on an incident
    ///
    /// Create a new status update for the specified incident.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub async fn create_incident_status_update(&self, id: &str, body: IncidentStatusUpdate) -> Result<IncidentStatusUpdateResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Some(PagerDuty::serialize_payload(IncidentStatusUpdate)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Get an incident
    ///
    /// Show detailed information about an incident. Accepts either an incident id, or an incident number.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub async fn get_incident(&self, id: &str) -> Result<IncidentSnoozeResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::GET),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Get an alert
    ///
    /// Show detailed information about an alert. Accepts an alert id.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// When a service sends an event to PagerDuty, an alert and corresponding incident is triggered in PagerDuty.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub async fn get_incident_alert(&self, id: &str, alert_id: &str) -> Result<GetIncidentAlertResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id&alert_id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::GET),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # List notification subscribers
    ///
    /// Retrieve a list of Notification Subscribers on the Incident.
    /// 
    /// <!-- theme: warning -->
    /// > ### Early Access
    /// > This endpoint is in Early Access and may change at any time. You must pass in the X-EARLY-ACCESS header to access it.
    /// > Users must be added through `POST /incident/{id}/status_updates/subscribers` to be returned from this endpoint.
    /// 
    /// ---
    pub async fn get_incident_notification_subscribers(&self, id: &str) -> Result<GetIncidentNotificationSubscribersResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::GET),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # List alerts for an incident
    ///
    /// List alerts for the specified incident.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub fn list_incident_alerts(&self, id: &str, query_params: IncidentsListIncidentAlertsParams) -> impl Stream<Item = Result<Alert, Error>> + '_ {
        let base_request = BaseRequest {
            host: String::clone(&self.api_endpoint),
            method: Method::GET,
            options: Arc::new(IncidentsListIncidentAlertsParamsBuilder::new().build()),
            path: self.path(),
        };

        self.client
            .process_into_paginated_stream::<IncidentAlertsResponse, >
    }

    /// ---
    ///
    /// # List log entries for an incident
    ///
    /// List log entries for the specified incident.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// A Log Entry are a record of all events on your account.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub fn list_incident_log_entries(&self, id: &str, query_params: IncidentsListIncidentLogEntriesParams) -> impl Stream<Item = Result<LogEntry, Error>> + '_ {
        let base_request = BaseRequest {
            host: String::clone(&self.api_endpoint),
            method: Method::GET,
            options: Arc::new(IncidentsListIncidentLogEntriesParamsBuilder::new().build()),
            path: self.path(),
        };

        self.client
            .process_into_paginated_stream::<LogEntriesResponse, >
    }

    /// ---
    ///
    /// # List notes for an incident
    ///
    /// List existing notes for the specified incident.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub async fn list_incident_notes(&self, id: &str) -> Result<IncidentNotesResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::GET),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # List incidents
    ///
    /// List existing incidents.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub fn list_incidents(&self, query_params: IncidentsListIncidentsParams) -> impl Stream<Item = Result<Incident, Error>> + '_ {
        let base_request = BaseRequest {
            host: String::clone(&self.api_endpoint),
            method: Method::GET,
            options: Arc::new(IncidentsListIncidentsParamsBuilder::new().build()),
            path: self.path(),
        };

        self.client
            .process_into_paginated_stream::<IncidentsResponse, >
    }

    /// ---
    ///
    /// # Merge incidents
    ///
    /// Merge a list of source incidents into this incident.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub async fn merge_incidents(&self, id: &str, body: Incidents) -> Result<IncidentsResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::PUT),
            Some(PagerDuty::serialize_payload(Incidents)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Remove notification subscriber
    ///
    /// Unsubscribes the matching Subscriber from Incident Status Update Notifications.
    /// 
    /// <!-- theme: warning -->
    /// > ### Early Access
    /// > This endpoint is in Early Access and may change at any time. You must pass in the X-EARLY-ACCESS header to access it.
    /// 
    /// ---
    pub async fn remove_incident_notification_subscriber(&self, id: &str) -> Result<(), Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::POST),
            Body::empty());


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Update an incident
    ///
    /// Acknowledge, resolve, escalate or reassign an incident.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub async fn update_incident(&self, id: &str, body: Incident) -> Result<IncidentResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::PUT),
            Some(PagerDuty::serialize_payload(Incident)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Update an alert
    ///
    /// Resolve an alert or associate an alert with a new parent incident.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// When a service sends an event to PagerDuty, an alert and corresponding incident is triggered in PagerDuty.
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub async fn update_incident_alert(&self, id: &str, alert_id: &str, body: IncidentAlert) -> Result<AlertsAlertIdBody, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id&alert_id), "")?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::PUT),
            Some(PagerDuty::serialize_payload(IncidentAlert)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Manage alerts
    ///
    /// Resolve multiple alerts or associate them with different incidents.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved. An alert represents a digital signal that was emitted to PagerDuty by the monitoring systems that detected or identified the issue.
    /// 
    /// A maximum of 500 alerts may be updated at a time. If more than this number of alerts are given, the API will respond with status 413 (Request Entity Too Large).
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub async fn update_incident_alerts(&self, id: &str, query_params: IncidentsUpdateIncidentAlertsParams, body: IncidentAlerts) -> Result<IncidentAlertsResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, format!("{}/{}", &self.path(), &id), IncidentsUpdateIncidentAlertsParamsBuilder::new().build().qs)?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::PUT),
            Some(PagerDuty::serialize_payload(IncidentAlerts)?));


        self.client
            .process_into_value(req)
            .await
    }

    /// ---
    ///
    /// # Manage incidents
    ///
    /// Acknowledge, resolve, escalate or reassign one or more incidents.
    /// 
    /// An incident represents a problem or an issue that needs to be addressed and resolved.
    /// 
    /// A maximum of 500 incidents may be updated at a time. If more than this number of incidents are given, the API will respond with status 413 (Request Entity Too Large).
    /// 
    /// For more information see the [API Concepts Document](../../docs/CONCEPTS.md#incidents)
    /// 
    /// 
    /// ---
    pub async fn update_incidents(&self, query_params: IncidentsUpdateIncidentsParams, body: Incidents) -> Result<IncidentsResponse, Error> {
        let uri = PagerDuty::parse_url(&self.api_endpoint, &self.path(), IncidentsUpdateIncidentsParamsBuilder::new().build().qs)?;
            
        let req = self.client.build_request(
            uri,
            Builder::new().method(Method::PUT),
            Some(PagerDuty::serialize_payload(Incidents)?));


        self.client
            .process_into_value(req)
            .await
    }

}
