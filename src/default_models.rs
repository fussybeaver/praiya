#![allow(unused_imports, unused_qualifications, unused_extern_crates)]
/* 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::ser::Serializer;
use serde::de::{DeserializeOwned, Deserializer};
use serde::Deserialize;
use serde_json::value::Value;

use std::cmp::Eq;
use std::collections::HashMap;
use std::default::Default;
use std::fmt::{self, Formatter, Display};
use std::hash::Hash;

use chrono::DateTime;
use chrono::Utc;

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Acknowledgement {     
    /// Time at which the acknowledgement was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub at: Option<chrono::DateTime<chrono::Utc>>,
    pub acknowledger: AcknowledgerReference,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AcknowledgerReference {     
    /// The label of the tag.
    #[serde(default="AcknowledgerReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: AcknowledgerReferenceTypeEnum,
}

impl Default for AcknowledgerReference {
    fn default() -> Self {
        Self {
            label: String::from("AcknowledgerReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl AcknowledgerReference {
    fn label_default() -> String {
        String::from("AcknowledgerReference")
    }
    fn _type_default() -> String {
        String::from("acknowledger_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AcknowledgerReferenceTypeEnum { 
    #[serde(rename = "user_reference")]
    USER_REFERENCE,
    #[serde(rename = "service_reference")]
    SERVICE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AcknowledgerReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            AcknowledgerReferenceTypeEnum::USER_REFERENCE => write!(f, "{}", "user_reference"),
            AcknowledgerReferenceTypeEnum::SERVICE_REFERENCE => write!(f, "{}", "service_reference"),
            AcknowledgerReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for AcknowledgerReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "user_reference" => Ok(AcknowledgerReferenceTypeEnum::USER_REFERENCE),
            "service_reference" => Ok(AcknowledgerReferenceTypeEnum::SERVICE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AcknowledgerReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            AcknowledgerReferenceTypeEnum::USER_REFERENCE => "user_reference",
            AcknowledgerReferenceTypeEnum::SERVICE_REFERENCE => "service_reference",
            AcknowledgerReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AcknowledgerReferenceTypeEnum {
    fn default() -> Self {
        AcknowledgerReferenceTypeEnum::USER_REFERENCE
    }
}

/// A message containing information about a single PagerDuty action.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Action {     
    /// Uniquely identifies this outgoing webhook message; can be used for idempotency when processing the messages.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<uuid::Uuid>,
    /// The date/time when this message was was sent.
    #[serde(skip_serializing_if="Option::is_none")]
    pub triggered_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook: Option<Webhook>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Addon {     
    /// The label of the tag.
    #[serde(default="Addon::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The type of Add-on.
    #[serde(rename = "type")]
    pub _type: AddonTypeEnum,
    /// The name of the Add-on.
    #[serde(skip_serializing_if="String::is_empty")]
    pub name: String,
    /// The source URL to display in a frame in the PagerDuty UI. HTTPS is required.
    #[serde(skip_serializing_if="String::is_empty")]
    pub src: String,
}

impl Default for Addon {
    fn default() -> Self {
        Self {
            label: String::from("Addon"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            name: Default::default(),
            src: Default::default(),
        }
    }
}

impl Addon {
    fn label_default() -> String {
        String::from("Addon")
    }
    fn _type_default() -> String {
        String::from("addon")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AddonTypeEnum { 
    #[serde(rename = "full_page_addon")]
    FULL_PAGE_ADDON,
    #[serde(rename = "incident_show_addon")]
    INCIDENT_SHOW_ADDON,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AddonTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            AddonTypeEnum::FULL_PAGE_ADDON => write!(f, "{}", "full_page_addon"),
            AddonTypeEnum::INCIDENT_SHOW_ADDON => write!(f, "{}", "incident_show_addon"),
            AddonTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for AddonTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "full_page_addon" => Ok(AddonTypeEnum::FULL_PAGE_ADDON),
            "incident_show_addon" => Ok(AddonTypeEnum::INCIDENT_SHOW_ADDON),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AddonTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            AddonTypeEnum::FULL_PAGE_ADDON => "full_page_addon",
            AddonTypeEnum::INCIDENT_SHOW_ADDON => "incident_show_addon",
            AddonTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AddonTypeEnum {
    fn default() -> Self {
        AddonTypeEnum::FULL_PAGE_ADDON
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AddonReference {     
    /// The label of the tag.
    #[serde(default="AddonReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: AddonReferenceTypeEnum,
}

impl Default for AddonReference {
    fn default() -> Self {
        Self {
            label: String::from("AddonReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl AddonReference {
    fn label_default() -> String {
        String::from("AddonReference")
    }
    fn _type_default() -> String {
        String::from("addon_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AddonReferenceTypeEnum { 
    #[serde(rename = "full_page_addon_reference")]
    FULL_PAGE_ADDON_REFERENCE,
    #[serde(rename = "incident_show_addon_reference")]
    INCIDENT_SHOW_ADDON_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AddonReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            AddonReferenceTypeEnum::FULL_PAGE_ADDON_REFERENCE => write!(f, "{}", "full_page_addon_reference"),
            AddonReferenceTypeEnum::INCIDENT_SHOW_ADDON_REFERENCE => write!(f, "{}", "incident_show_addon_reference"),
            AddonReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for AddonReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "full_page_addon_reference" => Ok(AddonReferenceTypeEnum::FULL_PAGE_ADDON_REFERENCE),
            "incident_show_addon_reference" => Ok(AddonReferenceTypeEnum::INCIDENT_SHOW_ADDON_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AddonReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            AddonReferenceTypeEnum::FULL_PAGE_ADDON_REFERENCE => "full_page_addon_reference",
            AddonReferenceTypeEnum::INCIDENT_SHOW_ADDON_REFERENCE => "incident_show_addon_reference",
            AddonReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AddonReferenceTypeEnum {
    fn default() -> Self {
        AddonReferenceTypeEnum::FULL_PAGE_ADDON_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateAddon {     
    pub addon: Addon,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateAddon {     
    pub addon: Addon,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AgentReference {     
    /// The label of the tag.
    #[serde(default="AgentReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: AgentReferenceTypeEnum,
}

impl Default for AgentReference {
    fn default() -> Self {
        Self {
            label: String::from("AgentReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl AgentReference {
    fn label_default() -> String {
        String::from("AgentReference")
    }
    fn _type_default() -> String {
        String::from("agent_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AgentReferenceTypeEnum { 
    #[serde(rename = "user_reference")]
    USER_REFERENCE,
    #[serde(rename = "service_reference")]
    SERVICE_REFERENCE,
    #[serde(rename = "integration_reference")]
    INTEGRATION_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AgentReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            AgentReferenceTypeEnum::USER_REFERENCE => write!(f, "{}", "user_reference"),
            AgentReferenceTypeEnum::SERVICE_REFERENCE => write!(f, "{}", "service_reference"),
            AgentReferenceTypeEnum::INTEGRATION_REFERENCE => write!(f, "{}", "integration_reference"),
            AgentReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for AgentReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "user_reference" => Ok(AgentReferenceTypeEnum::USER_REFERENCE),
            "service_reference" => Ok(AgentReferenceTypeEnum::SERVICE_REFERENCE),
            "integration_reference" => Ok(AgentReferenceTypeEnum::INTEGRATION_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AgentReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            AgentReferenceTypeEnum::USER_REFERENCE => "user_reference",
            AgentReferenceTypeEnum::SERVICE_REFERENCE => "service_reference",
            AgentReferenceTypeEnum::INTEGRATION_REFERENCE => "integration_reference",
            AgentReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AgentReferenceTypeEnum {
    fn default() -> Self {
        AgentReferenceTypeEnum::USER_REFERENCE
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Alert {     
    /// The label of the tag.
    #[serde(default="Alert::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The date/time the alert was first triggered.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: AlertTypeEnum,
    /// The current status of the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<AlertStatusEnum>,
    /// The alert's de-duplication key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert_key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub service: Option<ServiceReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub first_trigger_log_entry: Option<LogEntryReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident: Option<IncidentReference>,
    /// Whether or not an alert is suppressed. Suppressed alerts are not created with a parent incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub suppressed: Option<bool>,
    /// The magnitude of the problem as reported by the monitoring tool.
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<AlertSeverityEnum>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub integration: Option<Integration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<Body>,
}

impl Default for Alert {
    fn default() -> Self {
        Self {
            label: String::from("Alert"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            created_at: Default::default(),
            _type: Default::default(),
            status: Default::default(),
            alert_key: Default::default(),
            service: Default::default(),
            first_trigger_log_entry: Default::default(),
            incident: Default::default(),
            suppressed: Default::default(),
            severity: Default::default(),
            integration: Default::default(),
            body: Default::default(),
        }
    }
}

impl Alert {
    fn label_default() -> String {
        String::from("Alert")
    }
    fn _type_default() -> String {
        String::from("alert")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AlertTypeEnum { 
    #[serde(rename = "alert")]
    ALERT,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AlertTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            AlertTypeEnum::ALERT => write!(f, "{}", "alert"),
            AlertTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for AlertTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "alert" => Ok(AlertTypeEnum::ALERT),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AlertTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            AlertTypeEnum::ALERT => "alert",
            AlertTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AlertTypeEnum {
    fn default() -> Self {
        AlertTypeEnum::ALERT
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AlertStatusEnum { 
    #[serde(rename = "triggered")]
    TRIGGERED,
    #[serde(rename = "resolved")]
    RESOLVED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AlertStatusEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            AlertStatusEnum::TRIGGERED => write!(f, "{}", "triggered"),
            AlertStatusEnum::RESOLVED => write!(f, "{}", "resolved"),
            AlertStatusEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for AlertStatusEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "triggered" => Ok(AlertStatusEnum::TRIGGERED),
            "resolved" => Ok(AlertStatusEnum::RESOLVED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AlertStatusEnum {
    fn as_ref(&self) -> &str {
        match self { 
            AlertStatusEnum::TRIGGERED => "triggered",
            AlertStatusEnum::RESOLVED => "resolved",
            AlertStatusEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AlertStatusEnum {
    fn default() -> Self {
        AlertStatusEnum::TRIGGERED
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AlertSeverityEnum { 
    #[serde(rename = "info")]
    INFO,
    #[serde(rename = "warning")]
    WARNING,
    #[serde(rename = "error")]
    ERROR,
    #[serde(rename = "critical")]
    CRITICAL,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AlertSeverityEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            AlertSeverityEnum::INFO => write!(f, "{}", "info"),
            AlertSeverityEnum::WARNING => write!(f, "{}", "warning"),
            AlertSeverityEnum::ERROR => write!(f, "{}", "error"),
            AlertSeverityEnum::CRITICAL => write!(f, "{}", "critical"),
            AlertSeverityEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for AlertSeverityEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "info" => Ok(AlertSeverityEnum::INFO),
            "warning" => Ok(AlertSeverityEnum::WARNING),
            "error" => Ok(AlertSeverityEnum::ERROR),
            "critical" => Ok(AlertSeverityEnum::CRITICAL),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AlertSeverityEnum {
    fn as_ref(&self) -> &str {
        match self { 
            AlertSeverityEnum::INFO => "info",
            AlertSeverityEnum::WARNING => "warning",
            AlertSeverityEnum::ERROR => "error",
            AlertSeverityEnum::CRITICAL => "critical",
            AlertSeverityEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AlertSeverityEnum {
    fn default() -> Self {
        AlertSeverityEnum::INFO
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AlertCount {     
    /// The count of triggered alerts
    #[serde(skip_serializing_if="Option::is_none")]
    pub triggered: Option<isize>,
    /// The count of resolved alerts
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolved: Option<isize>,
    /// The total count of alerts
    #[serde(skip_serializing_if="Option::is_none")]
    pub all: Option<isize>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AlertReference {     
    /// The label of the tag.
    #[serde(default="AlertReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: AlertReferenceTypeEnum,
}

impl Default for AlertReference {
    fn default() -> Self {
        Self {
            label: String::from("AlertReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl AlertReference {
    fn label_default() -> String {
        String::from("AlertReference")
    }
    fn _type_default() -> String {
        String::from("alert_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AlertReferenceTypeEnum { 
    #[serde(rename = "alert_reference")]
    ALERT_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AlertReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            AlertReferenceTypeEnum::ALERT_REFERENCE => write!(f, "{}", "alert_reference"),
            AlertReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for AlertReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "alert_reference" => Ok(AlertReferenceTypeEnum::ALERT_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AlertReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            AlertReferenceTypeEnum::ALERT_REFERENCE => "alert_reference",
            AlertReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AlertReferenceTypeEnum {
    fn default() -> Self {
        AlertReferenceTypeEnum::ALERT_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateIncidentAlert {     
    pub alert: Alert,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfWebhooksV1AssignedToObject {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The user's name.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The user's email address.
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(rename = "type")]
    pub _type: AllOfWebhooksV1AssignedToObjectTypeEnum,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AllOfWebhooksV1AssignedToObjectTypeEnum { 
    #[serde(rename = "user")]
    USER,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AllOfWebhooksV1AssignedToObjectTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            AllOfWebhooksV1AssignedToObjectTypeEnum::USER => write!(f, "{}", "user"),
            AllOfWebhooksV1AssignedToObjectTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for AllOfWebhooksV1AssignedToObjectTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "user" => Ok(AllOfWebhooksV1AssignedToObjectTypeEnum::USER),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AllOfWebhooksV1AssignedToObjectTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            AllOfWebhooksV1AssignedToObjectTypeEnum::USER => "user",
            AllOfWebhooksV1AssignedToObjectTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AllOfWebhooksV1AssignedToObjectTypeEnum {
    fn default() -> Self {
        AllOfWebhooksV1AssignedToObjectTypeEnum::USER
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AnalyticsIncidentMetrics {     
    /// ID of the service.  Only included when aggregating by service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_id: Option<String>,
    /// Name of the service.  Only included when aggregating by service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_name: Option<String>,
    /// ID of the team.  Only included when aggregating by team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_id: Option<String>,
    /// Name of the team.  Only included when aggregating by team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_name: Option<String>,
    /// Mean time from when an incident was triggered until it was resolved.
    #[serde(skip_serializing_if="Option::is_none")]
    pub mean_seconds_to_resolve: Option<isize>,
    /// Mean time between the start of an incident, and the first responder to acknowledge.
    #[serde(skip_serializing_if="Option::is_none")]
    pub mean_seconds_to_first_ack: Option<isize>,
    /// Mean time between the start of an incident, and the first responder to acknowledge, or to accept responder request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub mean_seconds_to_engage: Option<isize>,
    /// Mean time between the start of an incident, and the last additional responder to acknowledge.  For incidents with one or less engaged users, this value is null.
    #[serde(skip_serializing_if="Option::is_none")]
    pub mean_seconds_to_mobilize: Option<isize>,
    /// Mean number of users who engaged (acknowledged, accepted responder request) with an incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub mean_engaged_user_count: Option<isize>,
    /// Total count of instances where an incident is escalated between responders assigned to an escalation policy.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_escalation_count: Option<isize>,
    /// Total count of instances where an additional responder, who was not on-call for an incident, is added.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_assignment_count: Option<isize>,
    /// Total number of unique interruptions during business hours. Business hour: 8am-6pm Mon-Fri, based on the user’s time zone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_business_hour_interruptions: Option<isize>,
    /// Total number of unique interruptions during sleep hours. Sleep hour: 10pm-8am every day, based on the user’s time zone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_sleep_hour_interruptions: Option<isize>,
    /// Total number of unique interruptions during off hours. Off hour: 6pm-10pm Mon-Fri and all day Sat-Sun, based on the user’s time zone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_off_hour_interruptions: Option<isize>,
    /// Total number of seconds incidents were snoozed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_snoozed_seconds: Option<isize>,
    /// Total engaged time across all responders for incidents.  Engaged time is measured from the time a user engages with an incident (by acknowledging or accepting a responder request) until the incident is resolved.  This may include periods in which the incidents was snoozed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_seconds: Option<isize>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AnalyticsRawIncident {     
    /// Incident Id
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// ID of the team the incident was assigned to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_id: Option<String>,
    /// ID of the service that the incident triggered on.
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_id: Option<String>,
    /// Timestamp of when the incident was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    /// Timestamp of when the incident was resolved.
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolved_at: Option<String>,
    /// Notification level
    #[serde(skip_serializing_if="Option::is_none")]
    pub urgency: Option<String>,
    /// A major incident is defined as any incident that requires a coordinated response, often across multiple teams.  https://support.pagerduty.com/docs/operational-reviews#major-incidents
    #[serde(skip_serializing_if="Option::is_none")]
    pub major: Option<bool>,
    /// ID of the incident's priority level.
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority_id: Option<String>,
    /// The user-provided short name of the priority.
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority_name: Option<String>,
    /// The integer representation of the incident's priority level.
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority_order: Option<isize>,
    /// Time from when incident triggered until it was resolved.
    #[serde(skip_serializing_if="Option::is_none")]
    pub seconds_to_resolve: Option<isize>,
    /// Time between start of an incident, and the first responder to acknowledge.
    #[serde(skip_serializing_if="Option::is_none")]
    pub seconds_to_first_ack: Option<isize>,
    /// Time between start of an incident, and the first responder to acknowledge, or to accept responder request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub seconds_to_engage: Option<isize>,
    /// Time between start of an incident, and the last additional responder to acknowledge.  If an incident has one or less responders, the value will be null.
    #[serde(skip_serializing_if="Option::is_none")]
    pub seconds_to_mobilize: Option<isize>,
    /// Total engaged time across all responders for this incident.  Engaged time is measured from the time a user engages with an incident (by acknowledging or accepting a responder request) until the incident is resolved.  This may include periods in which the incident was snoozed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub engaged_seconds: Option<isize>,
    /// Total number of users who engaged (acknowledged, accepted responder request) in the incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub engaged_user_count: Option<isize>,
    /// Total count of instances where an incident is escalated between responders assigned to an escalation policy.
    #[serde(skip_serializing_if="Option::is_none")]
    pub escalation_count: Option<isize>,
    /// Total count of instances where an additional responder, who was not on-call for the incident, is added.
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignment_count: Option<isize>,
    /// Total number of unique interruptions during business hour. Business hour: 8am-6pm Mon-Fri, based on the user’s time zone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub business_hour_interruptions: Option<isize>,
    /// Total number of unique interruptions during sleep hour. Sleep hour: 10pm-8am every day, based on the user’s time zone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sleep_hour_interruptions: Option<isize>,
    /// Total number of unique interruptions during off hour. Off hour: 6pm-10pm Mon-Fri and all day Sat-Sun, based on the user’s time zone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub off_hour_interruptions: Option<isize>,
    /// Total seconds the incident has been snoozed for.
    #[serde(skip_serializing_if="Option::is_none")]
    pub snoozed_seconds: Option<isize>,
}

/// Accepts a set of filters to apply to the Incidents before aggregating.  Any incidents that do not match the included filters will be omitted from the results
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AnalyticsmetricsincidentsallFilters {     
    /// Accepts an ISO8601 DateTime string.  Any incidents with a created_at less than this value will be omitted from the results.  The maximum supported time range in conjunction with created_at_end is one year.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at_start: Option<String>,
    /// Accepts an ISO8601 DateTime string.  Any incidents with a created_at greater than or equal to this value will be omitted from the results.  The maximum supported time range in conjunction with created_at_start is one year.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at_end: Option<String>,
    /// Any incidents whose urgency does not match the provided string will be omitted from the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub urgency: Option<AnalyticsmetricsincidentsallFiltersUrgencyEnum>,
    /// A boolean flag including whether results should contain only major incidents, or exclude major incidents. If no value is provided all incidents will be included. You can find more information on the major incident classification here: https://support.pagerduty.com/docs/operational-reviews#major-incidents
    #[serde(skip_serializing_if="Option::is_none")]
    pub major: Option<bool>,
    /// An array of team IDs. Only incidents related to these teams will be included in the results. Account must have the teams ability to use this parameter.  Any teams that the requestor does not have access to will be omitted from the results.  If omitted, all teams the requestor has access to will be included in the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_ids: Option<Vec<String>>,
    /// An array of service IDs. Only incidents related to these services will be included in the results. If omitted, all services the requestor has access to will be included in the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_ids: Option<Vec<String>>,
    /// An array of business service IDs. Only incidents related to these business services will be included in the results. If omitted, all services the requestor has access to will be included in the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub business_service_ids: Option<Vec<String>>,
    /// An array of priority IDs. Only incidents with these priorities will be included in the results. If omitted, all services the requestor has access to will be included in the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority_ids: Option<Vec<String>>,
    /// An array of user-defined priority names. Only incidents with these priorities will be included in the results. If omitted, all services the requestor has access to will be included in the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority_names: Option<Vec<String>>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AnalyticsmetricsincidentsallFiltersUrgencyEnum { 
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AnalyticsmetricsincidentsallFiltersUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            AnalyticsmetricsincidentsallFiltersUrgencyEnum::HIGH => write!(f, "{}", "high"),
            AnalyticsmetricsincidentsallFiltersUrgencyEnum::LOW => write!(f, "{}", "low"),
            AnalyticsmetricsincidentsallFiltersUrgencyEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for AnalyticsmetricsincidentsallFiltersUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "high" => Ok(AnalyticsmetricsincidentsallFiltersUrgencyEnum::HIGH),
            "low" => Ok(AnalyticsmetricsincidentsallFiltersUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AnalyticsmetricsincidentsallFiltersUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self { 
            AnalyticsmetricsincidentsallFiltersUrgencyEnum::HIGH => "high",
            AnalyticsmetricsincidentsallFiltersUrgencyEnum::LOW => "low",
            AnalyticsmetricsincidentsallFiltersUrgencyEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AnalyticsmetricsincidentsallFiltersUrgencyEnum {
    fn default() -> Self {
        AnalyticsmetricsincidentsallFiltersUrgencyEnum::HIGH
    }
}

/// Filters the result, only show incidents that match the conditions passed in the filter.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AnalyticsmetricsincidentsservicesFilters {     
    /// Filters the result, showing only the incidents where the creation timestamp is greater than the filter value.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at_start: Option<String>,
    /// Filters the result, showing only the incidents where the creation timestamp is less than the filter value.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at_end: Option<String>,
    /// Filters the result, showing only the incidents where urgency matches the filter value.
    #[serde(skip_serializing_if="Option::is_none")]
    pub urgency: Option<AnalyticsmetricsincidentsservicesFiltersUrgencyEnum>,
    /// A major incident is defined as any incident that requires a coordinated response, often across multiple teams. https://support.pagerduty.com/docs/operational-reviews#major-incidents
    #[serde(skip_serializing_if="Option::is_none")]
    pub major: Option<bool>,
    /// An array of team IDs. Only results related to these teams will be returned. Account must have the teams ability to use this parameter.
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_ids: Option<Vec<String>>,
    /// An array of service IDs. Only results related to these services will be returned.
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_ids: Option<Vec<String>>,
    /// An array of business service IDs. Only incidents related to these business services will be included in the results. If omitted, all services the requestor has access to will be included in the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub business_service_ids: Option<Vec<String>>,
    /// The priority_ids filter applied to the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority_ids: Option<Vec<String>>,
    /// The user-defined priority names filter applied to the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority_names: Option<Vec<String>>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AnalyticsmetricsincidentsservicesFiltersUrgencyEnum { 
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AnalyticsmetricsincidentsservicesFiltersUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            AnalyticsmetricsincidentsservicesFiltersUrgencyEnum::HIGH => write!(f, "{}", "high"),
            AnalyticsmetricsincidentsservicesFiltersUrgencyEnum::LOW => write!(f, "{}", "low"),
            AnalyticsmetricsincidentsservicesFiltersUrgencyEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for AnalyticsmetricsincidentsservicesFiltersUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "high" => Ok(AnalyticsmetricsincidentsservicesFiltersUrgencyEnum::HIGH),
            "low" => Ok(AnalyticsmetricsincidentsservicesFiltersUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AnalyticsmetricsincidentsservicesFiltersUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self { 
            AnalyticsmetricsincidentsservicesFiltersUrgencyEnum::HIGH => "high",
            AnalyticsmetricsincidentsservicesFiltersUrgencyEnum::LOW => "low",
            AnalyticsmetricsincidentsservicesFiltersUrgencyEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AnalyticsmetricsincidentsservicesFiltersUrgencyEnum {
    fn default() -> Self {
        AnalyticsmetricsincidentsservicesFiltersUrgencyEnum::HIGH
    }
}

/// Accepts a set of filters to apply to the Incidents before aggregating.  Any incidents that do not match the included filters will be omitted from the results
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AnalyticsmetricsincidentsteamsFilters {     
    /// Accepts an ISO8601 DateTime string.  Any incidents with a created_at less than this value will be omitted from the results.  The maximum supported time range in conjunction with created_at_end is one year.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at_start: Option<String>,
    /// Accepts an ISO8601 DateTime string.  Any incidents with a created_at greater than or equal to this value will be omitted from the results.  The maximum supported time range in conjunction with created_at_start is one year.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at_end: Option<String>,
    /// Any incidents whose urgency does not match the provided string will be omitted from the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub urgency: Option<AnalyticsmetricsincidentsteamsFiltersUrgencyEnum>,
    /// A boolean flag including whether results should contain only major incidents, or exclude major incidents. If no value is provided all incidents will be included. You can find more information on the major incident classification here: https://support.pagerduty.com/docs/operational-reviews#major-incidents
    #[serde(skip_serializing_if="Option::is_none")]
    pub major: Option<bool>,
    /// An array of team IDs. Only incidents related to these teams will be included in the results. Account must have the teams ability to use this parameter.  Any teams that the requestor does not have access to will be omitted from the results.  If omitted, all teams the requestor has access to will be included in the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_ids: Option<Vec<String>>,
    /// An array of service IDs. Only incidents related to these services will be included in the results. If omitted, all services the requestor has access to will be included in the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_ids: Option<Vec<String>>,
    /// An array of business service IDs. Only incidents related to these business services will be included in the results. If omitted, all services the requestor has access to will be included in the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub business_service_ids: Option<Vec<String>>,
    /// An array of priority IDs. Only incidents with these priorities will be included in the results. If omitted, all teams the requestor has access to will be included in the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority_ids: Option<Vec<String>>,
    /// An array of user-defined priority names. Only incidents with these priorities will be included in the results. If omitted, all teams the requestor has access to will be included in the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority_names: Option<Vec<String>>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AnalyticsmetricsincidentsteamsFiltersUrgencyEnum { 
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AnalyticsmetricsincidentsteamsFiltersUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            AnalyticsmetricsincidentsteamsFiltersUrgencyEnum::HIGH => write!(f, "{}", "high"),
            AnalyticsmetricsincidentsteamsFiltersUrgencyEnum::LOW => write!(f, "{}", "low"),
            AnalyticsmetricsincidentsteamsFiltersUrgencyEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for AnalyticsmetricsincidentsteamsFiltersUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "high" => Ok(AnalyticsmetricsincidentsteamsFiltersUrgencyEnum::HIGH),
            "low" => Ok(AnalyticsmetricsincidentsteamsFiltersUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AnalyticsmetricsincidentsteamsFiltersUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self { 
            AnalyticsmetricsincidentsteamsFiltersUrgencyEnum::HIGH => "high",
            AnalyticsmetricsincidentsteamsFiltersUrgencyEnum::LOW => "low",
            AnalyticsmetricsincidentsteamsFiltersUrgencyEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AnalyticsmetricsincidentsteamsFiltersUrgencyEnum {
    fn default() -> Self {
        AnalyticsmetricsincidentsteamsFiltersUrgencyEnum::HIGH
    }
}

/// Filters the result, only show incidents that match the conditions passed in the filter.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AnalyticsrawincidentsFilters {     
    /// Filters the result, showing only the incidents where the creation timestamp is greater than the filter value.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at_start: Option<String>,
    /// Filters the result, showing only the incidents where the creation timestamp is less than the filter value.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at_end: Option<String>,
    /// Filters the result, showing only the incidents where urgency matches the filter value.
    #[serde(skip_serializing_if="Option::is_none")]
    pub urgency: Option<String>,
    /// A major incident is defined as any incident that requires a coordinated response, often across multiple teams. https://support.pagerduty.com/docs/operational-reviews#major-incidents
    #[serde(skip_serializing_if="Option::is_none")]
    pub major: Option<bool>,
    /// An array of team IDs. Only results related to these teams will be returned. Account must have the teams ability to use this parameter.
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_ids: Option<Vec<String>>,
    /// An array of service IDs. Only results related to these services will be returned.
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_ids: Option<Vec<String>>,
    /// An array of business service IDs. Only incidents related to these business services will be included in the results. If omitted, all services the requestor has access to will be included in the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub business_service_ids: Option<Vec<String>>,
    /// The priority_ids filter applied to the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority_ids: Option<Vec<String>>,
    /// The priority_names filter applied to the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority_names: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AssignLogEntry {     
    #[serde(rename = "type")]
    pub _type: AssignLogEntryTypeEnum,
    /// Time at which the log entry was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub channel: Option<Channel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub agent: Option<AgentReference>,
    /// Optional field containing a note, if one was included with the log entry.
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<String>,
    /// Contexts to be included with the trigger such as links to graphs or images.
    #[serde(skip_serializing_if="Option::is_none")]
    pub contexts: Option<Vec<Context>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub service: Option<ServiceReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident: Option<IncidentReference>,
    /// Will consist of references unless included
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_details: Option<LogEntryEventDetails>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assigned_user: Option<UserReference>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AssignLogEntryTypeEnum { 
    #[serde(rename = "assign_log_entry")]
    ASSIGN_LOG_ENTRY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AssignLogEntryTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            AssignLogEntryTypeEnum::ASSIGN_LOG_ENTRY => write!(f, "{}", "assign_log_entry"),
            AssignLogEntryTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for AssignLogEntryTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "assign_log_entry" => Ok(AssignLogEntryTypeEnum::ASSIGN_LOG_ENTRY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AssignLogEntryTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            AssignLogEntryTypeEnum::ASSIGN_LOG_ENTRY => "assign_log_entry",
            AssignLogEntryTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AssignLogEntryTypeEnum {
    fn default() -> Self {
        AssignLogEntryTypeEnum::ASSIGN_LOG_ENTRY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Assignment {     
    /// Time at which the assignment was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub at: Option<chrono::DateTime<chrono::Utc>>,
    pub assignee: UserReference,
}

/// A JSON object containing data describing the alert.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Body {     
    /// The type of the body.
    #[serde(rename = "type")]
    pub _type: BodyTypeEnum,
    /// Contexts to be included with the body such as links to graphs or images.
    #[serde(skip_serializing_if="Option::is_none")]
    pub contexts: Option<Vec<Context>>,
    /// An arbitrary JSON object containing any data explaining the nature of the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub details: Option<HashMap<String, Value>>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum BodyTypeEnum { 
    #[serde(rename = "alert_body")]
    ALERT_BODY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for BodyTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            BodyTypeEnum::ALERT_BODY => write!(f, "{}", "alert_body"),
            BodyTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for BodyTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "alert_body" => Ok(BodyTypeEnum::ALERT_BODY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for BodyTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            BodyTypeEnum::ALERT_BODY => "alert_body",
            BodyTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for BodyTypeEnum {
    fn default() -> Self {
        BodyTypeEnum::ALERT_BODY
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct BusinessService {     
    /// The label of the tag.
    #[serde(default="BusinessService::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default="BusinessService::_type_default")]
    pub _type: String,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The name of the business service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The user-provided description of the business service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The point of contact assigned to this service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub point_of_contact: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team: Option<Team2>,
}

impl Default for BusinessService {
    fn default() -> Self {
        Self {
            label: String::from("BusinessService"),
            html_url: Default::default(),
            _self: Default::default(),
            _type: String::from("business_service"),
            summary: Default::default(),
            id: Default::default(),
            name: Default::default(),
            description: Default::default(),
            point_of_contact: Default::default(),
            team: Default::default(),
        }
    }
}

impl BusinessService {
    fn label_default() -> String {
        String::from("BusinessService")
    }
    fn _type_default() -> String {
        String::from("business_service")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct BusinessServiceReference {     
    /// The label of the tag.
    #[serde(default="BusinessServiceReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: BusinessServiceReferenceTypeEnum,
}

impl Default for BusinessServiceReference {
    fn default() -> Self {
        Self {
            label: String::from("BusinessServiceReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl BusinessServiceReference {
    fn label_default() -> String {
        String::from("BusinessServiceReference")
    }
    fn _type_default() -> String {
        String::from("business_service_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum BusinessServiceReferenceTypeEnum { 
    #[serde(rename = "business_service_reference")]
    BUSINESS_SERVICE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for BusinessServiceReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            BusinessServiceReferenceTypeEnum::BUSINESS_SERVICE_REFERENCE => write!(f, "{}", "business_service_reference"),
            BusinessServiceReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for BusinessServiceReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "business_service_reference" => Ok(BusinessServiceReferenceTypeEnum::BUSINESS_SERVICE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for BusinessServiceReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            BusinessServiceReferenceTypeEnum::BUSINESS_SERVICE_REFERENCE => "business_service_reference",
            BusinessServiceReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for BusinessServiceReferenceTypeEnum {
    fn default() -> Self {
        BusinessServiceReferenceTypeEnum::BUSINESS_SERVICE_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateBusinessService {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub business_service: Option<BusinessServicesBusinessService>,
}

/// The business service to be created
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BusinessServicesBusinessService {     
    /// The name of the business service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The description of the business service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The owner of the business service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub point_of_contact: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team: Option<Team1>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateBusinessService {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub business_service: Option<BusinessServicesBusinessService>,
}

/// Polymorphic object representation of the means by which the action was channeled. Has different formats depending on type, indicated by channel[type]. Will be one of `auto`, `email`, `api`, `nagios`, or `timeout` if `agent[type]` is `service`. Will be one of `email`, `sms`, `website`, `web_trigger`, or `note` if `agent[type]` is `user`. See [below](https://developer.pagerduty.com/documentation/rest/log_entries/show#channel_types) for detailed information about channel formats.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Channel {     
    /// type
    #[serde(rename = "type")]
    #[serde(default="Channel::_type_default")]
    pub _type: String,
    /// user
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<HashMap<String, Value>>,
    /// team
    #[serde(skip_serializing_if="Option::is_none")]
    pub team: Option<HashMap<String, Value>>,
    /// channel
    #[serde(skip_serializing_if="Option::is_none")]
    pub channel: Option<HashMap<String, Value>>,
}

impl Default for Channel {
    fn default() -> Self {
        Self {
            _type: String::from("channel"),
            user: Default::default(),
            team: Default::default(),
            channel: Default::default(),
        }
    }
}

impl Channel {
    fn _type_default() -> String {
        String::from("channel")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ConferenceBridge {     
    /// The phone number of the conference call for the conference bridge. Phone numbers should be formatted like +1 415-555-1212,,,,1234#, where a comma (,) represents a one-second wait and pound (#) completes access code input.
    #[serde(skip_serializing_if="Option::is_none")]
    pub conference_number: Option<String>,
    /// An URL for the conference bridge. This could be a link to a web conference or Slack channel.
    #[serde(skip_serializing_if="Option::is_none")]
    pub conference_url: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContactMethod {     
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The type of contact method being created.
    #[serde(rename = "type")]
    pub _type: ContactMethodTypeEnum,
    /// The label (e.g., \"Work\", \"Mobile\", etc.).
    #[serde(default="ContactMethod::label_default")]
    pub label: String,
    /// The \"address\" to deliver to: email, phone number, etc., depending on the type.
    #[serde(skip_serializing_if="String::is_empty")]
    pub address: String,
}

impl Default for ContactMethod {
    fn default() -> Self {
        Self {
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            label: String::from("ContactMethod"),
            address: Default::default(),
        }
    }
}

impl ContactMethod {
    fn label_default() -> String {
        String::from("ContactMethod")
    }
    fn _type_default() -> String {
        String::from("contact_method")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ContactMethodTypeEnum { 
    #[serde(rename = "email_contact_method")]
    EMAIL_CONTACT_METHOD,
    #[serde(rename = "phone_contact_method")]
    PHONE_CONTACT_METHOD,
    #[serde(rename = "push_notification_contact_method")]
    PUSH_NOTIFICATION_CONTACT_METHOD,
    #[serde(rename = "sms_contact_method")]
    SMS_CONTACT_METHOD,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ContactMethodTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ContactMethodTypeEnum::EMAIL_CONTACT_METHOD => write!(f, "{}", "email_contact_method"),
            ContactMethodTypeEnum::PHONE_CONTACT_METHOD => write!(f, "{}", "phone_contact_method"),
            ContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD => write!(f, "{}", "push_notification_contact_method"),
            ContactMethodTypeEnum::SMS_CONTACT_METHOD => write!(f, "{}", "sms_contact_method"),
            ContactMethodTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ContactMethodTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "email_contact_method" => Ok(ContactMethodTypeEnum::EMAIL_CONTACT_METHOD),
            "phone_contact_method" => Ok(ContactMethodTypeEnum::PHONE_CONTACT_METHOD),
            "push_notification_contact_method" => Ok(ContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD),
            "sms_contact_method" => Ok(ContactMethodTypeEnum::SMS_CONTACT_METHOD),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ContactMethodTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ContactMethodTypeEnum::EMAIL_CONTACT_METHOD => "email_contact_method",
            ContactMethodTypeEnum::PHONE_CONTACT_METHOD => "phone_contact_method",
            ContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD => "push_notification_contact_method",
            ContactMethodTypeEnum::SMS_CONTACT_METHOD => "sms_contact_method",
            ContactMethodTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ContactMethodTypeEnum {
    fn default() -> Self {
        ContactMethodTypeEnum::EMAIL_CONTACT_METHOD
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContactMethodReference {     
    /// The label of the tag.
    #[serde(default="ContactMethodReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: ContactMethodReferenceTypeEnum,
}

impl Default for ContactMethodReference {
    fn default() -> Self {
        Self {
            label: String::from("ContactMethodReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl ContactMethodReference {
    fn label_default() -> String {
        String::from("ContactMethodReference")
    }
    fn _type_default() -> String {
        String::from("contact_method_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ContactMethodReferenceTypeEnum { 
    #[serde(rename = "email_contact_method_reference")]
    EMAIL_CONTACT_METHOD_REFERENCE,
    #[serde(rename = "phone_contact_method_reference")]
    PHONE_CONTACT_METHOD_REFERENCE,
    #[serde(rename = "push_notification_contact_method_reference")]
    PUSH_NOTIFICATION_CONTACT_METHOD_REFERENCE,
    #[serde(rename = "sms_contact_method_reference")]
    SMS_CONTACT_METHOD_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ContactMethodReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ContactMethodReferenceTypeEnum::EMAIL_CONTACT_METHOD_REFERENCE => write!(f, "{}", "email_contact_method_reference"),
            ContactMethodReferenceTypeEnum::PHONE_CONTACT_METHOD_REFERENCE => write!(f, "{}", "phone_contact_method_reference"),
            ContactMethodReferenceTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD_REFERENCE => write!(f, "{}", "push_notification_contact_method_reference"),
            ContactMethodReferenceTypeEnum::SMS_CONTACT_METHOD_REFERENCE => write!(f, "{}", "sms_contact_method_reference"),
            ContactMethodReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ContactMethodReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "email_contact_method_reference" => Ok(ContactMethodReferenceTypeEnum::EMAIL_CONTACT_METHOD_REFERENCE),
            "phone_contact_method_reference" => Ok(ContactMethodReferenceTypeEnum::PHONE_CONTACT_METHOD_REFERENCE),
            "push_notification_contact_method_reference" => Ok(ContactMethodReferenceTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD_REFERENCE),
            "sms_contact_method_reference" => Ok(ContactMethodReferenceTypeEnum::SMS_CONTACT_METHOD_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ContactMethodReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ContactMethodReferenceTypeEnum::EMAIL_CONTACT_METHOD_REFERENCE => "email_contact_method_reference",
            ContactMethodReferenceTypeEnum::PHONE_CONTACT_METHOD_REFERENCE => "phone_contact_method_reference",
            ContactMethodReferenceTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD_REFERENCE => "push_notification_contact_method_reference",
            ContactMethodReferenceTypeEnum::SMS_CONTACT_METHOD_REFERENCE => "sms_contact_method_reference",
            ContactMethodReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ContactMethodReferenceTypeEnum {
    fn default() -> Self {
        ContactMethodReferenceTypeEnum::EMAIL_CONTACT_METHOD_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateUserContactMethod {     
    pub contact_method: ContactMethodsContactMethodIdBodyContactMethod,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Context {     
    /// The type of context being attached to the incident.
    #[serde(rename = "type")]
    pub _type: ContextTypeEnum,
    /// The link's target url
    #[serde(skip_serializing_if="Option::is_none")]
    pub href: Option<String>,
    /// The image's source url
    #[serde(skip_serializing_if="Option::is_none")]
    pub src: Option<String>,
    /// The alternate display for an image
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ContextTypeEnum { 
    #[serde(rename = "link")]
    LINK,
    #[serde(rename = "image")]
    IMAGE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ContextTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ContextTypeEnum::LINK => write!(f, "{}", "link"),
            ContextTypeEnum::IMAGE => write!(f, "{}", "image"),
            ContextTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ContextTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "link" => Ok(ContextTypeEnum::LINK),
            "image" => Ok(ContextTypeEnum::IMAGE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ContextTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ContextTypeEnum::LINK => "link",
            ContextTypeEnum::IMAGE => "image",
            ContextTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ContextTypeEnum {
    fn default() -> Self {
        ContextTypeEnum::LINK
    }
}

/// The Email Contact Method of the User.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct EmailContactMethod {     
    #[serde(rename = "type")]
    pub _type: EmailContactMethodTypeEnum,
    /// The label (e.g., \"Work\", \"Mobile\", etc.).
    #[serde(default="EmailContactMethod::label_default")]
    pub label: String,
    /// The \"address\" to deliver to: email, phone number, etc., depending on the type.
    #[serde(skip_serializing_if="String::is_empty")]
    pub address: String,
    /// Send an abbreviated email message instead of the standard email output. Useful for email-to-SMS gateways and email based pagers.
    #[serde(skip_serializing_if="Option::is_none")]
    pub send_short_email: Option<bool>,
}

impl Default for EmailContactMethod {
    fn default() -> Self {
        Self {
            _type: Default::default(),
            label: String::from("EmailContactMethod"),
            address: Default::default(),
            send_short_email: Default::default(),
        }
    }
}

impl EmailContactMethod {
    fn label_default() -> String {
        String::from("EmailContactMethod")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EmailContactMethodTypeEnum { 
    #[serde(rename = "email_contact_method")]
    EMAIL_CONTACT_METHOD,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EmailContactMethodTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            EmailContactMethodTypeEnum::EMAIL_CONTACT_METHOD => write!(f, "{}", "email_contact_method"),
            EmailContactMethodTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for EmailContactMethodTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "email_contact_method" => Ok(EmailContactMethodTypeEnum::EMAIL_CONTACT_METHOD),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EmailContactMethodTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            EmailContactMethodTypeEnum::EMAIL_CONTACT_METHOD => "email_contact_method",
            EmailContactMethodTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EmailContactMethodTypeEnum {
    fn default() -> Self {
        EmailContactMethodTypeEnum::EMAIL_CONTACT_METHOD
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct EntityReference {     
    /// The label of the tag.
    #[serde(default="EntityReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: EntityReferenceTypeEnum,
}

impl Default for EntityReference {
    fn default() -> Self {
        Self {
            label: String::from("EntityReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl EntityReference {
    fn label_default() -> String {
        String::from("EntityReference")
    }
    fn _type_default() -> String {
        String::from("entity_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EntityReferenceTypeEnum { 
    #[serde(rename = "user_reference")]
    USER_REFERENCE,
    #[serde(rename = "team_reference")]
    TEAM_REFERENCE,
    #[serde(rename = "escalation_policy_reference")]
    ESCALATION_POLICY_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EntityReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            EntityReferenceTypeEnum::USER_REFERENCE => write!(f, "{}", "user_reference"),
            EntityReferenceTypeEnum::TEAM_REFERENCE => write!(f, "{}", "team_reference"),
            EntityReferenceTypeEnum::ESCALATION_POLICY_REFERENCE => write!(f, "{}", "escalation_policy_reference"),
            EntityReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for EntityReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "user_reference" => Ok(EntityReferenceTypeEnum::USER_REFERENCE),
            "team_reference" => Ok(EntityReferenceTypeEnum::TEAM_REFERENCE),
            "escalation_policy_reference" => Ok(EntityReferenceTypeEnum::ESCALATION_POLICY_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EntityReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            EntityReferenceTypeEnum::USER_REFERENCE => "user_reference",
            EntityReferenceTypeEnum::TEAM_REFERENCE => "team_reference",
            EntityReferenceTypeEnum::ESCALATION_POLICY_REFERENCE => "escalation_policy_reference",
            EntityReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EntityReferenceTypeEnum {
    fn default() -> Self {
        EntityReferenceTypeEnum::USER_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct EscalateLogEntry {     
    #[serde(rename = "type")]
    pub _type: EscalateLogEntryTypeEnum,
    /// Time at which the log entry was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub channel: Option<Channel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub agent: Option<AgentReference>,
    /// Optional field containing a note, if one was included with the log entry.
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<String>,
    /// Contexts to be included with the trigger such as links to graphs or images.
    #[serde(skip_serializing_if="Option::is_none")]
    pub contexts: Option<Vec<Context>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub service: Option<ServiceReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident: Option<IncidentReference>,
    /// Will consist of references unless included
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_details: Option<LogEntryEventDetails>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assigned_user: Option<UserReference>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EscalateLogEntryTypeEnum { 
    #[serde(rename = "escalate_log_entry")]
    ESCALATE_LOG_ENTRY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EscalateLogEntryTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            EscalateLogEntryTypeEnum::ESCALATE_LOG_ENTRY => write!(f, "{}", "escalate_log_entry"),
            EscalateLogEntryTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for EscalateLogEntryTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "escalate_log_entry" => Ok(EscalateLogEntryTypeEnum::ESCALATE_LOG_ENTRY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EscalateLogEntryTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            EscalateLogEntryTypeEnum::ESCALATE_LOG_ENTRY => "escalate_log_entry",
            EscalateLogEntryTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EscalateLogEntryTypeEnum {
    fn default() -> Self {
        EscalateLogEntryTypeEnum::ESCALATE_LOG_ENTRY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateEscalationPolicy {     
    pub escalation_policy: EscalationPolicy,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateEscalationPolicy {     
    pub escalation_policy: EscalationPolicy,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct EscalationPolicy {     
    /// The label of the tag.
    #[serde(default="EscalationPolicy::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: EscalationPolicyTypeEnum,
    /// The name of the escalation policy.
    #[serde(skip_serializing_if="String::is_empty")]
    pub name: String,
    /// Escalation policy description.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The number of times the escalation policy will repeat after reaching the end of its escalation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub num_loops: Option<usize>,
    /// Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to \"if_has_services\".
    #[serde(skip_serializing_if="Option::is_none")]
    pub on_call_handoff_notifications: Option<EscalationPolicyOnCallHandoffNotificationsEnum>,
    pub escalation_rules: Vec<EscalationRule>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub services: Option<Vec<ServiceReference>>,
    /// Teams associated with the policy. Account must have the `teams` ability to use this parameter.
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
}

impl Default for EscalationPolicy {
    fn default() -> Self {
        Self {
            label: String::from("EscalationPolicy"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            name: Default::default(),
            description: Default::default(),
            num_loops: Default::default(),
            on_call_handoff_notifications: Default::default(),
            escalation_rules: Default::default(),
            services: Default::default(),
            teams: Default::default(),
        }
    }
}

impl EscalationPolicy {
    fn label_default() -> String {
        String::from("EscalationPolicy")
    }
    fn _type_default() -> String {
        String::from("escalation_policy")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EscalationPolicyTypeEnum { 
    #[serde(rename = "escalation_policy")]
    ESCALATION_POLICY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EscalationPolicyTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            EscalationPolicyTypeEnum::ESCALATION_POLICY => write!(f, "{}", "escalation_policy"),
            EscalationPolicyTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for EscalationPolicyTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "escalation_policy" => Ok(EscalationPolicyTypeEnum::ESCALATION_POLICY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EscalationPolicyTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            EscalationPolicyTypeEnum::ESCALATION_POLICY => "escalation_policy",
            EscalationPolicyTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EscalationPolicyTypeEnum {
    fn default() -> Self {
        EscalationPolicyTypeEnum::ESCALATION_POLICY
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EscalationPolicyOnCallHandoffNotificationsEnum { 
    #[serde(rename = "if_has_services")]
    IF_HAS_SERVICES,
    #[serde(rename = "always")]
    ALWAYS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EscalationPolicyOnCallHandoffNotificationsEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            EscalationPolicyOnCallHandoffNotificationsEnum::IF_HAS_SERVICES => write!(f, "{}", "if_has_services"),
            EscalationPolicyOnCallHandoffNotificationsEnum::ALWAYS => write!(f, "{}", "always"),
            EscalationPolicyOnCallHandoffNotificationsEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for EscalationPolicyOnCallHandoffNotificationsEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "if_has_services" => Ok(EscalationPolicyOnCallHandoffNotificationsEnum::IF_HAS_SERVICES),
            "always" => Ok(EscalationPolicyOnCallHandoffNotificationsEnum::ALWAYS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EscalationPolicyOnCallHandoffNotificationsEnum {
    fn as_ref(&self) -> &str {
        match self { 
            EscalationPolicyOnCallHandoffNotificationsEnum::IF_HAS_SERVICES => "if_has_services",
            EscalationPolicyOnCallHandoffNotificationsEnum::ALWAYS => "always",
            EscalationPolicyOnCallHandoffNotificationsEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EscalationPolicyOnCallHandoffNotificationsEnum {
    fn default() -> Self {
        EscalationPolicyOnCallHandoffNotificationsEnum::IF_HAS_SERVICES
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct EscalationPolicyReference {     
    /// The label of the tag.
    #[serde(default="EscalationPolicyReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: EscalationPolicyReferenceTypeEnum,
}

impl Default for EscalationPolicyReference {
    fn default() -> Self {
        Self {
            label: String::from("EscalationPolicyReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl EscalationPolicyReference {
    fn label_default() -> String {
        String::from("EscalationPolicyReference")
    }
    fn _type_default() -> String {
        String::from("escalation_policy_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EscalationPolicyReferenceTypeEnum { 
    #[serde(rename = "escalation_policy_reference")]
    ESCALATION_POLICY_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EscalationPolicyReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            EscalationPolicyReferenceTypeEnum::ESCALATION_POLICY_REFERENCE => write!(f, "{}", "escalation_policy_reference"),
            EscalationPolicyReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for EscalationPolicyReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "escalation_policy_reference" => Ok(EscalationPolicyReferenceTypeEnum::ESCALATION_POLICY_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EscalationPolicyReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            EscalationPolicyReferenceTypeEnum::ESCALATION_POLICY_REFERENCE => "escalation_policy_reference",
            EscalationPolicyReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EscalationPolicyReferenceTypeEnum {
    fn default() -> Self {
        EscalationPolicyReferenceTypeEnum::ESCALATION_POLICY_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct EscalationRule {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The number of minutes before an unacknowledged incident escalates away from this rule.
    pub escalation_delay_in_minutes: isize,
    /// The targets an incident should be assigned to upon reaching this rule.
    pub targets: Vec<EscalationTargetReference>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct EscalationTargetReference {     
    /// The label of the tag.
    #[serde(default="EscalationTargetReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: EscalationTargetReferenceTypeEnum,
}

impl Default for EscalationTargetReference {
    fn default() -> Self {
        Self {
            label: String::from("EscalationTargetReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl EscalationTargetReference {
    fn label_default() -> String {
        String::from("EscalationTargetReference")
    }
    fn _type_default() -> String {
        String::from("escalation_target_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EscalationTargetReferenceTypeEnum { 
    #[serde(rename = "user")]
    USER,
    #[serde(rename = "schedule")]
    SCHEDULE,
    #[serde(rename = "user_reference")]
    USER_REFERENCE,
    #[serde(rename = "schedule_reference")]
    SCHEDULE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EscalationTargetReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            EscalationTargetReferenceTypeEnum::USER => write!(f, "{}", "user"),
            EscalationTargetReferenceTypeEnum::SCHEDULE => write!(f, "{}", "schedule"),
            EscalationTargetReferenceTypeEnum::USER_REFERENCE => write!(f, "{}", "user_reference"),
            EscalationTargetReferenceTypeEnum::SCHEDULE_REFERENCE => write!(f, "{}", "schedule_reference"),
            EscalationTargetReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for EscalationTargetReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "user" => Ok(EscalationTargetReferenceTypeEnum::USER),
            "schedule" => Ok(EscalationTargetReferenceTypeEnum::SCHEDULE),
            "user_reference" => Ok(EscalationTargetReferenceTypeEnum::USER_REFERENCE),
            "schedule_reference" => Ok(EscalationTargetReferenceTypeEnum::SCHEDULE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EscalationTargetReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            EscalationTargetReferenceTypeEnum::USER => "user",
            EscalationTargetReferenceTypeEnum::SCHEDULE => "schedule",
            EscalationTargetReferenceTypeEnum::USER_REFERENCE => "user_reference",
            EscalationTargetReferenceTypeEnum::SCHEDULE_REFERENCE => "schedule_reference",
            EscalationTargetReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EscalationTargetReferenceTypeEnum {
    fn default() -> Self {
        EscalationTargetReferenceTypeEnum::USER
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Extension {     
    /// The label of the tag.
    #[serde(default="Extension::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The name of the extension.
    #[serde(skip_serializing_if="String::is_empty")]
    pub name: String,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: ExtensionTypeEnum,
    /// The url of the extension.
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoint_url: Option<String>,
    /// The objects for which the extension applies
    pub extension_objects: Vec<ServiceReference>,
    pub extension_schema: ExtensionSchemaReference,
    /// Whether or not this extension is temporarily disabled; for example, a webhook extension that is repeatedly rejected by the server.
    #[serde(skip_serializing_if="Option::is_none")]
    pub temporarily_disabled: Option<bool>,
    /// The object that contains extension configuration values depending on the extension schema specification.
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<HashMap<String, Value>>,
}

impl Default for Extension {
    fn default() -> Self {
        Self {
            label: String::from("Extension"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            name: Default::default(),
            _type: Default::default(),
            endpoint_url: Default::default(),
            extension_objects: Default::default(),
            extension_schema: Default::default(),
            temporarily_disabled: Default::default(),
            config: Default::default(),
        }
    }
}

impl Extension {
    fn label_default() -> String {
        String::from("Extension")
    }
    fn _type_default() -> String {
        String::from("extension")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ExtensionTypeEnum { 
    #[serde(rename = "extension")]
    EXTENSION,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ExtensionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ExtensionTypeEnum::EXTENSION => write!(f, "{}", "extension"),
            ExtensionTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ExtensionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "extension" => Ok(ExtensionTypeEnum::EXTENSION),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ExtensionTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ExtensionTypeEnum::EXTENSION => "extension",
            ExtensionTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ExtensionTypeEnum {
    fn default() -> Self {
        ExtensionTypeEnum::EXTENSION
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ExtensionReference {     
    /// The label of the tag.
    #[serde(default="ExtensionReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: ExtensionReferenceTypeEnum,
}

impl Default for ExtensionReference {
    fn default() -> Self {
        Self {
            label: String::from("ExtensionReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl ExtensionReference {
    fn label_default() -> String {
        String::from("ExtensionReference")
    }
    fn _type_default() -> String {
        String::from("extension_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ExtensionReferenceTypeEnum { 
    #[serde(rename = "extension_reference")]
    EXTENSION_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ExtensionReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ExtensionReferenceTypeEnum::EXTENSION_REFERENCE => write!(f, "{}", "extension_reference"),
            ExtensionReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ExtensionReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "extension_reference" => Ok(ExtensionReferenceTypeEnum::EXTENSION_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ExtensionReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ExtensionReferenceTypeEnum::EXTENSION_REFERENCE => "extension_reference",
            ExtensionReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ExtensionReferenceTypeEnum {
    fn default() -> Self {
        ExtensionReferenceTypeEnum::EXTENSION_REFERENCE
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ExtensionSchema {     
    /// A small logo, 18-by-18 pixels.
    #[serde(skip_serializing_if="Option::is_none")]
    pub icon_url: Option<String>,
    /// A large logo, 75 pixels high and no more than 300 pixels wide.
    #[serde(skip_serializing_if="Option::is_none")]
    pub logo_url: Option<String>,
    /// Human friendly display label
    #[serde(default="ExtensionSchema::label_default")]
    pub label: String,
    /// Machine friendly display label
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    /// The long description for the Extension
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// A link to the extension's support guide
    #[serde(skip_serializing_if="Option::is_none")]
    pub guide_url: Option<String>,
    /// The types of PagerDuty incident events that will activate this Extension
    #[serde(skip_serializing_if="Option::is_none")]
    pub send_types: Option<ExtensionSchemaSendTypesEnum>,
    /// The url that the webhook payload will be sent to for this Extension.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

impl Default for ExtensionSchema {
    fn default() -> Self {
        Self {
            icon_url: Default::default(),
            logo_url: Default::default(),
            label: String::from("ExtensionSchema"),
            key: Default::default(),
            description: Default::default(),
            guide_url: Default::default(),
            send_types: Default::default(),
            url: Default::default(),
        }
    }
}

impl ExtensionSchema {
    fn label_default() -> String {
        String::from("ExtensionSchema")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ExtensionSchemaSendTypesEnum { 
    #[serde(rename = "trigger")]
    TRIGGER,
    #[serde(rename = "acknowledge")]
    ACKNOWLEDGE,
    #[serde(rename = "resolve")]
    RESOLVE,
    #[serde(rename = "delegate")]
    DELEGATE,
    #[serde(rename = "escalate")]
    ESCALATE,
    #[serde(rename = "unacknowledge")]
    UNACKNOWLEDGE,
    #[serde(rename = "assign")]
    ASSIGN,
    #[serde(rename = "custom")]
    CUSTOM,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ExtensionSchemaSendTypesEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ExtensionSchemaSendTypesEnum::TRIGGER => write!(f, "{}", "trigger"),
            ExtensionSchemaSendTypesEnum::ACKNOWLEDGE => write!(f, "{}", "acknowledge"),
            ExtensionSchemaSendTypesEnum::RESOLVE => write!(f, "{}", "resolve"),
            ExtensionSchemaSendTypesEnum::DELEGATE => write!(f, "{}", "delegate"),
            ExtensionSchemaSendTypesEnum::ESCALATE => write!(f, "{}", "escalate"),
            ExtensionSchemaSendTypesEnum::UNACKNOWLEDGE => write!(f, "{}", "unacknowledge"),
            ExtensionSchemaSendTypesEnum::ASSIGN => write!(f, "{}", "assign"),
            ExtensionSchemaSendTypesEnum::CUSTOM => write!(f, "{}", "custom"),
            ExtensionSchemaSendTypesEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ExtensionSchemaSendTypesEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "trigger" => Ok(ExtensionSchemaSendTypesEnum::TRIGGER),
            "acknowledge" => Ok(ExtensionSchemaSendTypesEnum::ACKNOWLEDGE),
            "resolve" => Ok(ExtensionSchemaSendTypesEnum::RESOLVE),
            "delegate" => Ok(ExtensionSchemaSendTypesEnum::DELEGATE),
            "escalate" => Ok(ExtensionSchemaSendTypesEnum::ESCALATE),
            "unacknowledge" => Ok(ExtensionSchemaSendTypesEnum::UNACKNOWLEDGE),
            "assign" => Ok(ExtensionSchemaSendTypesEnum::ASSIGN),
            "custom" => Ok(ExtensionSchemaSendTypesEnum::CUSTOM),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ExtensionSchemaSendTypesEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ExtensionSchemaSendTypesEnum::TRIGGER => "trigger",
            ExtensionSchemaSendTypesEnum::ACKNOWLEDGE => "acknowledge",
            ExtensionSchemaSendTypesEnum::RESOLVE => "resolve",
            ExtensionSchemaSendTypesEnum::DELEGATE => "delegate",
            ExtensionSchemaSendTypesEnum::ESCALATE => "escalate",
            ExtensionSchemaSendTypesEnum::UNACKNOWLEDGE => "unacknowledge",
            ExtensionSchemaSendTypesEnum::ASSIGN => "assign",
            ExtensionSchemaSendTypesEnum::CUSTOM => "custom",
            ExtensionSchemaSendTypesEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ExtensionSchemaSendTypesEnum {
    fn default() -> Self {
        ExtensionSchemaSendTypesEnum::TRIGGER
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ExtensionSchemaReference {     
    /// The label of the tag.
    #[serde(default="ExtensionSchemaReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: ExtensionSchemaReferenceTypeEnum,
}

impl Default for ExtensionSchemaReference {
    fn default() -> Self {
        Self {
            label: String::from("ExtensionSchemaReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl ExtensionSchemaReference {
    fn label_default() -> String {
        String::from("ExtensionSchemaReference")
    }
    fn _type_default() -> String {
        String::from("extension_schema_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ExtensionSchemaReferenceTypeEnum { 
    #[serde(rename = "extension_schema_reference")]
    EXTENSION_SCHEMA_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ExtensionSchemaReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ExtensionSchemaReferenceTypeEnum::EXTENSION_SCHEMA_REFERENCE => write!(f, "{}", "extension_schema_reference"),
            ExtensionSchemaReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ExtensionSchemaReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "extension_schema_reference" => Ok(ExtensionSchemaReferenceTypeEnum::EXTENSION_SCHEMA_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ExtensionSchemaReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ExtensionSchemaReferenceTypeEnum::EXTENSION_SCHEMA_REFERENCE => "extension_schema_reference",
            ExtensionSchemaReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ExtensionSchemaReferenceTypeEnum {
    fn default() -> Self {
        ExtensionSchemaReferenceTypeEnum::EXTENSION_SCHEMA_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateExtension {     
    pub extension: Extension,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateExtension {     
    pub extension: Extension,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateIncidentAlerts {     
    /// An array of alerts, including the parameters to update for each alert.
    pub alerts: Vec<Alert>,
}

/// Tags to add to or remove from the entity.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateEntityTypeByIdChangeTags {     
    /// Array of tags and/or tag references to add to the entity. For elements with type `tag_reference`, the tag with the corresponding `id` is added to the entity. For elements with type `tag`, if there is an existing tag with the given label that tag is added to the entity. If there is no existing tag with that label and the user has permission to create tags, a new tag is created with that label and assigned to the entity. 
    #[serde(skip_serializing_if="Option::is_none")]
    pub add: Option<Vec<TagsToAdd>>,
    /// Array of tag references to remove from the entity.
    #[serde(skip_serializing_if="Option::is_none")]
    pub remove: Option<Vec<TagsToRemove_>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateLogEntryChannel {     
    pub channel: LogEntriesidchannelChannel,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateUserContactMethod {     
    pub contact_method: IdContactMethodsBodyContactMethod,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateServiceIntegration {     
    pub integration: Integration,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MergeIncidents {     
    /// The source incidents that will be merged into the target incident and resolved.
    pub source_incidents: Vec<IncidentReference>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateIncidentNote {     
    pub note: IncidentNote,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateUserNotificationRule {     
    pub notification_rule: NotificationRule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateScheduleOverride {     
    #[serde(rename = "override")]
    pub _override: ModelOverride,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateIncidentResponderRequest {     
    /// The user id of the requester.
    #[serde(skip_serializing_if="String::is_empty")]
    pub requester_id: String,
    /// The message sent with the responder request.
    #[serde(skip_serializing_if="String::is_empty")]
    pub message: String,
    /// The array of targets the responder request is sent to.
    pub responder_request_targets: Vec<ResponderRequestTargetReference>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateRulesetEventRule {     
    pub rule: RulesetsidrulesRule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateIncidentSnooze {     
    /// The number of seconds to snooze the incident for. After this number of seconds has elapsed, the incident will return to the \"triggered\" state.
    pub duration: isize,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateUserStatusUpdateNotificationRule {     
    pub status_update_notification_rule: UsersidstatusUpdateNotificationRulesStatusUpdateNotificationRule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateIncidentStatusUpdate {     
    /// The message to be posted as a status update.
    #[serde(skip_serializing_if="String::is_empty")]
    pub message: String,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Incident {     
    /// The label of the tag.
    #[serde(default="Incident::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default="Incident::_type_default")]
    pub _type: String,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The number of the incident. This is unique across your account.
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident_number: Option<isize>,
    /// The date/time the incident was first triggered.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The current status of the incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<IncidentStatusEnum>,
    /// A succinct description of the nature, symptoms, cause, or effect of the incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// The list of pending_actions on the incident. A pending_action object contains a type of action which can be escalate, unacknowledge, resolve or urgency_change. A pending_action object contains at, the time at which the action will take place. An urgency_change pending_action will contain to, the urgency that the incident will change to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pending_actions: Option<Vec<IncidentAction>>,
    /// The incident's de-duplication key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident_key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub service: Option<ServiceReference>,
    /// List of all assignments for this incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignments: Option<Vec<Assignment>>,
    /// How the current incident assignments were decided.  Note that `direct_assignment` incidents will not escalate up the attached `escalation_policy`
    #[serde(skip_serializing_if="Option::is_none")]
    pub assigned_via: Option<IncidentAssignedViaEnum>,
    /// List of all acknowledgements for this incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub acknowledgements: Option<Vec<Acknowledgement>>,
    /// The time at which the status of the incident last changed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_status_change_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_status_change_by: Option<AgentReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub first_trigger_log_entry: Option<LogEntryReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub escalation_policy: Option<EscalationPolicyReference>,
    /// The teams involved in the incident’s lifecycle.
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority: Option<PriorityReference>,
    /// The current urgency of the incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub urgency: Option<IncidentUrgencyEnum>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolve_reason: Option<ResolveReason>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert_counts: Option<AlertCount>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conference_bridge: Option<ConferenceBridge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<IncidentBody>,
}

impl Default for Incident {
    fn default() -> Self {
        Self {
            label: String::from("Incident"),
            html_url: Default::default(),
            _self: Default::default(),
            _type: String::from("incident"),
            summary: Default::default(),
            id: Default::default(),
            incident_number: Default::default(),
            created_at: Default::default(),
            status: Default::default(),
            title: Default::default(),
            pending_actions: Default::default(),
            incident_key: Default::default(),
            service: Default::default(),
            assignments: Default::default(),
            assigned_via: Default::default(),
            acknowledgements: Default::default(),
            last_status_change_at: Default::default(),
            last_status_change_by: Default::default(),
            first_trigger_log_entry: Default::default(),
            escalation_policy: Default::default(),
            teams: Default::default(),
            priority: Default::default(),
            urgency: Default::default(),
            resolve_reason: Default::default(),
            alert_counts: Default::default(),
            conference_bridge: Default::default(),
            body: Default::default(),
        }
    }
}

impl Incident {
    fn label_default() -> String {
        String::from("Incident")
    }
    fn _type_default() -> String {
        String::from("incident")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentStatusEnum { 
    #[serde(rename = "triggered")]
    TRIGGERED,
    #[serde(rename = "acknowledged")]
    ACKNOWLEDGED,
    #[serde(rename = "resolved")]
    RESOLVED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentStatusEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentStatusEnum::TRIGGERED => write!(f, "{}", "triggered"),
            IncidentStatusEnum::ACKNOWLEDGED => write!(f, "{}", "acknowledged"),
            IncidentStatusEnum::RESOLVED => write!(f, "{}", "resolved"),
            IncidentStatusEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentStatusEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "triggered" => Ok(IncidentStatusEnum::TRIGGERED),
            "acknowledged" => Ok(IncidentStatusEnum::ACKNOWLEDGED),
            "resolved" => Ok(IncidentStatusEnum::RESOLVED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentStatusEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentStatusEnum::TRIGGERED => "triggered",
            IncidentStatusEnum::ACKNOWLEDGED => "acknowledged",
            IncidentStatusEnum::RESOLVED => "resolved",
            IncidentStatusEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentStatusEnum {
    fn default() -> Self {
        IncidentStatusEnum::TRIGGERED
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentAssignedViaEnum { 
    #[serde(rename = "escalation_policy")]
    ESCALATION_POLICY,
    #[serde(rename = "direct_assignment")]
    DIRECT_ASSIGNMENT,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentAssignedViaEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentAssignedViaEnum::ESCALATION_POLICY => write!(f, "{}", "escalation_policy"),
            IncidentAssignedViaEnum::DIRECT_ASSIGNMENT => write!(f, "{}", "direct_assignment"),
            IncidentAssignedViaEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentAssignedViaEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "escalation_policy" => Ok(IncidentAssignedViaEnum::ESCALATION_POLICY),
            "direct_assignment" => Ok(IncidentAssignedViaEnum::DIRECT_ASSIGNMENT),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentAssignedViaEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentAssignedViaEnum::ESCALATION_POLICY => "escalation_policy",
            IncidentAssignedViaEnum::DIRECT_ASSIGNMENT => "direct_assignment",
            IncidentAssignedViaEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentAssignedViaEnum {
    fn default() -> Self {
        IncidentAssignedViaEnum::ESCALATION_POLICY
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentUrgencyEnum { 
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentUrgencyEnum::HIGH => write!(f, "{}", "high"),
            IncidentUrgencyEnum::LOW => write!(f, "{}", "low"),
            IncidentUrgencyEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "high" => Ok(IncidentUrgencyEnum::HIGH),
            "low" => Ok(IncidentUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentUrgencyEnum::HIGH => "high",
            IncidentUrgencyEnum::LOW => "low",
            IncidentUrgencyEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentUrgencyEnum {
    fn default() -> Self {
        IncidentUrgencyEnum::HIGH
    }
}

/// An incident action is a pending change to an incident that will automatically happen at some future time.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IncidentAction {     
    #[serde(rename = "type")]
    pub _type: IncidentActionTypeEnum,
    #[serde(skip_serializing_if="Option::is_none")]
    pub at: Option<chrono::DateTime<chrono::Utc>>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentActionTypeEnum { 
    #[serde(rename = "unacknowledge")]
    UNACKNOWLEDGE,
    #[serde(rename = "escalate")]
    ESCALATE,
    #[serde(rename = "resolve")]
    RESOLVE,
    #[serde(rename = "urgency_change")]
    URGENCY_CHANGE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentActionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentActionTypeEnum::UNACKNOWLEDGE => write!(f, "{}", "unacknowledge"),
            IncidentActionTypeEnum::ESCALATE => write!(f, "{}", "escalate"),
            IncidentActionTypeEnum::RESOLVE => write!(f, "{}", "resolve"),
            IncidentActionTypeEnum::URGENCY_CHANGE => write!(f, "{}", "urgency_change"),
            IncidentActionTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentActionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "unacknowledge" => Ok(IncidentActionTypeEnum::UNACKNOWLEDGE),
            "escalate" => Ok(IncidentActionTypeEnum::ESCALATE),
            "resolve" => Ok(IncidentActionTypeEnum::RESOLVE),
            "urgency_change" => Ok(IncidentActionTypeEnum::URGENCY_CHANGE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentActionTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentActionTypeEnum::UNACKNOWLEDGE => "unacknowledge",
            IncidentActionTypeEnum::ESCALATE => "escalate",
            IncidentActionTypeEnum::RESOLVE => "resolve",
            IncidentActionTypeEnum::URGENCY_CHANGE => "urgency_change",
            IncidentActionTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentActionTypeEnum {
    fn default() -> Self {
        IncidentActionTypeEnum::UNACKNOWLEDGE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IncidentAddon {     
    /// The type of Add-on.
    #[serde(rename = "type")]
    pub _type: IncidentAddonTypeEnum,
    /// The name of the Add-on.
    #[serde(skip_serializing_if="String::is_empty")]
    pub name: String,
    /// The source URL to display in a frame in the PagerDuty UI. HTTPS is required.
    #[serde(skip_serializing_if="String::is_empty")]
    pub src: String,
    /// The services this Add-on is associated with. If non-empty, the Add-on will appear only on incidents for those services. If empty, it will appear on incidents for all services. 
    #[serde(skip_serializing_if="Option::is_none")]
    pub services: Option<Vec<ServiceReference>>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentAddonTypeEnum { 
    #[serde(rename = "full_page_addon")]
    FULL_PAGE_ADDON,
    #[serde(rename = "incident_show_addon")]
    INCIDENT_SHOW_ADDON,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentAddonTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentAddonTypeEnum::FULL_PAGE_ADDON => write!(f, "{}", "full_page_addon"),
            IncidentAddonTypeEnum::INCIDENT_SHOW_ADDON => write!(f, "{}", "incident_show_addon"),
            IncidentAddonTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentAddonTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "full_page_addon" => Ok(IncidentAddonTypeEnum::FULL_PAGE_ADDON),
            "incident_show_addon" => Ok(IncidentAddonTypeEnum::INCIDENT_SHOW_ADDON),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentAddonTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentAddonTypeEnum::FULL_PAGE_ADDON => "full_page_addon",
            IncidentAddonTypeEnum::INCIDENT_SHOW_ADDON => "incident_show_addon",
            IncidentAddonTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentAddonTypeEnum {
    fn default() -> Self {
        IncidentAddonTypeEnum::FULL_PAGE_ADDON
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IncidentBody {     
    #[serde(rename = "type")]
    pub _type: IncidentBodyTypeEnum,
    /// Additional incident details.
    #[serde(skip_serializing_if="Option::is_none")]
    pub details: Option<String>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentBodyTypeEnum { 
    #[serde(rename = "incident_body")]
    INCIDENT_BODY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentBodyTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentBodyTypeEnum::INCIDENT_BODY => write!(f, "{}", "incident_body"),
            IncidentBodyTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentBodyTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "incident_body" => Ok(IncidentBodyTypeEnum::INCIDENT_BODY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentBodyTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentBodyTypeEnum::INCIDENT_BODY => "incident_body",
            IncidentBodyTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentBodyTypeEnum {
    fn default() -> Self {
        IncidentBodyTypeEnum::INCIDENT_BODY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IncidentNote {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<UserReference>,
    /// The note content
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
    /// The time at which the note was submitted
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct IncidentReference {     
    /// The label of the tag.
    #[serde(default="IncidentReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: IncidentReferenceTypeEnum,
}

impl Default for IncidentReference {
    fn default() -> Self {
        Self {
            label: String::from("IncidentReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl IncidentReference {
    fn label_default() -> String {
        String::from("IncidentReference")
    }
    fn _type_default() -> String {
        String::from("incident_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentReferenceTypeEnum { 
    #[serde(rename = "incident_reference")]
    INCIDENT_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentReferenceTypeEnum::INCIDENT_REFERENCE => write!(f, "{}", "incident_reference"),
            IncidentReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "incident_reference" => Ok(IncidentReferenceTypeEnum::INCIDENT_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentReferenceTypeEnum::INCIDENT_REFERENCE => "incident_reference",
            IncidentReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentReferenceTypeEnum {
    fn default() -> Self {
        IncidentReferenceTypeEnum::INCIDENT_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IncidentUrgencyRule {     
    /// The type of incident urgency: whether it's constant, or it's dependent on the support hours.
    #[serde(rename = "type")]
    pub _type: IncidentUrgencyRuleTypeEnum,
    /// The incidents' urgency, if type is constant.
    #[serde(skip_serializing_if="Option::is_none")]
    pub urgency: Option<IncidentUrgencyRuleUrgencyEnum>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub during_support_hours: Option<IncidentUrgencyType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub outside_support_hours: Option<IncidentUrgencyType>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentUrgencyRuleTypeEnum { 
    #[serde(rename = "constant")]
    CONSTANT,
    #[serde(rename = "use_support_hours")]
    USE_SUPPORT_HOURS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentUrgencyRuleTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentUrgencyRuleTypeEnum::CONSTANT => write!(f, "{}", "constant"),
            IncidentUrgencyRuleTypeEnum::USE_SUPPORT_HOURS => write!(f, "{}", "use_support_hours"),
            IncidentUrgencyRuleTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentUrgencyRuleTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "constant" => Ok(IncidentUrgencyRuleTypeEnum::CONSTANT),
            "use_support_hours" => Ok(IncidentUrgencyRuleTypeEnum::USE_SUPPORT_HOURS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentUrgencyRuleTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentUrgencyRuleTypeEnum::CONSTANT => "constant",
            IncidentUrgencyRuleTypeEnum::USE_SUPPORT_HOURS => "use_support_hours",
            IncidentUrgencyRuleTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentUrgencyRuleTypeEnum {
    fn default() -> Self {
        IncidentUrgencyRuleTypeEnum::CONSTANT
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentUrgencyRuleUrgencyEnum { 
    #[serde(rename = "low")]
    LOW,
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "severity_based")]
    SEVERITY_BASED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentUrgencyRuleUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentUrgencyRuleUrgencyEnum::LOW => write!(f, "{}", "low"),
            IncidentUrgencyRuleUrgencyEnum::HIGH => write!(f, "{}", "high"),
            IncidentUrgencyRuleUrgencyEnum::SEVERITY_BASED => write!(f, "{}", "severity_based"),
            IncidentUrgencyRuleUrgencyEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentUrgencyRuleUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "low" => Ok(IncidentUrgencyRuleUrgencyEnum::LOW),
            "high" => Ok(IncidentUrgencyRuleUrgencyEnum::HIGH),
            "severity_based" => Ok(IncidentUrgencyRuleUrgencyEnum::SEVERITY_BASED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentUrgencyRuleUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentUrgencyRuleUrgencyEnum::LOW => "low",
            IncidentUrgencyRuleUrgencyEnum::HIGH => "high",
            IncidentUrgencyRuleUrgencyEnum::SEVERITY_BASED => "severity_based",
            IncidentUrgencyRuleUrgencyEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentUrgencyRuleUrgencyEnum {
    fn default() -> Self {
        IncidentUrgencyRuleUrgencyEnum::LOW
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IncidentUrgencyType {     
    /// The type of incident urgency: whether it's constant, or it's dependent on the support hours.
    #[serde(rename = "type")]
    pub _type: IncidentUrgencyTypeTypeEnum,
    /// The incidents' urgency, if type is constant.
    #[serde(skip_serializing_if="Option::is_none")]
    pub urgency: Option<IncidentUrgencyTypeUrgencyEnum>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentUrgencyTypeTypeEnum { 
    #[serde(rename = "constant")]
    CONSTANT,
    #[serde(rename = "use_support_hours")]
    USE_SUPPORT_HOURS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentUrgencyTypeTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentUrgencyTypeTypeEnum::CONSTANT => write!(f, "{}", "constant"),
            IncidentUrgencyTypeTypeEnum::USE_SUPPORT_HOURS => write!(f, "{}", "use_support_hours"),
            IncidentUrgencyTypeTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentUrgencyTypeTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "constant" => Ok(IncidentUrgencyTypeTypeEnum::CONSTANT),
            "use_support_hours" => Ok(IncidentUrgencyTypeTypeEnum::USE_SUPPORT_HOURS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentUrgencyTypeTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentUrgencyTypeTypeEnum::CONSTANT => "constant",
            IncidentUrgencyTypeTypeEnum::USE_SUPPORT_HOURS => "use_support_hours",
            IncidentUrgencyTypeTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentUrgencyTypeTypeEnum {
    fn default() -> Self {
        IncidentUrgencyTypeTypeEnum::CONSTANT
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentUrgencyTypeUrgencyEnum { 
    #[serde(rename = "low")]
    LOW,
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "severity_based")]
    SEVERITY_BASED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentUrgencyTypeUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentUrgencyTypeUrgencyEnum::LOW => write!(f, "{}", "low"),
            IncidentUrgencyTypeUrgencyEnum::HIGH => write!(f, "{}", "high"),
            IncidentUrgencyTypeUrgencyEnum::SEVERITY_BASED => write!(f, "{}", "severity_based"),
            IncidentUrgencyTypeUrgencyEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentUrgencyTypeUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "low" => Ok(IncidentUrgencyTypeUrgencyEnum::LOW),
            "high" => Ok(IncidentUrgencyTypeUrgencyEnum::HIGH),
            "severity_based" => Ok(IncidentUrgencyTypeUrgencyEnum::SEVERITY_BASED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentUrgencyTypeUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentUrgencyTypeUrgencyEnum::LOW => "low",
            IncidentUrgencyTypeUrgencyEnum::HIGH => "high",
            IncidentUrgencyTypeUrgencyEnum::SEVERITY_BASED => "severity_based",
            IncidentUrgencyTypeUrgencyEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentUrgencyTypeUrgencyEnum {
    fn default() -> Self {
        IncidentUrgencyTypeUrgencyEnum::LOW
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetAnalyticsMetricsIncidentsAll {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub filters: Option<AnalyticsmetricsincidentsallFilters>,
    /// The time zone to use for the results and grouping.
    #[serde(skip_serializing_if="Option::is_none")]
    pub time_zone: Option<String>,
    /// The time unit to aggregate metrics by.  If no value is provided, the metrics will be aggregated for the entire period.
    #[serde(skip_serializing_if="Option::is_none")]
    pub aggregate_unit: Option<GetAnalyticsMetricsIncidentsAllAggregateUnitEnum>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum GetAnalyticsMetricsIncidentsAllAggregateUnitEnum { 
    #[serde(rename = "day")]
    DAY,
    #[serde(rename = "week")]
    WEEK,
    #[serde(rename = "month")]
    MONTH,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for GetAnalyticsMetricsIncidentsAllAggregateUnitEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            GetAnalyticsMetricsIncidentsAllAggregateUnitEnum::DAY => write!(f, "{}", "day"),
            GetAnalyticsMetricsIncidentsAllAggregateUnitEnum::WEEK => write!(f, "{}", "week"),
            GetAnalyticsMetricsIncidentsAllAggregateUnitEnum::MONTH => write!(f, "{}", "month"),
            GetAnalyticsMetricsIncidentsAllAggregateUnitEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for GetAnalyticsMetricsIncidentsAllAggregateUnitEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "day" => Ok(GetAnalyticsMetricsIncidentsAllAggregateUnitEnum::DAY),
            "week" => Ok(GetAnalyticsMetricsIncidentsAllAggregateUnitEnum::WEEK),
            "month" => Ok(GetAnalyticsMetricsIncidentsAllAggregateUnitEnum::MONTH),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for GetAnalyticsMetricsIncidentsAllAggregateUnitEnum {
    fn as_ref(&self) -> &str {
        match self { 
            GetAnalyticsMetricsIncidentsAllAggregateUnitEnum::DAY => "day",
            GetAnalyticsMetricsIncidentsAllAggregateUnitEnum::WEEK => "week",
            GetAnalyticsMetricsIncidentsAllAggregateUnitEnum::MONTH => "month",
            GetAnalyticsMetricsIncidentsAllAggregateUnitEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for GetAnalyticsMetricsIncidentsAllAggregateUnitEnum {
    fn default() -> Self {
        GetAnalyticsMetricsIncidentsAllAggregateUnitEnum::DAY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IncidentsAssignments {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<UserReference>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateIncidents {     
    /// An array of incidents, including the parameters to update.
    pub incidents: Vec<IncidentsIncidents>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateIncident {     
    pub incident: IncidentsIncident,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateIncident {     
    pub incident: IncidentsidIncident,
}

/// Details of the incident to be created.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IncidentsIncident {     
    #[serde(rename = "type")]
    pub _type: IncidentsIncidentTypeEnum,
    /// A succinct description of the nature, symptoms, cause, or effect of the incident.
    #[serde(skip_serializing_if="String::is_empty")]
    pub title: String,
    pub service: ServiceReference,
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority: Option<PriorityReference>,
    /// The urgency of the incident
    #[serde(skip_serializing_if="Option::is_none")]
    pub urgency: Option<IncidentsIncidentUrgencyEnum>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<IncidentBody>,
    /// A string which identifies the incident. Sending subsequent requests referencing the same service and with the same incident_key will result in those requests being rejected if an open incident matches that incident_key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident_key: Option<String>,
    /// Assign the incident to these assignees. Cannot be specified if an escalation policy is given.
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignments: Option<Vec<IncidentsAssignments>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub escalation_policy: Option<EscalationPolicyReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conference_bridge: Option<ConferenceBridge>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsIncidentTypeEnum { 
    #[serde(rename = "incident")]
    INCIDENT,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsIncidentTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentsIncidentTypeEnum::INCIDENT => write!(f, "{}", "incident"),
            IncidentsIncidentTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsIncidentTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "incident" => Ok(IncidentsIncidentTypeEnum::INCIDENT),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsIncidentTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentsIncidentTypeEnum::INCIDENT => "incident",
            IncidentsIncidentTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsIncidentTypeEnum {
    fn default() -> Self {
        IncidentsIncidentTypeEnum::INCIDENT
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsIncidentUrgencyEnum { 
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsIncidentUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentsIncidentUrgencyEnum::HIGH => write!(f, "{}", "high"),
            IncidentsIncidentUrgencyEnum::LOW => write!(f, "{}", "low"),
            IncidentsIncidentUrgencyEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsIncidentUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "high" => Ok(IncidentsIncidentUrgencyEnum::HIGH),
            "low" => Ok(IncidentsIncidentUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsIncidentUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentsIncidentUrgencyEnum::HIGH => "high",
            IncidentsIncidentUrgencyEnum::LOW => "low",
            IncidentsIncidentUrgencyEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsIncidentUrgencyEnum {
    fn default() -> Self {
        IncidentsIncidentUrgencyEnum::HIGH
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IncidentsIncidents {     
    /// The id of the incident to update.
    #[serde(skip_serializing_if="String::is_empty")]
    pub id: String,
    /// The incident type.
    #[serde(rename = "type")]
    pub _type: IncidentsIncidentsTypeEnum,
    /// The new status of the incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<IncidentsIncidentsStatusEnum>,
    /// The resolution for this incident if status is set to resolved.
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolution: Option<String>,
    /// A succinct description of the nature, symptoms, cause, or effect of the incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority: Option<PriorityReference>,
    /// Escalate the incident to this level in the escalation policy.
    #[serde(skip_serializing_if="Option::is_none")]
    pub escalation_level: Option<isize>,
    /// Assign the incident to these assignees.
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignments: Option<Vec<IncidentsAssignments>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub escalation_policy: Option<EscalationPolicyReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conference_bridge: Option<ConferenceBridge>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsIncidentsTypeEnum { 
    #[serde(rename = "incident")]
    INCIDENT,
    #[serde(rename = "incident_reference")]
    INCIDENT_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsIncidentsTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentsIncidentsTypeEnum::INCIDENT => write!(f, "{}", "incident"),
            IncidentsIncidentsTypeEnum::INCIDENT_REFERENCE => write!(f, "{}", "incident_reference"),
            IncidentsIncidentsTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsIncidentsTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "incident" => Ok(IncidentsIncidentsTypeEnum::INCIDENT),
            "incident_reference" => Ok(IncidentsIncidentsTypeEnum::INCIDENT_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsIncidentsTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentsIncidentsTypeEnum::INCIDENT => "incident",
            IncidentsIncidentsTypeEnum::INCIDENT_REFERENCE => "incident_reference",
            IncidentsIncidentsTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsIncidentsTypeEnum {
    fn default() -> Self {
        IncidentsIncidentsTypeEnum::INCIDENT
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsIncidentsStatusEnum { 
    #[serde(rename = "resolved")]
    RESOLVED,
    #[serde(rename = "acknowledged")]
    ACKNOWLEDGED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsIncidentsStatusEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentsIncidentsStatusEnum::RESOLVED => write!(f, "{}", "resolved"),
            IncidentsIncidentsStatusEnum::ACKNOWLEDGED => write!(f, "{}", "acknowledged"),
            IncidentsIncidentsStatusEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsIncidentsStatusEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "resolved" => Ok(IncidentsIncidentsStatusEnum::RESOLVED),
            "acknowledged" => Ok(IncidentsIncidentsStatusEnum::ACKNOWLEDGED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsIncidentsStatusEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentsIncidentsStatusEnum::RESOLVED => "resolved",
            IncidentsIncidentsStatusEnum::ACKNOWLEDGED => "acknowledged",
            IncidentsIncidentsStatusEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsIncidentsStatusEnum {
    fn default() -> Self {
        IncidentsIncidentsStatusEnum::RESOLVED
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IncidentsRespondersReference {     
    /// The status of the responder being added to the incident
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<UserReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident: Option<IncidentReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    /// The message sent with the responder request
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requester: Option<UserReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetAnalyticsMetricsIncidentsService {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub filters: Option<AnalyticsmetricsincidentsservicesFilters>,
    /// The time zone to use for the results and grouping.
    #[serde(skip_serializing_if="Option::is_none")]
    pub time_zone: Option<String>,
    /// The time unit to aggregate metrics by (day/week/month).  Used in conjunction with the service_id.
    #[serde(skip_serializing_if="Option::is_none")]
    pub aggregate_unit: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetAnalyticsMetricsIncidentsTeam {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub filters: Option<AnalyticsmetricsincidentsteamsFilters>,
    /// The time zone to use for the results and grouping.
    #[serde(skip_serializing_if="Option::is_none")]
    pub time_zone: Option<String>,
    /// The time unit to aggregate metrics by.  If no value is provided, the metrics will be aggregated for the entire period.
    #[serde(skip_serializing_if="Option::is_none")]
    pub aggregate_unit: Option<GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum { 
    #[serde(rename = "day")]
    DAY,
    #[serde(rename = "week")]
    WEEK,
    #[serde(rename = "month")]
    MONTH,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::DAY => write!(f, "{}", "day"),
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::WEEK => write!(f, "{}", "week"),
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::MONTH => write!(f, "{}", "month"),
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "day" => Ok(GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::DAY),
            "week" => Ok(GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::WEEK),
            "month" => Ok(GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::MONTH),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum {
    fn as_ref(&self) -> &str {
        match self { 
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::DAY => "day",
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::WEEK => "week",
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::MONTH => "month",
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum {
    fn default() -> Self {
        GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::DAY
    }
}

/// The parameters of the incident to update.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IncidentsidIncident {     
    /// The incident type.
    #[serde(rename = "type")]
    pub _type: IncidentsidIncidentTypeEnum,
    /// The new status of the incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<IncidentsidIncidentStatusEnum>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority: Option<PriorityReference>,
    /// The resolution for this incident if status is set to resolved.
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolution: Option<String>,
    /// The new title of the incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// Escalate the incident to this level in the escalation policy.
    #[serde(skip_serializing_if="Option::is_none")]
    pub escalation_level: Option<isize>,
    /// Assign the incident to these assignees.
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignments: Option<Vec<IncidentsAssignments>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub escalation_policy: Option<EscalationPolicyReference>,
    /// The urgency of the incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub urgency: Option<IncidentsidIncidentUrgencyEnum>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conference_bridge: Option<ConferenceBridge>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsidIncidentTypeEnum { 
    #[serde(rename = "incident")]
    INCIDENT,
    #[serde(rename = "incident_reference")]
    INCIDENT_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsidIncidentTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentsidIncidentTypeEnum::INCIDENT => write!(f, "{}", "incident"),
            IncidentsidIncidentTypeEnum::INCIDENT_REFERENCE => write!(f, "{}", "incident_reference"),
            IncidentsidIncidentTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsidIncidentTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "incident" => Ok(IncidentsidIncidentTypeEnum::INCIDENT),
            "incident_reference" => Ok(IncidentsidIncidentTypeEnum::INCIDENT_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsidIncidentTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentsidIncidentTypeEnum::INCIDENT => "incident",
            IncidentsidIncidentTypeEnum::INCIDENT_REFERENCE => "incident_reference",
            IncidentsidIncidentTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsidIncidentTypeEnum {
    fn default() -> Self {
        IncidentsidIncidentTypeEnum::INCIDENT
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsidIncidentStatusEnum { 
    #[serde(rename = "resolved")]
    RESOLVED,
    #[serde(rename = "acknowledged")]
    ACKNOWLEDGED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsidIncidentStatusEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentsidIncidentStatusEnum::RESOLVED => write!(f, "{}", "resolved"),
            IncidentsidIncidentStatusEnum::ACKNOWLEDGED => write!(f, "{}", "acknowledged"),
            IncidentsidIncidentStatusEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsidIncidentStatusEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "resolved" => Ok(IncidentsidIncidentStatusEnum::RESOLVED),
            "acknowledged" => Ok(IncidentsidIncidentStatusEnum::ACKNOWLEDGED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsidIncidentStatusEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentsidIncidentStatusEnum::RESOLVED => "resolved",
            IncidentsidIncidentStatusEnum::ACKNOWLEDGED => "acknowledged",
            IncidentsidIncidentStatusEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsidIncidentStatusEnum {
    fn default() -> Self {
        IncidentsidIncidentStatusEnum::RESOLVED
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsidIncidentUrgencyEnum { 
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsidIncidentUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IncidentsidIncidentUrgencyEnum::HIGH => write!(f, "{}", "high"),
            IncidentsidIncidentUrgencyEnum::LOW => write!(f, "{}", "low"),
            IncidentsidIncidentUrgencyEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsidIncidentUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "high" => Ok(IncidentsidIncidentUrgencyEnum::HIGH),
            "low" => Ok(IncidentsidIncidentUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsidIncidentUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IncidentsidIncidentUrgencyEnum::HIGH => "high",
            IncidentsidIncidentUrgencyEnum::LOW => "low",
            IncidentsidIncidentUrgencyEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsidIncidentUrgencyEnum {
    fn default() -> Self {
        IncidentsidIncidentUrgencyEnum::HIGH
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Integration {     
    /// The label of the tag.
    #[serde(default="Integration::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: IntegrationTypeEnum,
    /// The name of this integration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub service: Option<ServiceReference>,
    /// The date/time when this integration was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor: Option<VendorReference>,
}

impl Default for Integration {
    fn default() -> Self {
        Self {
            label: String::from("Integration"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            name: Default::default(),
            service: Default::default(),
            created_at: Default::default(),
            vendor: Default::default(),
        }
    }
}

impl Integration {
    fn label_default() -> String {
        String::from("Integration")
    }
    fn _type_default() -> String {
        String::from("integration")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IntegrationTypeEnum { 
    #[serde(rename = "aws_cloudwatch_inbound_integration")]
    AWS_CLOUDWATCH_INBOUND_INTEGRATION,
    #[serde(rename = "cloudkick_inbound_integration")]
    CLOUDKICK_INBOUND_INTEGRATION,
    #[serde(rename = "event_transformer_api_inbound_integration")]
    EVENT_TRANSFORMER_API_INBOUND_INTEGRATION,
    #[serde(rename = "generic_email_inbound_integration")]
    GENERIC_EMAIL_INBOUND_INTEGRATION,
    #[serde(rename = "generic_events_api_inbound_integration")]
    GENERIC_EVENTS_API_INBOUND_INTEGRATION,
    #[serde(rename = "keynote_inbound_integration")]
    KEYNOTE_INBOUND_INTEGRATION,
    #[serde(rename = "nagios_inbound_integration")]
    NAGIOS_INBOUND_INTEGRATION,
    #[serde(rename = "pingdom_inbound_integration")]
    PINGDOM_INBOUND_INTEGRATION,
    #[serde(rename = "sql_monitor_inbound_integration")]
    SQL_MONITOR_INBOUND_INTEGRATION,
    #[serde(rename = "events_api_v2_inbound_integration")]
    EVENTS_API_V2_INBOUND_INTEGRATION,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IntegrationTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IntegrationTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION => write!(f, "{}", "aws_cloudwatch_inbound_integration"),
            IntegrationTypeEnum::CLOUDKICK_INBOUND_INTEGRATION => write!(f, "{}", "cloudkick_inbound_integration"),
            IntegrationTypeEnum::EVENT_TRANSFORMER_API_INBOUND_INTEGRATION => write!(f, "{}", "event_transformer_api_inbound_integration"),
            IntegrationTypeEnum::GENERIC_EMAIL_INBOUND_INTEGRATION => write!(f, "{}", "generic_email_inbound_integration"),
            IntegrationTypeEnum::GENERIC_EVENTS_API_INBOUND_INTEGRATION => write!(f, "{}", "generic_events_api_inbound_integration"),
            IntegrationTypeEnum::KEYNOTE_INBOUND_INTEGRATION => write!(f, "{}", "keynote_inbound_integration"),
            IntegrationTypeEnum::NAGIOS_INBOUND_INTEGRATION => write!(f, "{}", "nagios_inbound_integration"),
            IntegrationTypeEnum::PINGDOM_INBOUND_INTEGRATION => write!(f, "{}", "pingdom_inbound_integration"),
            IntegrationTypeEnum::SQL_MONITOR_INBOUND_INTEGRATION => write!(f, "{}", "sql_monitor_inbound_integration"),
            IntegrationTypeEnum::EVENTS_API_V2_INBOUND_INTEGRATION => write!(f, "{}", "events_api_v2_inbound_integration"),
            IntegrationTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IntegrationTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "aws_cloudwatch_inbound_integration" => Ok(IntegrationTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION),
            "cloudkick_inbound_integration" => Ok(IntegrationTypeEnum::CLOUDKICK_INBOUND_INTEGRATION),
            "event_transformer_api_inbound_integration" => Ok(IntegrationTypeEnum::EVENT_TRANSFORMER_API_INBOUND_INTEGRATION),
            "generic_email_inbound_integration" => Ok(IntegrationTypeEnum::GENERIC_EMAIL_INBOUND_INTEGRATION),
            "generic_events_api_inbound_integration" => Ok(IntegrationTypeEnum::GENERIC_EVENTS_API_INBOUND_INTEGRATION),
            "keynote_inbound_integration" => Ok(IntegrationTypeEnum::KEYNOTE_INBOUND_INTEGRATION),
            "nagios_inbound_integration" => Ok(IntegrationTypeEnum::NAGIOS_INBOUND_INTEGRATION),
            "pingdom_inbound_integration" => Ok(IntegrationTypeEnum::PINGDOM_INBOUND_INTEGRATION),
            "sql_monitor_inbound_integration" => Ok(IntegrationTypeEnum::SQL_MONITOR_INBOUND_INTEGRATION),
            "events_api_v2_inbound_integration" => Ok(IntegrationTypeEnum::EVENTS_API_V2_INBOUND_INTEGRATION),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IntegrationTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IntegrationTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION => "aws_cloudwatch_inbound_integration",
            IntegrationTypeEnum::CLOUDKICK_INBOUND_INTEGRATION => "cloudkick_inbound_integration",
            IntegrationTypeEnum::EVENT_TRANSFORMER_API_INBOUND_INTEGRATION => "event_transformer_api_inbound_integration",
            IntegrationTypeEnum::GENERIC_EMAIL_INBOUND_INTEGRATION => "generic_email_inbound_integration",
            IntegrationTypeEnum::GENERIC_EVENTS_API_INBOUND_INTEGRATION => "generic_events_api_inbound_integration",
            IntegrationTypeEnum::KEYNOTE_INBOUND_INTEGRATION => "keynote_inbound_integration",
            IntegrationTypeEnum::NAGIOS_INBOUND_INTEGRATION => "nagios_inbound_integration",
            IntegrationTypeEnum::PINGDOM_INBOUND_INTEGRATION => "pingdom_inbound_integration",
            IntegrationTypeEnum::SQL_MONITOR_INBOUND_INTEGRATION => "sql_monitor_inbound_integration",
            IntegrationTypeEnum::EVENTS_API_V2_INBOUND_INTEGRATION => "events_api_v2_inbound_integration",
            IntegrationTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IntegrationTypeEnum {
    fn default() -> Self {
        IntegrationTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct IntegrationReference {     
    /// The label of the tag.
    #[serde(default="IntegrationReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: IntegrationReferenceTypeEnum,
}

impl Default for IntegrationReference {
    fn default() -> Self {
        Self {
            label: String::from("IntegrationReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl IntegrationReference {
    fn label_default() -> String {
        String::from("IntegrationReference")
    }
    fn _type_default() -> String {
        String::from("integration_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IntegrationReferenceTypeEnum { 
    #[serde(rename = "aws_cloudwatch_inbound_integration_reference")]
    AWS_CLOUDWATCH_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "cloudkick_inbound_integration_reference")]
    CLOUDKICK_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "event_transformer_api_inbound_integration_reference")]
    EVENT_TRANSFORMER_API_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "generic_email_inbound_integration_reference")]
    GENERIC_EMAIL_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "generic_events_api_inbound_integration_reference")]
    GENERIC_EVENTS_API_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "keynote_inbound_integration_reference")]
    KEYNOTE_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "nagios_inbound_integration_reference")]
    NAGIOS_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "pingdom_inbound_integration_reference")]
    PINGDOM_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "sql_monitor_inbound_integration_reference")]
    SQL_MONITOR_INBOUND_INTEGRATION_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IntegrationReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            IntegrationReferenceTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION_REFERENCE => write!(f, "{}", "aws_cloudwatch_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::CLOUDKICK_INBOUND_INTEGRATION_REFERENCE => write!(f, "{}", "cloudkick_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::EVENT_TRANSFORMER_API_INBOUND_INTEGRATION_REFERENCE => write!(f, "{}", "event_transformer_api_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::GENERIC_EMAIL_INBOUND_INTEGRATION_REFERENCE => write!(f, "{}", "generic_email_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::GENERIC_EVENTS_API_INBOUND_INTEGRATION_REFERENCE => write!(f, "{}", "generic_events_api_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::KEYNOTE_INBOUND_INTEGRATION_REFERENCE => write!(f, "{}", "keynote_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::NAGIOS_INBOUND_INTEGRATION_REFERENCE => write!(f, "{}", "nagios_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::PINGDOM_INBOUND_INTEGRATION_REFERENCE => write!(f, "{}", "pingdom_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::SQL_MONITOR_INBOUND_INTEGRATION_REFERENCE => write!(f, "{}", "sql_monitor_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for IntegrationReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "aws_cloudwatch_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION_REFERENCE),
            "cloudkick_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::CLOUDKICK_INBOUND_INTEGRATION_REFERENCE),
            "event_transformer_api_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::EVENT_TRANSFORMER_API_INBOUND_INTEGRATION_REFERENCE),
            "generic_email_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::GENERIC_EMAIL_INBOUND_INTEGRATION_REFERENCE),
            "generic_events_api_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::GENERIC_EVENTS_API_INBOUND_INTEGRATION_REFERENCE),
            "keynote_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::KEYNOTE_INBOUND_INTEGRATION_REFERENCE),
            "nagios_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::NAGIOS_INBOUND_INTEGRATION_REFERENCE),
            "pingdom_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::PINGDOM_INBOUND_INTEGRATION_REFERENCE),
            "sql_monitor_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::SQL_MONITOR_INBOUND_INTEGRATION_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IntegrationReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            IntegrationReferenceTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION_REFERENCE => "aws_cloudwatch_inbound_integration_reference",
            IntegrationReferenceTypeEnum::CLOUDKICK_INBOUND_INTEGRATION_REFERENCE => "cloudkick_inbound_integration_reference",
            IntegrationReferenceTypeEnum::EVENT_TRANSFORMER_API_INBOUND_INTEGRATION_REFERENCE => "event_transformer_api_inbound_integration_reference",
            IntegrationReferenceTypeEnum::GENERIC_EMAIL_INBOUND_INTEGRATION_REFERENCE => "generic_email_inbound_integration_reference",
            IntegrationReferenceTypeEnum::GENERIC_EVENTS_API_INBOUND_INTEGRATION_REFERENCE => "generic_events_api_inbound_integration_reference",
            IntegrationReferenceTypeEnum::KEYNOTE_INBOUND_INTEGRATION_REFERENCE => "keynote_inbound_integration_reference",
            IntegrationReferenceTypeEnum::NAGIOS_INBOUND_INTEGRATION_REFERENCE => "nagios_inbound_integration_reference",
            IntegrationReferenceTypeEnum::PINGDOM_INBOUND_INTEGRATION_REFERENCE => "pingdom_inbound_integration_reference",
            IntegrationReferenceTypeEnum::SQL_MONITOR_INBOUND_INTEGRATION_REFERENCE => "sql_monitor_inbound_integration_reference",
            IntegrationReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IntegrationReferenceTypeEnum {
    fn default() -> Self {
        IntegrationReferenceTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateServiceIntegration {     
    pub integration: Integration,
}

/// The parameters to update.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct LogEntriesidchannelChannel {     
    /// New channel details
    #[serde(skip_serializing_if="String::is_empty")]
    pub details: String,
    /// Channel type. Cannot be changed and must match the present value.
    #[serde(rename = "type")]
    pub _type: LogEntriesidchannelChannelTypeEnum,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum LogEntriesidchannelChannelTypeEnum { 
    #[serde(rename = "web_trigger")]
    WEB_TRIGGER,
    #[serde(rename = "mobile")]
    MOBILE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for LogEntriesidchannelChannelTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            LogEntriesidchannelChannelTypeEnum::WEB_TRIGGER => write!(f, "{}", "web_trigger"),
            LogEntriesidchannelChannelTypeEnum::MOBILE => write!(f, "{}", "mobile"),
            LogEntriesidchannelChannelTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for LogEntriesidchannelChannelTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "web_trigger" => Ok(LogEntriesidchannelChannelTypeEnum::WEB_TRIGGER),
            "mobile" => Ok(LogEntriesidchannelChannelTypeEnum::MOBILE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for LogEntriesidchannelChannelTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            LogEntriesidchannelChannelTypeEnum::WEB_TRIGGER => "web_trigger",
            LogEntriesidchannelChannelTypeEnum::MOBILE => "mobile",
            LogEntriesidchannelChannelTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for LogEntriesidchannelChannelTypeEnum {
    fn default() -> Self {
        LogEntriesidchannelChannelTypeEnum::WEB_TRIGGER
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LogEntry {     
    /// The label of the tag.
    #[serde(default="LogEntry::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: LogEntryTypeEnum,
    /// Time at which the log entry was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub channel: Option<Channel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub agent: Option<AgentReference>,
    /// Optional field containing a note, if one was included with the log entry.
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<String>,
    /// Contexts to be included with the trigger such as links to graphs or images.
    #[serde(skip_serializing_if="Option::is_none")]
    pub contexts: Option<Vec<Context>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub service: Option<ServiceReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident: Option<IncidentReference>,
    /// Will consist of references unless included
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_details: Option<LogEntryEventDetails>,
}

impl Default for LogEntry {
    fn default() -> Self {
        Self {
            label: String::from("LogEntry"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            created_at: Default::default(),
            channel: Default::default(),
            agent: Default::default(),
            note: Default::default(),
            contexts: Default::default(),
            service: Default::default(),
            incident: Default::default(),
            teams: Default::default(),
            event_details: Default::default(),
        }
    }
}

impl LogEntry {
    fn label_default() -> String {
        String::from("LogEntry")
    }
    fn _type_default() -> String {
        String::from("log_entry")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum LogEntryTypeEnum { 
    #[serde(rename = "acknowledge_log_entry")]
    ACKNOWLEDGE_LOG_ENTRY,
    #[serde(rename = "annotate_log_entry")]
    ANNOTATE_LOG_ENTRY,
    #[serde(rename = "assign_log_entry")]
    ASSIGN_LOG_ENTRY,
    #[serde(rename = "escalate_log_entry")]
    ESCALATE_LOG_ENTRY,
    #[serde(rename = "exhaust_escalation_path_log_entry")]
    EXHAUST_ESCALATION_PATH_LOG_ENTRY,
    #[serde(rename = "notify_log_entry")]
    NOTIFY_LOG_ENTRY,
    #[serde(rename = "reach_trigger_limit_log_entry")]
    REACH_TRIGGER_LIMIT_LOG_ENTRY,
    #[serde(rename = "repeat_escalation_path_log_entry")]
    REPEAT_ESCALATION_PATH_LOG_ENTRY,
    #[serde(rename = "resolve_log_entry")]
    RESOLVE_LOG_ENTRY,
    #[serde(rename = "snooze_log_entry")]
    SNOOZE_LOG_ENTRY,
    #[serde(rename = "trigger_log_entry")]
    TRIGGER_LOG_ENTRY,
    #[serde(rename = "unacknowledge_log_entry")]
    UNACKNOWLEDGE_LOG_ENTRY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for LogEntryTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            LogEntryTypeEnum::ACKNOWLEDGE_LOG_ENTRY => write!(f, "{}", "acknowledge_log_entry"),
            LogEntryTypeEnum::ANNOTATE_LOG_ENTRY => write!(f, "{}", "annotate_log_entry"),
            LogEntryTypeEnum::ASSIGN_LOG_ENTRY => write!(f, "{}", "assign_log_entry"),
            LogEntryTypeEnum::ESCALATE_LOG_ENTRY => write!(f, "{}", "escalate_log_entry"),
            LogEntryTypeEnum::EXHAUST_ESCALATION_PATH_LOG_ENTRY => write!(f, "{}", "exhaust_escalation_path_log_entry"),
            LogEntryTypeEnum::NOTIFY_LOG_ENTRY => write!(f, "{}", "notify_log_entry"),
            LogEntryTypeEnum::REACH_TRIGGER_LIMIT_LOG_ENTRY => write!(f, "{}", "reach_trigger_limit_log_entry"),
            LogEntryTypeEnum::REPEAT_ESCALATION_PATH_LOG_ENTRY => write!(f, "{}", "repeat_escalation_path_log_entry"),
            LogEntryTypeEnum::RESOLVE_LOG_ENTRY => write!(f, "{}", "resolve_log_entry"),
            LogEntryTypeEnum::SNOOZE_LOG_ENTRY => write!(f, "{}", "snooze_log_entry"),
            LogEntryTypeEnum::TRIGGER_LOG_ENTRY => write!(f, "{}", "trigger_log_entry"),
            LogEntryTypeEnum::UNACKNOWLEDGE_LOG_ENTRY => write!(f, "{}", "unacknowledge_log_entry"),
            LogEntryTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for LogEntryTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "acknowledge_log_entry" => Ok(LogEntryTypeEnum::ACKNOWLEDGE_LOG_ENTRY),
            "annotate_log_entry" => Ok(LogEntryTypeEnum::ANNOTATE_LOG_ENTRY),
            "assign_log_entry" => Ok(LogEntryTypeEnum::ASSIGN_LOG_ENTRY),
            "escalate_log_entry" => Ok(LogEntryTypeEnum::ESCALATE_LOG_ENTRY),
            "exhaust_escalation_path_log_entry" => Ok(LogEntryTypeEnum::EXHAUST_ESCALATION_PATH_LOG_ENTRY),
            "notify_log_entry" => Ok(LogEntryTypeEnum::NOTIFY_LOG_ENTRY),
            "reach_trigger_limit_log_entry" => Ok(LogEntryTypeEnum::REACH_TRIGGER_LIMIT_LOG_ENTRY),
            "repeat_escalation_path_log_entry" => Ok(LogEntryTypeEnum::REPEAT_ESCALATION_PATH_LOG_ENTRY),
            "resolve_log_entry" => Ok(LogEntryTypeEnum::RESOLVE_LOG_ENTRY),
            "snooze_log_entry" => Ok(LogEntryTypeEnum::SNOOZE_LOG_ENTRY),
            "trigger_log_entry" => Ok(LogEntryTypeEnum::TRIGGER_LOG_ENTRY),
            "unacknowledge_log_entry" => Ok(LogEntryTypeEnum::UNACKNOWLEDGE_LOG_ENTRY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for LogEntryTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            LogEntryTypeEnum::ACKNOWLEDGE_LOG_ENTRY => "acknowledge_log_entry",
            LogEntryTypeEnum::ANNOTATE_LOG_ENTRY => "annotate_log_entry",
            LogEntryTypeEnum::ASSIGN_LOG_ENTRY => "assign_log_entry",
            LogEntryTypeEnum::ESCALATE_LOG_ENTRY => "escalate_log_entry",
            LogEntryTypeEnum::EXHAUST_ESCALATION_PATH_LOG_ENTRY => "exhaust_escalation_path_log_entry",
            LogEntryTypeEnum::NOTIFY_LOG_ENTRY => "notify_log_entry",
            LogEntryTypeEnum::REACH_TRIGGER_LIMIT_LOG_ENTRY => "reach_trigger_limit_log_entry",
            LogEntryTypeEnum::REPEAT_ESCALATION_PATH_LOG_ENTRY => "repeat_escalation_path_log_entry",
            LogEntryTypeEnum::RESOLVE_LOG_ENTRY => "resolve_log_entry",
            LogEntryTypeEnum::SNOOZE_LOG_ENTRY => "snooze_log_entry",
            LogEntryTypeEnum::TRIGGER_LOG_ENTRY => "trigger_log_entry",
            LogEntryTypeEnum::UNACKNOWLEDGE_LOG_ENTRY => "unacknowledge_log_entry",
            LogEntryTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for LogEntryTypeEnum {
    fn default() -> Self {
        LogEntryTypeEnum::ACKNOWLEDGE_LOG_ENTRY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct LogEntryEventDetails {     
    /// Additional details about the event.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LogEntryReference {     
    /// The label of the tag.
    #[serde(default="LogEntryReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: LogEntryReferenceTypeEnum,
}

impl Default for LogEntryReference {
    fn default() -> Self {
        Self {
            label: String::from("LogEntryReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl LogEntryReference {
    fn label_default() -> String {
        String::from("LogEntryReference")
    }
    fn _type_default() -> String {
        String::from("log_entry_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum LogEntryReferenceTypeEnum { 
    #[serde(rename = "acknowledge_log_entry_reference")]
    ACKNOWLEDGE_LOG_ENTRY_REFERENCE,
    #[serde(rename = "annotate_log_entry_reference")]
    ANNOTATE_LOG_ENTRY_REFERENCE,
    #[serde(rename = "assign_log_entry_reference")]
    ASSIGN_LOG_ENTRY_REFERENCE,
    #[serde(rename = "escalate_log_entry_reference")]
    ESCALATE_LOG_ENTRY_REFERENCE,
    #[serde(rename = "exhaust_escalation_path_log_entry_reference")]
    EXHAUST_ESCALATION_PATH_LOG_ENTRY_REFERENCE,
    #[serde(rename = "notify_log_entry_reference")]
    NOTIFY_LOG_ENTRY_REFERENCE,
    #[serde(rename = "reach_trigger_limit_log_entry_reference")]
    REACH_TRIGGER_LIMIT_LOG_ENTRY_REFERENCE,
    #[serde(rename = "repeat_escalation_path_log_entry_reference")]
    REPEAT_ESCALATION_PATH_LOG_ENTRY_REFERENCE,
    #[serde(rename = "resolve_log_entry_reference")]
    RESOLVE_LOG_ENTRY_REFERENCE,
    #[serde(rename = "snooze_log_entry_reference")]
    SNOOZE_LOG_ENTRY_REFERENCE,
    #[serde(rename = "trigger_log_entry_reference")]
    TRIGGER_LOG_ENTRY_REFERENCE,
    #[serde(rename = "unacknowledge_log_entry_reference")]
    UNACKNOWLEDGE_LOG_ENTRY_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for LogEntryReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            LogEntryReferenceTypeEnum::ACKNOWLEDGE_LOG_ENTRY_REFERENCE => write!(f, "{}", "acknowledge_log_entry_reference"),
            LogEntryReferenceTypeEnum::ANNOTATE_LOG_ENTRY_REFERENCE => write!(f, "{}", "annotate_log_entry_reference"),
            LogEntryReferenceTypeEnum::ASSIGN_LOG_ENTRY_REFERENCE => write!(f, "{}", "assign_log_entry_reference"),
            LogEntryReferenceTypeEnum::ESCALATE_LOG_ENTRY_REFERENCE => write!(f, "{}", "escalate_log_entry_reference"),
            LogEntryReferenceTypeEnum::EXHAUST_ESCALATION_PATH_LOG_ENTRY_REFERENCE => write!(f, "{}", "exhaust_escalation_path_log_entry_reference"),
            LogEntryReferenceTypeEnum::NOTIFY_LOG_ENTRY_REFERENCE => write!(f, "{}", "notify_log_entry_reference"),
            LogEntryReferenceTypeEnum::REACH_TRIGGER_LIMIT_LOG_ENTRY_REFERENCE => write!(f, "{}", "reach_trigger_limit_log_entry_reference"),
            LogEntryReferenceTypeEnum::REPEAT_ESCALATION_PATH_LOG_ENTRY_REFERENCE => write!(f, "{}", "repeat_escalation_path_log_entry_reference"),
            LogEntryReferenceTypeEnum::RESOLVE_LOG_ENTRY_REFERENCE => write!(f, "{}", "resolve_log_entry_reference"),
            LogEntryReferenceTypeEnum::SNOOZE_LOG_ENTRY_REFERENCE => write!(f, "{}", "snooze_log_entry_reference"),
            LogEntryReferenceTypeEnum::TRIGGER_LOG_ENTRY_REFERENCE => write!(f, "{}", "trigger_log_entry_reference"),
            LogEntryReferenceTypeEnum::UNACKNOWLEDGE_LOG_ENTRY_REFERENCE => write!(f, "{}", "unacknowledge_log_entry_reference"),
            LogEntryReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for LogEntryReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "acknowledge_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::ACKNOWLEDGE_LOG_ENTRY_REFERENCE),
            "annotate_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::ANNOTATE_LOG_ENTRY_REFERENCE),
            "assign_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::ASSIGN_LOG_ENTRY_REFERENCE),
            "escalate_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::ESCALATE_LOG_ENTRY_REFERENCE),
            "exhaust_escalation_path_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::EXHAUST_ESCALATION_PATH_LOG_ENTRY_REFERENCE),
            "notify_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::NOTIFY_LOG_ENTRY_REFERENCE),
            "reach_trigger_limit_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::REACH_TRIGGER_LIMIT_LOG_ENTRY_REFERENCE),
            "repeat_escalation_path_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::REPEAT_ESCALATION_PATH_LOG_ENTRY_REFERENCE),
            "resolve_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::RESOLVE_LOG_ENTRY_REFERENCE),
            "snooze_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::SNOOZE_LOG_ENTRY_REFERENCE),
            "trigger_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::TRIGGER_LOG_ENTRY_REFERENCE),
            "unacknowledge_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::UNACKNOWLEDGE_LOG_ENTRY_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for LogEntryReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            LogEntryReferenceTypeEnum::ACKNOWLEDGE_LOG_ENTRY_REFERENCE => "acknowledge_log_entry_reference",
            LogEntryReferenceTypeEnum::ANNOTATE_LOG_ENTRY_REFERENCE => "annotate_log_entry_reference",
            LogEntryReferenceTypeEnum::ASSIGN_LOG_ENTRY_REFERENCE => "assign_log_entry_reference",
            LogEntryReferenceTypeEnum::ESCALATE_LOG_ENTRY_REFERENCE => "escalate_log_entry_reference",
            LogEntryReferenceTypeEnum::EXHAUST_ESCALATION_PATH_LOG_ENTRY_REFERENCE => "exhaust_escalation_path_log_entry_reference",
            LogEntryReferenceTypeEnum::NOTIFY_LOG_ENTRY_REFERENCE => "notify_log_entry_reference",
            LogEntryReferenceTypeEnum::REACH_TRIGGER_LIMIT_LOG_ENTRY_REFERENCE => "reach_trigger_limit_log_entry_reference",
            LogEntryReferenceTypeEnum::REPEAT_ESCALATION_PATH_LOG_ENTRY_REFERENCE => "repeat_escalation_path_log_entry_reference",
            LogEntryReferenceTypeEnum::RESOLVE_LOG_ENTRY_REFERENCE => "resolve_log_entry_reference",
            LogEntryReferenceTypeEnum::SNOOZE_LOG_ENTRY_REFERENCE => "snooze_log_entry_reference",
            LogEntryReferenceTypeEnum::TRIGGER_LOG_ENTRY_REFERENCE => "trigger_log_entry_reference",
            LogEntryReferenceTypeEnum::UNACKNOWLEDGE_LOG_ENTRY_REFERENCE => "unacknowledge_log_entry_reference",
            LogEntryReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for LogEntryReferenceTypeEnum {
    fn default() -> Self {
        LogEntryReferenceTypeEnum::ACKNOWLEDGE_LOG_ENTRY_REFERENCE
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MaintenanceWindow {     
    /// The label of the tag.
    #[serde(default="MaintenanceWindow::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: MaintenanceWindowTypeEnum,
    /// The order in which the maintenance window was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sequence_number: Option<isize>,
    /// This maintenance window's start time. This is when the services will stop creating incidents. If this date is in the past, it will be updated to be the current time.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<chrono::DateTime<chrono::Utc>>,
    /// This maintenance window's end time. This is when the services will start creating incidents again. This date must be in the future and after the `start_time`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<chrono::DateTime<chrono::Utc>>,
    /// A description for this maintenance window.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_by: Option<UserReference>,
    pub services: Vec<ServiceReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
}

impl Default for MaintenanceWindow {
    fn default() -> Self {
        Self {
            label: String::from("MaintenanceWindow"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            sequence_number: Default::default(),
            start_time: Default::default(),
            end_time: Default::default(),
            description: Default::default(),
            created_by: Default::default(),
            services: Default::default(),
            teams: Default::default(),
        }
    }
}

impl MaintenanceWindow {
    fn label_default() -> String {
        String::from("MaintenanceWindow")
    }
    fn _type_default() -> String {
        String::from("maintenance_window")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum MaintenanceWindowTypeEnum { 
    #[serde(rename = "maintenance_window")]
    MAINTENANCE_WINDOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for MaintenanceWindowTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            MaintenanceWindowTypeEnum::MAINTENANCE_WINDOW => write!(f, "{}", "maintenance_window"),
            MaintenanceWindowTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for MaintenanceWindowTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "maintenance_window" => Ok(MaintenanceWindowTypeEnum::MAINTENANCE_WINDOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for MaintenanceWindowTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            MaintenanceWindowTypeEnum::MAINTENANCE_WINDOW => "maintenance_window",
            MaintenanceWindowTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for MaintenanceWindowTypeEnum {
    fn default() -> Self {
        MaintenanceWindowTypeEnum::MAINTENANCE_WINDOW
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MaintenanceWindowReference {     
    /// The label of the tag.
    #[serde(default="MaintenanceWindowReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: MaintenanceWindowReferenceTypeEnum,
}

impl Default for MaintenanceWindowReference {
    fn default() -> Self {
        Self {
            label: String::from("MaintenanceWindowReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl MaintenanceWindowReference {
    fn label_default() -> String {
        String::from("MaintenanceWindowReference")
    }
    fn _type_default() -> String {
        String::from("maintenance_window_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum MaintenanceWindowReferenceTypeEnum { 
    #[serde(rename = "maintenance_window_reference")]
    MAINTENANCE_WINDOW_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for MaintenanceWindowReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            MaintenanceWindowReferenceTypeEnum::MAINTENANCE_WINDOW_REFERENCE => write!(f, "{}", "maintenance_window_reference"),
            MaintenanceWindowReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for MaintenanceWindowReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "maintenance_window_reference" => Ok(MaintenanceWindowReferenceTypeEnum::MAINTENANCE_WINDOW_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for MaintenanceWindowReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            MaintenanceWindowReferenceTypeEnum::MAINTENANCE_WINDOW_REFERENCE => "maintenance_window_reference",
            MaintenanceWindowReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for MaintenanceWindowReferenceTypeEnum {
    fn default() -> Self {
        MaintenanceWindowReferenceTypeEnum::MAINTENANCE_WINDOW_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateMaintenanceWindow {     
    pub maintenance_window: MaintenanceWindow,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateMaintenanceWindow {     
    pub maintenance_window: MaintenanceWindow,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ModelOverride {     
    /// The label of the tag.
    #[serde(default="ModelOverride::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default="ModelOverride::_type_default")]
    pub _type: String,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The start date and time for the override.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start: Option<chrono::DateTime<chrono::Utc>>,
    /// The end date and time for the override.
    #[serde(skip_serializing_if="Option::is_none")]
    pub end: Option<chrono::DateTime<chrono::Utc>>,
    pub user: UserReference,
}

impl Default for ModelOverride {
    fn default() -> Self {
        Self {
            label: String::from("Override"),
            html_url: Default::default(),
            _self: Default::default(),
            _type: String::from("override"),
            summary: Default::default(),
            id: Default::default(),
            start: Default::default(),
            end: Default::default(),
            user: Default::default(),
        }
    }
}

impl ModelOverride {
    fn label_default() -> String {
        String::from("Override")
    }
    fn _type_default() -> String {
        String::from("override")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Notification {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The type of notification.
    #[serde(rename = "type")]
    pub _type: NotificationTypeEnum,
    /// The time at which the notification was sent
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The address where the notification was sent. This will be null for notification type `push_notification`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub address: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<UserReference>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationTypeEnum { 
    #[serde(rename = "sms_notification")]
    SMS_NOTIFICATION,
    #[serde(rename = "email_notification")]
    EMAIL_NOTIFICATION,
    #[serde(rename = "phone_notification")]
    PHONE_NOTIFICATION,
    #[serde(rename = "push_notification")]
    PUSH_NOTIFICATION,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            NotificationTypeEnum::SMS_NOTIFICATION => write!(f, "{}", "sms_notification"),
            NotificationTypeEnum::EMAIL_NOTIFICATION => write!(f, "{}", "email_notification"),
            NotificationTypeEnum::PHONE_NOTIFICATION => write!(f, "{}", "phone_notification"),
            NotificationTypeEnum::PUSH_NOTIFICATION => write!(f, "{}", "push_notification"),
            NotificationTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "sms_notification" => Ok(NotificationTypeEnum::SMS_NOTIFICATION),
            "email_notification" => Ok(NotificationTypeEnum::EMAIL_NOTIFICATION),
            "phone_notification" => Ok(NotificationTypeEnum::PHONE_NOTIFICATION),
            "push_notification" => Ok(NotificationTypeEnum::PUSH_NOTIFICATION),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            NotificationTypeEnum::SMS_NOTIFICATION => "sms_notification",
            NotificationTypeEnum::EMAIL_NOTIFICATION => "email_notification",
            NotificationTypeEnum::PHONE_NOTIFICATION => "phone_notification",
            NotificationTypeEnum::PUSH_NOTIFICATION => "push_notification",
            NotificationTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationTypeEnum {
    fn default() -> Self {
        NotificationTypeEnum::SMS_NOTIFICATION
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct NotificationRule {     
    /// The label of the tag.
    #[serde(default="NotificationRule::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: NotificationRuleTypeEnum,
    /// The delay before firing the rule, in minutes.
    pub start_delay_in_minutes: usize,
    pub contact_method: ContactMethodReference,
    /// Which incident urgency this rule is used for. Account must have the `urgencies` ability to have a low urgency notification rule.
    pub urgency: NotificationRuleUrgencyEnum,
}

impl Default for NotificationRule {
    fn default() -> Self {
        Self {
            label: String::from("NotificationRule"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            start_delay_in_minutes: Default::default(),
            contact_method: Default::default(),
            urgency: Default::default(),
        }
    }
}

impl NotificationRule {
    fn label_default() -> String {
        String::from("NotificationRule")
    }
    fn _type_default() -> String {
        String::from("notification_rule")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationRuleTypeEnum { 
    #[serde(rename = "assignment_notification_rule")]
    ASSIGNMENT_NOTIFICATION_RULE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationRuleTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            NotificationRuleTypeEnum::ASSIGNMENT_NOTIFICATION_RULE => write!(f, "{}", "assignment_notification_rule"),
            NotificationRuleTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationRuleTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "assignment_notification_rule" => Ok(NotificationRuleTypeEnum::ASSIGNMENT_NOTIFICATION_RULE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationRuleTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            NotificationRuleTypeEnum::ASSIGNMENT_NOTIFICATION_RULE => "assignment_notification_rule",
            NotificationRuleTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationRuleTypeEnum {
    fn default() -> Self {
        NotificationRuleTypeEnum::ASSIGNMENT_NOTIFICATION_RULE
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationRuleUrgencyEnum { 
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationRuleUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            NotificationRuleUrgencyEnum::HIGH => write!(f, "{}", "high"),
            NotificationRuleUrgencyEnum::LOW => write!(f, "{}", "low"),
            NotificationRuleUrgencyEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationRuleUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "high" => Ok(NotificationRuleUrgencyEnum::HIGH),
            "low" => Ok(NotificationRuleUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationRuleUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self { 
            NotificationRuleUrgencyEnum::HIGH => "high",
            NotificationRuleUrgencyEnum::LOW => "low",
            NotificationRuleUrgencyEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationRuleUrgencyEnum {
    fn default() -> Self {
        NotificationRuleUrgencyEnum::HIGH
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct NotificationRuleReference {     
    /// The label of the tag.
    #[serde(default="NotificationRuleReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: NotificationRuleReferenceTypeEnum,
}

impl Default for NotificationRuleReference {
    fn default() -> Self {
        Self {
            label: String::from("NotificationRuleReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl NotificationRuleReference {
    fn label_default() -> String {
        String::from("NotificationRuleReference")
    }
    fn _type_default() -> String {
        String::from("notification_rule_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationRuleReferenceTypeEnum { 
    #[serde(rename = "assignment_notification_rule_reference")]
    ASSIGNMENT_NOTIFICATION_RULE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationRuleReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            NotificationRuleReferenceTypeEnum::ASSIGNMENT_NOTIFICATION_RULE_REFERENCE => write!(f, "{}", "assignment_notification_rule_reference"),
            NotificationRuleReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationRuleReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "assignment_notification_rule_reference" => Ok(NotificationRuleReferenceTypeEnum::ASSIGNMENT_NOTIFICATION_RULE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationRuleReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            NotificationRuleReferenceTypeEnum::ASSIGNMENT_NOTIFICATION_RULE_REFERENCE => "assignment_notification_rule_reference",
            NotificationRuleReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationRuleReferenceTypeEnum {
    fn default() -> Self {
        NotificationRuleReferenceTypeEnum::ASSIGNMENT_NOTIFICATION_RULE_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateUserNotificationRule {     
    pub notification_rule: NotificationRule,
}

/// A reference of a subscribable entity.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateUserNotificationSubscription {     
    /// The ID of the entity to subscribe to
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribable_id: Option<String>,
    /// The type of the entity being subscribed to
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribable_type: Option<CreateUserNotificationSubscriptionSubscribableTypeEnum>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum CreateUserNotificationSubscriptionSubscribableTypeEnum { 
    #[serde(rename = "incident")]
    INCIDENT,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for CreateUserNotificationSubscriptionSubscribableTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            CreateUserNotificationSubscriptionSubscribableTypeEnum::INCIDENT => write!(f, "{}", "incident"),
            CreateUserNotificationSubscriptionSubscribableTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for CreateUserNotificationSubscriptionSubscribableTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "incident" => Ok(CreateUserNotificationSubscriptionSubscribableTypeEnum::INCIDENT),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for CreateUserNotificationSubscriptionSubscribableTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            CreateUserNotificationSubscriptionSubscribableTypeEnum::INCIDENT => "incident",
            CreateUserNotificationSubscriptionSubscribableTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for CreateUserNotificationSubscriptionSubscribableTypeEnum {
    fn default() -> Self {
        CreateUserNotificationSubscriptionSubscribableTypeEnum::INCIDENT
    }
}

/// A reference of a subscriber entity.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateIncidentNotificationSubscriber {     
    /// The ID of the entity being subscribed
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriber_id: Option<String>,
    /// The type of the entity being subscribed
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriber_type: Option<CreateIncidentNotificationSubscriberSubscriberTypeEnum>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum CreateIncidentNotificationSubscriberSubscriberTypeEnum { 
    #[serde(rename = "user")]
    USER,
    #[serde(rename = "team")]
    TEAM,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for CreateIncidentNotificationSubscriberSubscriberTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            CreateIncidentNotificationSubscriberSubscriberTypeEnum::USER => write!(f, "{}", "user"),
            CreateIncidentNotificationSubscriberSubscriberTypeEnum::TEAM => write!(f, "{}", "team"),
            CreateIncidentNotificationSubscriberSubscriberTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for CreateIncidentNotificationSubscriberSubscriberTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "user" => Ok(CreateIncidentNotificationSubscriberSubscriberTypeEnum::USER),
            "team" => Ok(CreateIncidentNotificationSubscriberSubscriberTypeEnum::TEAM),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for CreateIncidentNotificationSubscriberSubscriberTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            CreateIncidentNotificationSubscriberSubscriberTypeEnum::USER => "user",
            CreateIncidentNotificationSubscriberSubscriberTypeEnum::TEAM => "team",
            CreateIncidentNotificationSubscriberSubscriberTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for CreateIncidentNotificationSubscriberSubscriberTypeEnum {
    fn default() -> Self {
        CreateIncidentNotificationSubscriberSubscriberTypeEnum::USER
    }
}

/// An object describing the relationship of a NotificationSubscriber and a NotificationSubscribable.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NotificationSubscription {     
    /// The ID of the entity being subscribed
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriber_id: Option<String>,
    /// The type of the entity being subscribed
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriber_type: Option<NotificationSubscriptionSubscriberTypeEnum>,
    /// The ID of the entity being subscribed to
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribable_id: Option<String>,
    /// The type of the entity being subscribed to
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribable_type: Option<NotificationSubscriptionSubscribableTypeEnum>,
    /// The ID of the account belonging to the subscriber entity
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_id: Option<String>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationSubscriptionSubscriberTypeEnum { 
    #[serde(rename = "user")]
    USER,
    #[serde(rename = "team")]
    TEAM,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationSubscriptionSubscriberTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            NotificationSubscriptionSubscriberTypeEnum::USER => write!(f, "{}", "user"),
            NotificationSubscriptionSubscriberTypeEnum::TEAM => write!(f, "{}", "team"),
            NotificationSubscriptionSubscriberTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationSubscriptionSubscriberTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "user" => Ok(NotificationSubscriptionSubscriberTypeEnum::USER),
            "team" => Ok(NotificationSubscriptionSubscriberTypeEnum::TEAM),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationSubscriptionSubscriberTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            NotificationSubscriptionSubscriberTypeEnum::USER => "user",
            NotificationSubscriptionSubscriberTypeEnum::TEAM => "team",
            NotificationSubscriptionSubscriberTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationSubscriptionSubscriberTypeEnum {
    fn default() -> Self {
        NotificationSubscriptionSubscriberTypeEnum::USER
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationSubscriptionSubscribableTypeEnum { 
    #[serde(rename = "incident")]
    INCIDENT,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationSubscriptionSubscribableTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            NotificationSubscriptionSubscribableTypeEnum::INCIDENT => write!(f, "{}", "incident"),
            NotificationSubscriptionSubscribableTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationSubscriptionSubscribableTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "incident" => Ok(NotificationSubscriptionSubscribableTypeEnum::INCIDENT),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationSubscriptionSubscribableTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            NotificationSubscriptionSubscribableTypeEnum::INCIDENT => "incident",
            NotificationSubscriptionSubscribableTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationSubscriptionSubscribableTypeEnum {
    fn default() -> Self {
        NotificationSubscriptionSubscribableTypeEnum::INCIDENT
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NotifyLogEntry {     
    #[serde(rename = "type")]
    pub _type: NotifyLogEntryTypeEnum,
    /// Time at which the log entry was created
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub channel: Option<Channel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub agent: Option<AgentReference>,
    /// Optional field containing a note, if one was included with the log entry.
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<String>,
    /// Contexts to be included with the trigger such as links to graphs or images.
    #[serde(skip_serializing_if="Option::is_none")]
    pub contexts: Option<Vec<Context>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub service: Option<ServiceReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident: Option<IncidentReference>,
    /// Will consist of references unless included
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_details: Option<LogEntryEventDetails>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<UserReference>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotifyLogEntryTypeEnum { 
    #[serde(rename = "notify_log_entry")]
    NOTIFY_LOG_ENTRY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotifyLogEntryTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            NotifyLogEntryTypeEnum::NOTIFY_LOG_ENTRY => write!(f, "{}", "notify_log_entry"),
            NotifyLogEntryTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotifyLogEntryTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "notify_log_entry" => Ok(NotifyLogEntryTypeEnum::NOTIFY_LOG_ENTRY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotifyLogEntryTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            NotifyLogEntryTypeEnum::NOTIFY_LOG_ENTRY => "notify_log_entry",
            NotifyLogEntryTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotifyLogEntryTypeEnum {
    fn default() -> Self {
        NotifyLogEntryTypeEnum::NOTIFY_LOG_ENTRY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Oncall {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub escalation_policy: Option<EscalationPolicyReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<UserReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub schedule: Option<ScheduleReference>,
    /// The escalation level for the on-call.
    #[serde(skip_serializing_if="Option::is_none")]
    pub escalation_level: Option<isize>,
    /// The start of the on-call. If `null`, the on-call is a permanent user on-call.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start: Option<chrono::DateTime<chrono::Utc>>,
    /// The end of the on-call. If `null`, the user does not go off-call.
    #[serde(skip_serializing_if="Option::is_none")]
    pub end: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContactMethodsContactMethodIdBodyContactMethod {     
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IdContactMethodsBodyContactMethod {     
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct InlineResponse20045ContactMethodsItems {     
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct InlineResponse2015ContactMethod {     
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct OutboundIntegrationReference {     
    /// The label of the tag.
    #[serde(default="OutboundIntegrationReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: OutboundIntegrationReferenceTypeEnum,
}

impl Default for OutboundIntegrationReference {
    fn default() -> Self {
        Self {
            label: String::from("OutboundIntegrationReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl OutboundIntegrationReference {
    fn label_default() -> String {
        String::from("OutboundIntegrationReference")
    }
    fn _type_default() -> String {
        String::from("outbound_integration_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum OutboundIntegrationReferenceTypeEnum { 
    #[serde(rename = "outbound_integration_reference")]
    OUTBOUND_INTEGRATION_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for OutboundIntegrationReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            OutboundIntegrationReferenceTypeEnum::OUTBOUND_INTEGRATION_REFERENCE => write!(f, "{}", "outbound_integration_reference"),
            OutboundIntegrationReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for OutboundIntegrationReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "outbound_integration_reference" => Ok(OutboundIntegrationReferenceTypeEnum::OUTBOUND_INTEGRATION_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for OutboundIntegrationReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            OutboundIntegrationReferenceTypeEnum::OUTBOUND_INTEGRATION_REFERENCE => "outbound_integration_reference",
            OutboundIntegrationReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for OutboundIntegrationReferenceTypeEnum {
    fn default() -> Self {
        OutboundIntegrationReferenceTypeEnum::OUTBOUND_INTEGRATION_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Pagination {     
    /// Echoes offset pagination property.
    #[serde(skip_serializing_if="Option::is_none")]
    pub offset: Option<isize>,
    /// Echoes limit pagination property.
    #[serde(skip_serializing_if="Option::is_none")]
    pub limit: Option<isize>,
    /// Indicates if there are additional records to return
    #[serde(skip_serializing_if="Option::is_none")]
    pub more: Option<bool>,
    /// The total number of records matching the given query.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<isize>,
}

/// The Phone Contact Method of the User, used for Voice or SMS.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PhoneContactMethod {     
    #[serde(rename = "type")]
    pub _type: PhoneContactMethodTypeEnum,
    /// The label (e.g., \"Work\", \"Mobile\", etc.).
    #[serde(default="PhoneContactMethod::label_default")]
    pub label: String,
    /// The \"address\" to deliver to: email, phone number, etc., depending on the type.
    #[serde(skip_serializing_if="String::is_empty")]
    pub address: String,
    /// The 1-to-3 digit country calling code.
    pub country_code: u16,
    /// If true, this phone is capable of receiving SMS messages.
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
    /// If true, this phone has been blacklisted by PagerDuty and no messages will be sent to it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub blacklisted: Option<bool>,
}

impl Default for PhoneContactMethod {
    fn default() -> Self {
        Self {
            _type: Default::default(),
            label: String::from("PhoneContactMethod"),
            address: Default::default(),
            country_code: Default::default(),
            enabled: Default::default(),
            blacklisted: Default::default(),
        }
    }
}

impl PhoneContactMethod {
    fn label_default() -> String {
        String::from("PhoneContactMethod")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum PhoneContactMethodTypeEnum { 
    #[serde(rename = "phone_contact_method")]
    PHONE_CONTACT_METHOD,
    #[serde(rename = "sms_contact_method")]
    SMS_CONTACT_METHOD,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for PhoneContactMethodTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            PhoneContactMethodTypeEnum::PHONE_CONTACT_METHOD => write!(f, "{}", "phone_contact_method"),
            PhoneContactMethodTypeEnum::SMS_CONTACT_METHOD => write!(f, "{}", "sms_contact_method"),
            PhoneContactMethodTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for PhoneContactMethodTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "phone_contact_method" => Ok(PhoneContactMethodTypeEnum::PHONE_CONTACT_METHOD),
            "sms_contact_method" => Ok(PhoneContactMethodTypeEnum::SMS_CONTACT_METHOD),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for PhoneContactMethodTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            PhoneContactMethodTypeEnum::PHONE_CONTACT_METHOD => "phone_contact_method",
            PhoneContactMethodTypeEnum::SMS_CONTACT_METHOD => "sms_contact_method",
            PhoneContactMethodTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for PhoneContactMethodTypeEnum {
    fn default() -> Self {
        PhoneContactMethodTypeEnum::PHONE_CONTACT_METHOD
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Priority {     
    /// The label of the tag.
    #[serde(default="Priority::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default="Priority::_type_default")]
    pub _type: String,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The user-provided short name of the priority.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The user-provided description of the priority.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
}

impl Default for Priority {
    fn default() -> Self {
        Self {
            label: String::from("Priority"),
            html_url: Default::default(),
            _self: Default::default(),
            _type: String::from("priority"),
            summary: Default::default(),
            id: Default::default(),
            name: Default::default(),
            description: Default::default(),
        }
    }
}

impl Priority {
    fn label_default() -> String {
        String::from("Priority")
    }
    fn _type_default() -> String {
        String::from("priority")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PriorityReference {     
    /// The label of the tag.
    #[serde(default="PriorityReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: PriorityReferenceTypeEnum,
}

impl Default for PriorityReference {
    fn default() -> Self {
        Self {
            label: String::from("PriorityReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl PriorityReference {
    fn label_default() -> String {
        String::from("PriorityReference")
    }
    fn _type_default() -> String {
        String::from("priority_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum PriorityReferenceTypeEnum { 
    #[serde(rename = "priority_reference")]
    PRIORITY_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for PriorityReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            PriorityReferenceTypeEnum::PRIORITY_REFERENCE => write!(f, "{}", "priority_reference"),
            PriorityReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for PriorityReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "priority_reference" => Ok(PriorityReferenceTypeEnum::PRIORITY_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for PriorityReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            PriorityReferenceTypeEnum::PRIORITY_REFERENCE => "priority_reference",
            PriorityReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for PriorityReferenceTypeEnum {
    fn default() -> Self {
        PriorityReferenceTypeEnum::PRIORITY_REFERENCE
    }
}

/// The Push Contact Method of the User.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PushContactMethod {     
    #[serde(rename = "type")]
    pub _type: PushContactMethodTypeEnum,
    /// The label (e.g., \"Work\", \"Mobile\", etc.).
    #[serde(default="PushContactMethod::label_default")]
    pub label: String,
    /// The \"address\" to deliver to: email, phone number, etc., depending on the type.
    #[serde(skip_serializing_if="String::is_empty")]
    pub address: String,
    /// The type of device.
    pub device_type: PushContactMethodDeviceTypeEnum,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sounds: Option<Vec<PushContactMethodSound>>,
    /// Time at which the contact method was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// If true, this phone has been blacklisted by PagerDuty and no messages will be sent to it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub blacklisted: Option<bool>,
}

impl Default for PushContactMethod {
    fn default() -> Self {
        Self {
            _type: Default::default(),
            label: String::from("PushContactMethod"),
            address: Default::default(),
            device_type: Default::default(),
            sounds: Default::default(),
            created_at: Default::default(),
            blacklisted: Default::default(),
        }
    }
}

impl PushContactMethod {
    fn label_default() -> String {
        String::from("PushContactMethod")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum PushContactMethodTypeEnum { 
    #[serde(rename = "push_notification_contact_method")]
    PUSH_NOTIFICATION_CONTACT_METHOD,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for PushContactMethodTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            PushContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD => write!(f, "{}", "push_notification_contact_method"),
            PushContactMethodTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for PushContactMethodTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "push_notification_contact_method" => Ok(PushContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for PushContactMethodTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            PushContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD => "push_notification_contact_method",
            PushContactMethodTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for PushContactMethodTypeEnum {
    fn default() -> Self {
        PushContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum PushContactMethodDeviceTypeEnum { 
    #[serde(rename = "android")]
    ANDROID,
    #[serde(rename = "ios")]
    IOS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for PushContactMethodDeviceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            PushContactMethodDeviceTypeEnum::ANDROID => write!(f, "{}", "android"),
            PushContactMethodDeviceTypeEnum::IOS => write!(f, "{}", "ios"),
            PushContactMethodDeviceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for PushContactMethodDeviceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "android" => Ok(PushContactMethodDeviceTypeEnum::ANDROID),
            "ios" => Ok(PushContactMethodDeviceTypeEnum::IOS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for PushContactMethodDeviceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            PushContactMethodDeviceTypeEnum::ANDROID => "android",
            PushContactMethodDeviceTypeEnum::IOS => "ios",
            PushContactMethodDeviceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for PushContactMethodDeviceTypeEnum {
    fn default() -> Self {
        PushContactMethodDeviceTypeEnum::ANDROID
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PushContactMethodSound {     
    /// The type of sound.
    #[serde(rename = "type")]
    pub _type: PushContactMethodSoundTypeEnum,
    /// The sound file name.
    #[serde(skip_serializing_if="Option::is_none")]
    pub file: Option<String>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum PushContactMethodSoundTypeEnum { 
    #[serde(rename = "alert_high_urgency")]
    HIGH_URGENCY,
    #[serde(rename = "alert_low_urgency")]
    LOW_URGENCY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for PushContactMethodSoundTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            PushContactMethodSoundTypeEnum::HIGH_URGENCY => write!(f, "{}", "alert_high_urgency"),
            PushContactMethodSoundTypeEnum::LOW_URGENCY => write!(f, "{}", "alert_low_urgency"),
            PushContactMethodSoundTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for PushContactMethodSoundTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "alert_high_urgency" => Ok(PushContactMethodSoundTypeEnum::HIGH_URGENCY),
            "alert_low_urgency" => Ok(PushContactMethodSoundTypeEnum::LOW_URGENCY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for PushContactMethodSoundTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            PushContactMethodSoundTypeEnum::HIGH_URGENCY => "alert_high_urgency",
            PushContactMethodSoundTypeEnum::LOW_URGENCY => "alert_low_urgency",
            PushContactMethodSoundTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for PushContactMethodSoundTypeEnum {
    fn default() -> Self {
        PushContactMethodSoundTypeEnum::HIGH_URGENCY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetAnalyticsIncidents {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub filters: Option<AnalyticsrawincidentsFilters>,
    /// Specifies an incident by ID, the paginated results will begin with the incident directly after this one.
    #[serde(skip_serializing_if="Option::is_none")]
    pub starting_after: Option<String>,
    /// Specifies an incident by ID, the paginated results will end with the incident directly before this one.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ending_before: Option<String>,
    /// Number of results to include in each batch. Limits between 1 to 1000 are accepted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub limit: Option<u16>,
    /// The time zone to use for the results.
    #[serde(skip_serializing_if="Option::is_none")]
    pub time_zone: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Reference {     
    /// The label of the tag.
    #[serde(default="Reference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default="Reference::_type_default")]
    pub _type: String,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
}

impl Default for Reference {
    fn default() -> Self {
        Self {
            label: String::from("Reference"),
            html_url: Default::default(),
            _self: Default::default(),
            _type: String::from("reference"),
            summary: Default::default(),
            id: Default::default(),
        }
    }
}

impl Reference {
    fn label_default() -> String {
        String::from("Reference")
    }
    fn _type_default() -> String {
        String::from("reference")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ResolveReason {     
    /// The reason the incident was resolved. The only reason currently supported is merge.
    #[serde(rename = "type")]
    pub _type: ResolveReasonTypeEnum,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident: Option<IncidentReference>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ResolveReasonTypeEnum { 
    #[serde(rename = "merge_resolve_reason")]
    MERGE_RESOLVE_REASON,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ResolveReasonTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ResolveReasonTypeEnum::MERGE_RESOLVE_REASON => write!(f, "{}", "merge_resolve_reason"),
            ResolveReasonTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ResolveReasonTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "merge_resolve_reason" => Ok(ResolveReasonTypeEnum::MERGE_RESOLVE_REASON),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ResolveReasonTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ResolveReasonTypeEnum::MERGE_RESOLVE_REASON => "merge_resolve_reason",
            ResolveReasonTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ResolveReasonTypeEnum {
    fn default() -> Self {
        ResolveReasonTypeEnum::MERGE_RESOLVE_REASON
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ResponderRequest {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident: Option<IncidentReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requester: Option<UserReference>,
    /// The time the request was made
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_at: Option<String>,
    /// The message sent with the responder request
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    /// The array of targets the responder request is being sent to
    #[serde(skip_serializing_if="Option::is_none")]
    pub responder_request_targets: Option<Vec<ResponderRequestTargetReference>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ResponderRequestTargetReference {     
    /// The type of target (either a user or an escalation policy)
    #[serde(rename = "type")]
    #[serde(default="ResponderRequestTargetReference::_type_default")]
    pub _type: String,
    /// The id of the user or escalation policy
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    /// An array of responders associated with the specified incident
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident_responders: Option<Vec<IncidentsRespondersReference>>,
}

impl Default for ResponderRequestTargetReference {
    fn default() -> Self {
        Self {
            _type: String::from("responder_request_target_reference"),
            id: Default::default(),
            summary: Default::default(),
            incident_responders: Default::default(),
        }
    }
}

impl ResponderRequestTargetReference {
    fn _type_default() -> String {
        String::from("responder_request_target_reference")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ResponsePlay {     
    /// The label of the tag.
    #[serde(default="ResponsePlay::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: ResponsePlayTypeEnum,
    /// The name of the response play.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The description of the response play.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team: Option<TeamReference>,
    /// An array containing the users and/or teams to be added as subscribers to any incident on which this response play is run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers: Option<Vec<Value>>,
    /// The content of the notification that will be sent to all incident subscribers upon the running of this response play. Note that this includes any users who may have already been subscribed to the incident prior to the running of this response play. If empty, no notifications will be sent.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_message: Option<String>,
    /// An array containing the users and/or escalation policies to be requested as responders to any incident on which this response play is run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub responders: Option<Vec<Value>>,
    /// The message body of the notification that will be sent to this response play's set of responders. If empty, a default response request notification will be sent.
    #[serde(skip_serializing_if="Option::is_none")]
    pub responders_message: Option<String>,
    /// String representing how this response play is allowed to be run. Valid options are:   - `services`: This response play cannot be manually run by any users. It will run automatically for new incidents triggered on any services that are configured with this response play.   - `teams`: This response play can be run manually on an incident only by members of its configured team. This option can only be selected when the `team` property for this response play is not empty.   - `responders`: This response play can be run manually on an incident by any responders in this account.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runnability: Option<ResponsePlayRunnabilityEnum>,
    /// The telephone number that will be set as the conference number for any incident on which this response play is run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub conference_number: Option<String>,
    /// The URL that will be set as the conference URL for any incident on which this response play is run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub conference_url: Option<String>,
}

impl Default for ResponsePlay {
    fn default() -> Self {
        Self {
            label: String::from("ResponsePlay"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            name: Default::default(),
            description: Default::default(),
            team: Default::default(),
            subscribers: Default::default(),
            subscribers_message: Default::default(),
            responders: Default::default(),
            responders_message: Default::default(),
            runnability: Default::default(),
            conference_number: Default::default(),
            conference_url: Default::default(),
        }
    }
}

impl ResponsePlay {
    fn label_default() -> String {
        String::from("ResponsePlay")
    }
    fn _type_default() -> String {
        String::from("response_play")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ResponsePlayTypeEnum { 
    #[serde(rename = "response_play")]
    RESPONSE_PLAY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ResponsePlayTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ResponsePlayTypeEnum::RESPONSE_PLAY => write!(f, "{}", "response_play"),
            ResponsePlayTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ResponsePlayTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "response_play" => Ok(ResponsePlayTypeEnum::RESPONSE_PLAY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ResponsePlayTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ResponsePlayTypeEnum::RESPONSE_PLAY => "response_play",
            ResponsePlayTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ResponsePlayTypeEnum {
    fn default() -> Self {
        ResponsePlayTypeEnum::RESPONSE_PLAY
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ResponsePlayRunnabilityEnum { 
    #[serde(rename = "services")]
    SERVICES,
    #[serde(rename = "teams")]
    TEAMS,
    #[serde(rename = "responders")]
    RESPONDERS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ResponsePlayRunnabilityEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ResponsePlayRunnabilityEnum::SERVICES => write!(f, "{}", "services"),
            ResponsePlayRunnabilityEnum::TEAMS => write!(f, "{}", "teams"),
            ResponsePlayRunnabilityEnum::RESPONDERS => write!(f, "{}", "responders"),
            ResponsePlayRunnabilityEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ResponsePlayRunnabilityEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "services" => Ok(ResponsePlayRunnabilityEnum::SERVICES),
            "teams" => Ok(ResponsePlayRunnabilityEnum::TEAMS),
            "responders" => Ok(ResponsePlayRunnabilityEnum::RESPONDERS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ResponsePlayRunnabilityEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ResponsePlayRunnabilityEnum::SERVICES => "services",
            ResponsePlayRunnabilityEnum::TEAMS => "teams",
            ResponsePlayRunnabilityEnum::RESPONDERS => "responders",
            ResponsePlayRunnabilityEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ResponsePlayRunnabilityEnum {
    fn default() -> Self {
        ResponsePlayRunnabilityEnum::SERVICES
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RunResponsePlay {     
    pub incident: IncidentReference,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateResponsePlay {     
    pub response_play: ResponsePlay,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateResponsePlay {     
    pub response_play: ResponsePlay,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Restriction {     
    /// Specify the types of `restriction`.
    #[serde(rename = "type")]
    pub _type: RestrictionTypeEnum,
    /// The duration of the restriction in seconds.
    pub duration_seconds: isize,
    /// The start time in HH:mm:ss format.
    #[serde(skip_serializing_if="String::is_empty")]
    pub start_time_of_day: String,
    /// Only required for use with a `weekly_restriction` restriction type. The first day of the weekly rotation schedule as [ISO 8601 day](https://en.wikipedia.org/wiki/ISO_week_date) (1 is Monday, etc.)
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_day_of_week: Option<u8>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RestrictionTypeEnum { 
    #[serde(rename = "daily_restriction")]
    DAILY_RESTRICTION,
    #[serde(rename = "weekly_restriction")]
    WEEKLY_RESTRICTION,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for RestrictionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            RestrictionTypeEnum::DAILY_RESTRICTION => write!(f, "{}", "daily_restriction"),
            RestrictionTypeEnum::WEEKLY_RESTRICTION => write!(f, "{}", "weekly_restriction"),
            RestrictionTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for RestrictionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "daily_restriction" => Ok(RestrictionTypeEnum::DAILY_RESTRICTION),
            "weekly_restriction" => Ok(RestrictionTypeEnum::WEEKLY_RESTRICTION),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for RestrictionTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            RestrictionTypeEnum::DAILY_RESTRICTION => "daily_restriction",
            RestrictionTypeEnum::WEEKLY_RESTRICTION => "weekly_restriction",
            RestrictionTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for RestrictionTypeEnum {
    fn default() -> Self {
        RestrictionTypeEnum::DAILY_RESTRICTION
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateRulesetEventRule {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<Value>,
    /// The id of the event rule to update.
    #[serde(skip_serializing_if="String::is_empty")]
    pub rule_id: String,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateRuleset {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub ruleset: Option<RulesetsRuleset>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateRuleset {     
    pub ruleset: Value,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsRuleset {     
    /// ID of the ruleset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    #[serde(rename = "type")]
    pub _type: RulesetsRulesetTypeEnum,
    /// Name of the ruleset.
    #[serde(skip_serializing_if="String::is_empty")]
    pub name: String,
    /// Routing keys routed to this ruleset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub routing_keys: Option<Vec<String>>,
    /// The date the ruleset was created at.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<RulesetsRulesetCreator>,
    /// The date the ruleset was last updated.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updater: Option<RulesetsRulesetUpdater>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team: Option<RulesetsRulesetTeam>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RulesetsRulesetTypeEnum { 
    #[serde(rename = "global")]
    GLOBAL,
    #[serde(rename = "default_global")]
    DEFAULT_GLOBAL,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for RulesetsRulesetTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            RulesetsRulesetTypeEnum::GLOBAL => write!(f, "{}", "global"),
            RulesetsRulesetTypeEnum::DEFAULT_GLOBAL => write!(f, "{}", "default_global"),
            RulesetsRulesetTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for RulesetsRulesetTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "global" => Ok(RulesetsRulesetTypeEnum::GLOBAL),
            "default_global" => Ok(RulesetsRulesetTypeEnum::DEFAULT_GLOBAL),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for RulesetsRulesetTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            RulesetsRulesetTypeEnum::GLOBAL => "global",
            RulesetsRulesetTypeEnum::DEFAULT_GLOBAL => "default_global",
            RulesetsRulesetTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for RulesetsRulesetTypeEnum {
    fn default() -> Self {
        RulesetsRulesetTypeEnum::GLOBAL
    }
}

/// Reference to the user that has created the ruleset.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsRulesetCreator {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// A string that determines the schema of the object
    #[serde(rename = "type")]
    #[serde(default="RulesetsRulesetCreator::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
}

impl Default for RulesetsRulesetCreator {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("rulesets_ruleset_creator"),
            _self: Default::default(),
        }
    }
}

impl RulesetsRulesetCreator {
    fn _type_default() -> String {
        String::from("rulesets_ruleset_creator")
    }
}

/// Reference to the team that owns the ruleset. If none is specified, only admins have access.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsRulesetTeam {     
    #[serde(skip_serializing_if="String::is_empty")]
    pub id: String,
    /// A string that determines the schema of the object
    #[serde(rename = "type")]
    #[serde(default="RulesetsRulesetTeam::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
}

impl Default for RulesetsRulesetTeam {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("rulesets_ruleset_team"),
            _self: Default::default(),
        }
    }
}

impl RulesetsRulesetTeam {
    fn _type_default() -> String {
        String::from("rulesets_ruleset_team")
    }
}

/// Reference to the user that has updated the ruleset last.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsRulesetUpdater {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// A string that determines the schema of the object
    #[serde(rename = "type")]
    #[serde(default="RulesetsRulesetUpdater::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
}

impl Default for RulesetsRulesetUpdater {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("rulesets_ruleset_updater"),
            _self: Default::default(),
        }
    }
}

impl RulesetsRulesetUpdater {
    fn _type_default() -> String {
        String::from("rulesets_ruleset_updater")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRule {     
    /// ID of the event rule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// Position/index of the rule within the ruleset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub position: Option<isize>,
    /// Indicates whether the rule is disabled and would therefore not be evaluated.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    /// Indicates whether the rule is the last rule of the ruleset that serves as a catch-all. It has limited functionality compared to other rules.
    #[serde(skip_serializing_if="Option::is_none")]
    pub catch_all: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conditions: Option<RulesetsidrulesRuleConditions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub time_frame: Option<RulesetsidrulesRuleTimeFrame>,
    pub actions: RulesetsidrulesRuleActions,
}

/// When an event matches this rule, the actions that will be taken to change the resulting alert and incident.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleActions {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotate: Option<RulesetsidrulesRuleActionsAnnotate>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_action: Option<RulesetsidrulesRuleActionsEventAction>,
    /// Use regular expressions to extract values from event fields to set fields on the resulting alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub extractions: Option<Vec<RulesetsidrulesRuleActionsExtractions>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority: Option<RulesetsidrulesRuleActionsPriority>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub route: Option<RulesetsidrulesRuleActionsRoute>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<RulesetsidrulesRuleActionsSeverity>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub suppress: Option<RulesetsidrulesRuleActionsSuppress>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub suspend: Option<RulesetsidrulesRuleActionsSuspend>,
}

/// Set a note on the resulting incident.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleActionsAnnotate {     
    /// The content of the note.
    #[serde(skip_serializing_if="String::is_empty")]
    pub value: String,
}

/// Set whether the resulting alert status is trigger or resolve.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleActionsEventAction {     
    pub value: RulesetsidrulesRuleActionsEventActionValueEnum,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RulesetsidrulesRuleActionsEventActionValueEnum { 
    #[serde(rename = "trigger")]
    TRIGGER,
    #[serde(rename = "resolve")]
    RESOLVE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for RulesetsidrulesRuleActionsEventActionValueEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            RulesetsidrulesRuleActionsEventActionValueEnum::TRIGGER => write!(f, "{}", "trigger"),
            RulesetsidrulesRuleActionsEventActionValueEnum::RESOLVE => write!(f, "{}", "resolve"),
            RulesetsidrulesRuleActionsEventActionValueEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for RulesetsidrulesRuleActionsEventActionValueEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "trigger" => Ok(RulesetsidrulesRuleActionsEventActionValueEnum::TRIGGER),
            "resolve" => Ok(RulesetsidrulesRuleActionsEventActionValueEnum::RESOLVE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for RulesetsidrulesRuleActionsEventActionValueEnum {
    fn as_ref(&self) -> &str {
        match self { 
            RulesetsidrulesRuleActionsEventActionValueEnum::TRIGGER => "trigger",
            RulesetsidrulesRuleActionsEventActionValueEnum::RESOLVE => "resolve",
            RulesetsidrulesRuleActionsEventActionValueEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for RulesetsidrulesRuleActionsEventActionValueEnum {
    fn default() -> Self {
        RulesetsidrulesRuleActionsEventActionValueEnum::TRIGGER
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleActionsExtractions {     
    /// The alert field that will be set with the value from the regex.
    pub target: RulesetsidrulesRuleActionsExtractionsTargetEnum,
    /// The path to the event field where the regex will be applied to extract a value.
    #[serde(skip_serializing_if="String::is_empty")]
    pub source: String,
    /// A RE2 regular expression.  If it contains one or more capture groups, their values will be extracted and appended together.  If it contains no capture groups, the whole match is used.
    #[serde(skip_serializing_if="String::is_empty")]
    pub regex: String,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RulesetsidrulesRuleActionsExtractionsTargetEnum { 
    #[serde(rename = "dedup_key")]
    DEDUP_KEY,
    #[serde(rename = "description")]
    DESCRIPTION,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for RulesetsidrulesRuleActionsExtractionsTargetEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            RulesetsidrulesRuleActionsExtractionsTargetEnum::DEDUP_KEY => write!(f, "{}", "dedup_key"),
            RulesetsidrulesRuleActionsExtractionsTargetEnum::DESCRIPTION => write!(f, "{}", "description"),
            RulesetsidrulesRuleActionsExtractionsTargetEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for RulesetsidrulesRuleActionsExtractionsTargetEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "dedup_key" => Ok(RulesetsidrulesRuleActionsExtractionsTargetEnum::DEDUP_KEY),
            "description" => Ok(RulesetsidrulesRuleActionsExtractionsTargetEnum::DESCRIPTION),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for RulesetsidrulesRuleActionsExtractionsTargetEnum {
    fn as_ref(&self) -> &str {
        match self { 
            RulesetsidrulesRuleActionsExtractionsTargetEnum::DEDUP_KEY => "dedup_key",
            RulesetsidrulesRuleActionsExtractionsTargetEnum::DESCRIPTION => "description",
            RulesetsidrulesRuleActionsExtractionsTargetEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for RulesetsidrulesRuleActionsExtractionsTargetEnum {
    fn default() -> Self {
        RulesetsidrulesRuleActionsExtractionsTargetEnum::DEDUP_KEY
    }
}

/// Set the priority ID for the resulting incident. You can find the priority you want by calling the priorities endpoint.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleActionsPriority {     
    /// The priority ID.
    #[serde(skip_serializing_if="String::is_empty")]
    pub value: String,
}

/// Set the service ID of the target service for the resulting alert. You can find the service you want to route to by calling the services endpoint.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleActionsRoute {     
    /// The target service's ID.
    #[serde(skip_serializing_if="String::is_empty")]
    pub value: String,
}

/// Set the severity of the resulting alert.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleActionsSeverity {     
    pub value: RulesetsidrulesRuleActionsSeverityValueEnum,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RulesetsidrulesRuleActionsSeverityValueEnum { 
    #[serde(rename = "info")]
    INFO,
    #[serde(rename = "warning")]
    WARNING,
    #[serde(rename = "error")]
    ERROR,
    #[serde(rename = "critical")]
    CRITICAL,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for RulesetsidrulesRuleActionsSeverityValueEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            RulesetsidrulesRuleActionsSeverityValueEnum::INFO => write!(f, "{}", "info"),
            RulesetsidrulesRuleActionsSeverityValueEnum::WARNING => write!(f, "{}", "warning"),
            RulesetsidrulesRuleActionsSeverityValueEnum::ERROR => write!(f, "{}", "error"),
            RulesetsidrulesRuleActionsSeverityValueEnum::CRITICAL => write!(f, "{}", "critical"),
            RulesetsidrulesRuleActionsSeverityValueEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for RulesetsidrulesRuleActionsSeverityValueEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "info" => Ok(RulesetsidrulesRuleActionsSeverityValueEnum::INFO),
            "warning" => Ok(RulesetsidrulesRuleActionsSeverityValueEnum::WARNING),
            "error" => Ok(RulesetsidrulesRuleActionsSeverityValueEnum::ERROR),
            "critical" => Ok(RulesetsidrulesRuleActionsSeverityValueEnum::CRITICAL),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for RulesetsidrulesRuleActionsSeverityValueEnum {
    fn as_ref(&self) -> &str {
        match self { 
            RulesetsidrulesRuleActionsSeverityValueEnum::INFO => "info",
            RulesetsidrulesRuleActionsSeverityValueEnum::WARNING => "warning",
            RulesetsidrulesRuleActionsSeverityValueEnum::ERROR => "error",
            RulesetsidrulesRuleActionsSeverityValueEnum::CRITICAL => "critical",
            RulesetsidrulesRuleActionsSeverityValueEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for RulesetsidrulesRuleActionsSeverityValueEnum {
    fn default() -> Self {
        RulesetsidrulesRuleActionsSeverityValueEnum::INFO
    }
}

/// Set whether the resulting alert is suppressed.  Can optionally be used with a threshold where resulting alerts will be suppressed until the threshold is met in window of time.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleActionsSuppress {     
    pub value: bool,
    /// The number of occurences needed during the window of time to trigger the theshold.
    #[serde(skip_serializing_if="Option::is_none")]
    pub threshold_value: Option<isize>,
    /// The time unit for the window of time.
    #[serde(skip_serializing_if="Option::is_none")]
    pub threshold_time_unit: Option<RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum>,
    /// The amount of time units for the window of time.
    #[serde(skip_serializing_if="Option::is_none")]
    pub threshold_time_amount: Option<isize>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum { 
    #[serde(rename = "seconds")]
    SECONDS,
    #[serde(rename = "minutes")]
    MINUTES,
    #[serde(rename = "hours")]
    HOURS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum::SECONDS => write!(f, "{}", "seconds"),
            RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum::MINUTES => write!(f, "{}", "minutes"),
            RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum::HOURS => write!(f, "{}", "hours"),
            RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "seconds" => Ok(RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum::SECONDS),
            "minutes" => Ok(RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum::MINUTES),
            "hours" => Ok(RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum::HOURS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum {
    fn as_ref(&self) -> &str {
        match self { 
            RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum::SECONDS => "seconds",
            RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum::MINUTES => "minutes",
            RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum::HOURS => "hours",
            RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum {
    fn default() -> Self {
        RulesetsidrulesRuleActionsSuppressThresholdTimeUnitEnum::SECONDS
    }
}

/// [Early Access] Set the length of time to suspend the resulting alert before triggering.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleActionsSuspend {     
    /// The amount of time to suspend the alert in seconds.
    pub value: isize,
}

/// Conditions evaluated to check if an event matches this event rule. Is always empty for the catch all rule, though.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleConditions {     
    /// Operator to combine sub-conditions.
    pub operator: RulesetsidrulesRuleConditionsOperatorEnum,
    /// Array of sub-conditions.
    pub subconditions: Vec<RulesetsidrulesRuleConditionsSubconditions>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RulesetsidrulesRuleConditionsOperatorEnum { 
    #[serde(rename = "and")]
    AND,
    #[serde(rename = "or")]
    OR,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for RulesetsidrulesRuleConditionsOperatorEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            RulesetsidrulesRuleConditionsOperatorEnum::AND => write!(f, "{}", "and"),
            RulesetsidrulesRuleConditionsOperatorEnum::OR => write!(f, "{}", "or"),
            RulesetsidrulesRuleConditionsOperatorEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for RulesetsidrulesRuleConditionsOperatorEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "and" => Ok(RulesetsidrulesRuleConditionsOperatorEnum::AND),
            "or" => Ok(RulesetsidrulesRuleConditionsOperatorEnum::OR),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for RulesetsidrulesRuleConditionsOperatorEnum {
    fn as_ref(&self) -> &str {
        match self { 
            RulesetsidrulesRuleConditionsOperatorEnum::AND => "and",
            RulesetsidrulesRuleConditionsOperatorEnum::OR => "or",
            RulesetsidrulesRuleConditionsOperatorEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for RulesetsidrulesRuleConditionsOperatorEnum {
    fn default() -> Self {
        RulesetsidrulesRuleConditionsOperatorEnum::AND
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleConditionsParameters {     
    /// Path to a field in an event, in dot-notation.
    #[serde(skip_serializing_if="String::is_empty")]
    pub path: String,
    /// Value to apply to the operator.
    #[serde(skip_serializing_if="String::is_empty")]
    pub value: String,
    /// Options to configure the operator.
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<HashMap<String, Value>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleConditionsSubconditions {     
    /// The type of operator to apply.
    pub operator: RulesetsidrulesRuleConditionsSubconditionsOperatorEnum,
    pub parameters: RulesetsidrulesRuleConditionsParameters,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RulesetsidrulesRuleConditionsSubconditionsOperatorEnum { 
    #[serde(rename = "exists")]
    EXISTS,
    #[serde(rename = "nexists")]
    NEXISTS,
    #[serde(rename = "equals")]
    EQUALS,
    #[serde(rename = "nequals")]
    NEQUALS,
    #[serde(rename = "contains")]
    CONTAINS,
    #[serde(rename = "ncontains")]
    NCONTAINS,
    #[serde(rename = "matches")]
    MATCHES,
    #[serde(rename = "nmatches")]
    NMATCHES,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for RulesetsidrulesRuleConditionsSubconditionsOperatorEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::EXISTS => write!(f, "{}", "exists"),
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::NEXISTS => write!(f, "{}", "nexists"),
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::EQUALS => write!(f, "{}", "equals"),
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::NEQUALS => write!(f, "{}", "nequals"),
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::CONTAINS => write!(f, "{}", "contains"),
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::NCONTAINS => write!(f, "{}", "ncontains"),
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::MATCHES => write!(f, "{}", "matches"),
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::NMATCHES => write!(f, "{}", "nmatches"),
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for RulesetsidrulesRuleConditionsSubconditionsOperatorEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "exists" => Ok(RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::EXISTS),
            "nexists" => Ok(RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::NEXISTS),
            "equals" => Ok(RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::EQUALS),
            "nequals" => Ok(RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::NEQUALS),
            "contains" => Ok(RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::CONTAINS),
            "ncontains" => Ok(RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::NCONTAINS),
            "matches" => Ok(RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::MATCHES),
            "nmatches" => Ok(RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::NMATCHES),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for RulesetsidrulesRuleConditionsSubconditionsOperatorEnum {
    fn as_ref(&self) -> &str {
        match self { 
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::EXISTS => "exists",
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::NEXISTS => "nexists",
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::EQUALS => "equals",
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::NEQUALS => "nequals",
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::CONTAINS => "contains",
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::NCONTAINS => "ncontains",
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::MATCHES => "matches",
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::NMATCHES => "nmatches",
            RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for RulesetsidrulesRuleConditionsSubconditionsOperatorEnum {
    fn default() -> Self {
        RulesetsidrulesRuleConditionsSubconditionsOperatorEnum::EXISTS
    }
}

/// Time-based conditions for limiting when the rule is active.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleTimeFrame {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_between: Option<RulesetsidrulesRuleTimeFrameActiveBetween>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub scheduled_weekly: Option<RulesetsidrulesRuleTimeFrameScheduledWeekly>,
}

/// A fixed window of time during which the rule is active.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleTimeFrameActiveBetween {     
    /// The start time in milliseconds.
    pub start_time: isize,
    /// End time in milliseconds.
    pub end_time: isize,
}

/// A reccuring window of time based on the day of the week, during which the rule is active.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesetsidrulesRuleTimeFrameScheduledWeekly {     
    /// The amount of milliseconds into the day at which the window starts.
    pub start_time: isize,
    /// The duration of the window in milliseconds.
    pub duration: isize,
    /// The timezone.
    #[serde(skip_serializing_if="String::is_empty")]
    pub timezone: String,
    /// An array of day values. Ex [1, 3, 5] is Monday, Wednesday, Friday.
    pub weekdays: Vec<i32>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Schedule {     
    /// The label of the tag.
    #[serde(default="Schedule::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: ScheduleTypeEnum,
    /// A list of schedule layers.
    pub schedule_layers: Vec<ScheduleLayer>,
    /// The time zone of the schedule.
    #[serde(skip_serializing_if="String::is_empty")]
    pub time_zone: String,
    /// The name of the schedule
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The description of the schedule
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub final_schedule: Option<SubSchedule>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub overrides_subschedule: Option<SubSchedule>,
    /// An array of all of the escalation policies that uses this schedule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub escalation_policies: Option<Vec<EscalationPolicyReference>>,
    /// An array of all of the users on the schedule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<UserReference>>,
    /// An array of all of the teams on the schedule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
}

impl Default for Schedule {
    fn default() -> Self {
        Self {
            label: String::from("Schedule"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            schedule_layers: Default::default(),
            time_zone: Default::default(),
            name: Default::default(),
            description: Default::default(),
            final_schedule: Default::default(),
            overrides_subschedule: Default::default(),
            escalation_policies: Default::default(),
            users: Default::default(),
            teams: Default::default(),
        }
    }
}

impl Schedule {
    fn label_default() -> String {
        String::from("Schedule")
    }
    fn _type_default() -> String {
        String::from("schedule")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ScheduleTypeEnum { 
    #[serde(rename = "schedule")]
    SCHEDULE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ScheduleTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ScheduleTypeEnum::SCHEDULE => write!(f, "{}", "schedule"),
            ScheduleTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ScheduleTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "schedule" => Ok(ScheduleTypeEnum::SCHEDULE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ScheduleTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ScheduleTypeEnum::SCHEDULE => "schedule",
            ScheduleTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ScheduleTypeEnum {
    fn default() -> Self {
        ScheduleTypeEnum::SCHEDULE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ScheduleLayer {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The start time of this layer.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start: Option<chrono::DateTime<chrono::Utc>>,
    /// The end time of this layer. If `null`, the layer does not end.
    #[serde(skip_serializing_if="Option::is_none")]
    pub end: Option<chrono::DateTime<chrono::Utc>>,
    /// The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
    pub users: Vec<ScheduleLayerUser>,
    /// An array of restrictions for the layer. A restriction is a limit on which period of the day or week the schedule layer can accept assignments.
    #[serde(skip_serializing_if="Option::is_none")]
    pub restrictions: Option<Vec<Restriction>>,
    /// The effective start time of the layer. This can be before the start time of the schedule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub rotation_virtual_start: Option<chrono::DateTime<chrono::Utc>>,
    /// The duration of each on-call shift in seconds.
    pub rotation_turn_length_seconds: isize,
    /// The name of the schedule layer.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// This is a list of entries on the computed layer for the current time range. Since or until must be set in order for this field to be populated.
    #[serde(skip_serializing_if="Option::is_none")]
    pub rendered_schedule_entries: Option<Vec<ScheduleLayerEntry>>,
    /// The percentage of the time range covered by this layer. Returns null unless since or until are set.
    #[serde(skip_serializing_if="Option::is_none")]
    pub rendered_coverage_percentage: Option<f64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ScheduleLayerEntry {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<UserReference>,
    /// The start time of this entry.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start: Option<chrono::DateTime<chrono::Utc>>,
    /// The end time of this entry. If null, the entry does not end.
    #[serde(skip_serializing_if="Option::is_none")]
    pub end: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ScheduleLayerUser {     
    pub user: UserReference,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ScheduleReference {     
    /// The label of the tag.
    #[serde(default="ScheduleReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: ScheduleReferenceTypeEnum,
}

impl Default for ScheduleReference {
    fn default() -> Self {
        Self {
            label: String::from("ScheduleReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl ScheduleReference {
    fn label_default() -> String {
        String::from("ScheduleReference")
    }
    fn _type_default() -> String {
        String::from("schedule_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ScheduleReferenceTypeEnum { 
    #[serde(rename = "schedule_reference")]
    SCHEDULE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ScheduleReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ScheduleReferenceTypeEnum::SCHEDULE_REFERENCE => write!(f, "{}", "schedule_reference"),
            ScheduleReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ScheduleReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "schedule_reference" => Ok(ScheduleReferenceTypeEnum::SCHEDULE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ScheduleReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ScheduleReferenceTypeEnum::SCHEDULE_REFERENCE => "schedule_reference",
            ScheduleReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ScheduleReferenceTypeEnum {
    fn default() -> Self {
        ScheduleReferenceTypeEnum::SCHEDULE_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ScheduledAction {     
    /// The type of schedule action. Must be set to urgency_change.
    #[serde(rename = "type")]
    pub _type: ScheduledActionTypeEnum,
    pub at: ScheduledActionAt,
    /// Urgency level. Must be set to high.
    pub to_urgency: ScheduledActionToUrgencyEnum,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ScheduledActionTypeEnum { 
    #[serde(rename = "urgency_change")]
    URGENCY_CHANGE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ScheduledActionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ScheduledActionTypeEnum::URGENCY_CHANGE => write!(f, "{}", "urgency_change"),
            ScheduledActionTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ScheduledActionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "urgency_change" => Ok(ScheduledActionTypeEnum::URGENCY_CHANGE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ScheduledActionTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ScheduledActionTypeEnum::URGENCY_CHANGE => "urgency_change",
            ScheduledActionTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ScheduledActionTypeEnum {
    fn default() -> Self {
        ScheduledActionTypeEnum::URGENCY_CHANGE
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ScheduledActionToUrgencyEnum { 
    #[serde(rename = "high")]
    HIGH,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ScheduledActionToUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ScheduledActionToUrgencyEnum::HIGH => write!(f, "{}", "high"),
            ScheduledActionToUrgencyEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ScheduledActionToUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "high" => Ok(ScheduledActionToUrgencyEnum::HIGH),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ScheduledActionToUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ScheduledActionToUrgencyEnum::HIGH => "high",
            ScheduledActionToUrgencyEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ScheduledActionToUrgencyEnum {
    fn default() -> Self {
        ScheduledActionToUrgencyEnum::HIGH
    }
}

/// Represents when scheduled action will occur.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ScheduledActionAt {     
    /// Must be set to named_time.
    #[serde(rename = "type")]
    pub _type: ScheduledActionAtTypeEnum,
    /// Designates either the start or the end of support hours.
    pub name: ScheduledActionAtNameEnum,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ScheduledActionAtTypeEnum { 
    #[serde(rename = "named_time")]
    NAMED_TIME,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ScheduledActionAtTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ScheduledActionAtTypeEnum::NAMED_TIME => write!(f, "{}", "named_time"),
            ScheduledActionAtTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ScheduledActionAtTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "named_time" => Ok(ScheduledActionAtTypeEnum::NAMED_TIME),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ScheduledActionAtTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ScheduledActionAtTypeEnum::NAMED_TIME => "named_time",
            ScheduledActionAtTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ScheduledActionAtTypeEnum {
    fn default() -> Self {
        ScheduledActionAtTypeEnum::NAMED_TIME
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ScheduledActionAtNameEnum { 
    #[serde(rename = "support_hours_start")]
    START,
    #[serde(rename = "support_hours_end")]
    END,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ScheduledActionAtNameEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ScheduledActionAtNameEnum::START => write!(f, "{}", "support_hours_start"),
            ScheduledActionAtNameEnum::END => write!(f, "{}", "support_hours_end"),
            ScheduledActionAtNameEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ScheduledActionAtNameEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "support_hours_start" => Ok(ScheduledActionAtNameEnum::START),
            "support_hours_end" => Ok(ScheduledActionAtNameEnum::END),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ScheduledActionAtNameEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ScheduledActionAtNameEnum::START => "support_hours_start",
            ScheduledActionAtNameEnum::END => "support_hours_end",
            ScheduledActionAtNameEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ScheduledActionAtNameEnum {
    fn default() -> Self {
        ScheduledActionAtNameEnum::START
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateSchedule {     
    pub schedule: Schedule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateSchedule {     
    pub schedule: Schedule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateSchedulePreview {     
    pub schedule: Schedule,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Service {     
    /// The label of the tag.
    #[serde(default="Service::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: ServiceTypeEnum,
    /// The name of the service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The user-provided description of the service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Time in seconds that an incident is automatically resolved if left open for that long. Value is `null` if the feature is disabled. Value must not be negative. Setting this field to `0`, `null` (or unset in POST request) will disable the feature.
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_resolve_timeout: Option<isize>,
    /// Time in seconds that an incident changes to the Triggered State after being Acknowledged. Value is `null` if the feature is disabled. Value must not be negative. Setting this field to `0`, `null` (or unset in POST request) will disable the feature.
    #[serde(skip_serializing_if="Option::is_none")]
    pub acknowledgement_timeout: Option<isize>,
    /// The date/time when this service was created
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The current state of the Service. Valid statuses are:   - `active`: The service is enabled and has no open incidents. - `warning`: The service is enabled and has one or more acknowledged incidents. - `critical`: The service is enabled and has one or more triggered incidents. - `maintenance`: The service is under maintenance, no new incidents will be triggered during maintenance mode. - `disabled`: The service is disabled and will not have any new triggered incidents. 
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<ServiceStatusEnum>,
    /// The date/time when the most recent incident was created for this service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_incident_timestamp: Option<chrono::DateTime<chrono::Utc>>,
    pub escalation_policy: EscalationPolicyReference,
    /// The set of teams associated with this service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    /// An array containing Integration objects that belong to this service. If `integrations` is passed as an argument, these are full objects - otherwise, these are references.
    #[serde(skip_serializing_if="Option::is_none")]
    pub integrations: Option<Vec<IntegrationReference>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident_urgency_rule: Option<IncidentUrgencyRule>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub support_hours: Option<SupportHours>,
    /// An array containing scheduled actions for the service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub scheduled_actions: Option<Vec<ScheduledAction>>,
    /// The array of Add-ons associated with this service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub addons: Option<Vec<AddonReference>>,
    /// Whether a service creates only incidents, or both alerts and incidents. A service must create alerts in order to enable incident merging. * \"create_incidents\" - The service will create one incident and zero alerts for each incoming event. * \"create_alerts_and_incidents\" - The service will create one incident and one associated alert for each incoming event. 
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert_creation: Option<ServiceAlertCreationEnum>,
    /// Defines how alerts on this service will be automatically grouped into incidents. Note that the alert grouping features are available only on certain plans. There are three available options: * null - No alert grouping on the service. Each alert will create a separate incident; * \"time\" - All alerts within a specified duration will be grouped into the same incident. This duration is set in the `alert_grouping_timeout` setting (described below). Available on Standard, Enterprise, and Event Intelligence plans; * \"intelligent\" - Alerts will be intelligently grouped based on a machine learning model that looks at the alert summary, timing, and the history of grouped alerts. Available on Enterprise and Event Intelligence plans 
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert_grouping: Option<ServiceAlertGroupingEnum>,
    /// The duration in minutes within which to automatically group incoming alerts. This setting applies only when `alert_grouping` is set to `\"time\"`. To continue grouping alerts until the incident is resolved, set this value to `0`. 
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert_grouping_timeout: Option<isize>,
}

impl Default for Service {
    fn default() -> Self {
        Self {
            label: String::from("Service"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            name: Default::default(),
            description: Default::default(),
            auto_resolve_timeout: Default::default(),
            acknowledgement_timeout: Default::default(),
            created_at: Default::default(),
            status: Default::default(),
            last_incident_timestamp: Default::default(),
            escalation_policy: Default::default(),
            teams: Default::default(),
            integrations: Default::default(),
            incident_urgency_rule: Default::default(),
            support_hours: Default::default(),
            scheduled_actions: Default::default(),
            addons: Default::default(),
            alert_creation: Default::default(),
            alert_grouping: Default::default(),
            alert_grouping_timeout: Default::default(),
        }
    }
}

impl Service {
    fn label_default() -> String {
        String::from("Service")
    }
    fn _type_default() -> String {
        String::from("service")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ServiceTypeEnum { 
    #[serde(rename = "service")]
    SERVICE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ServiceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ServiceTypeEnum::SERVICE => write!(f, "{}", "service"),
            ServiceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ServiceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "service" => Ok(ServiceTypeEnum::SERVICE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ServiceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ServiceTypeEnum::SERVICE => "service",
            ServiceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ServiceTypeEnum {
    fn default() -> Self {
        ServiceTypeEnum::SERVICE
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ServiceStatusEnum { 
    #[serde(rename = "active")]
    ACTIVE,
    #[serde(rename = "warning")]
    WARNING,
    #[serde(rename = "critical")]
    CRITICAL,
    #[serde(rename = "maintenance")]
    MAINTENANCE,
    #[serde(rename = "disabled")]
    DISABLED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ServiceStatusEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ServiceStatusEnum::ACTIVE => write!(f, "{}", "active"),
            ServiceStatusEnum::WARNING => write!(f, "{}", "warning"),
            ServiceStatusEnum::CRITICAL => write!(f, "{}", "critical"),
            ServiceStatusEnum::MAINTENANCE => write!(f, "{}", "maintenance"),
            ServiceStatusEnum::DISABLED => write!(f, "{}", "disabled"),
            ServiceStatusEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ServiceStatusEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "active" => Ok(ServiceStatusEnum::ACTIVE),
            "warning" => Ok(ServiceStatusEnum::WARNING),
            "critical" => Ok(ServiceStatusEnum::CRITICAL),
            "maintenance" => Ok(ServiceStatusEnum::MAINTENANCE),
            "disabled" => Ok(ServiceStatusEnum::DISABLED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ServiceStatusEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ServiceStatusEnum::ACTIVE => "active",
            ServiceStatusEnum::WARNING => "warning",
            ServiceStatusEnum::CRITICAL => "critical",
            ServiceStatusEnum::MAINTENANCE => "maintenance",
            ServiceStatusEnum::DISABLED => "disabled",
            ServiceStatusEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ServiceStatusEnum {
    fn default() -> Self {
        ServiceStatusEnum::ACTIVE
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ServiceAlertCreationEnum { 
    #[serde(rename = "create_incidents")]
    INCIDENTS,
    #[serde(rename = "create_alerts_and_incidents")]
    ALERTS_AND_INCIDENTS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ServiceAlertCreationEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ServiceAlertCreationEnum::INCIDENTS => write!(f, "{}", "create_incidents"),
            ServiceAlertCreationEnum::ALERTS_AND_INCIDENTS => write!(f, "{}", "create_alerts_and_incidents"),
            ServiceAlertCreationEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ServiceAlertCreationEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "create_incidents" => Ok(ServiceAlertCreationEnum::INCIDENTS),
            "create_alerts_and_incidents" => Ok(ServiceAlertCreationEnum::ALERTS_AND_INCIDENTS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ServiceAlertCreationEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ServiceAlertCreationEnum::INCIDENTS => "create_incidents",
            ServiceAlertCreationEnum::ALERTS_AND_INCIDENTS => "create_alerts_and_incidents",
            ServiceAlertCreationEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ServiceAlertCreationEnum {
    fn default() -> Self {
        ServiceAlertCreationEnum::INCIDENTS
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ServiceAlertGroupingEnum { 
    #[serde(rename = "time")]
    TIME,
    #[serde(rename = "intelligent")]
    INTELLIGENT,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ServiceAlertGroupingEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ServiceAlertGroupingEnum::TIME => write!(f, "{}", "time"),
            ServiceAlertGroupingEnum::INTELLIGENT => write!(f, "{}", "intelligent"),
            ServiceAlertGroupingEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ServiceAlertGroupingEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "time" => Ok(ServiceAlertGroupingEnum::TIME),
            "intelligent" => Ok(ServiceAlertGroupingEnum::INTELLIGENT),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ServiceAlertGroupingEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ServiceAlertGroupingEnum::TIME => "time",
            ServiceAlertGroupingEnum::INTELLIGENT => "intelligent",
            ServiceAlertGroupingEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ServiceAlertGroupingEnum {
    fn default() -> Self {
        ServiceAlertGroupingEnum::TIME
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateServiceDependency {     
    /// List of all service dependencies to be created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub relationships: Option<Vec<ServiceDependenciesassociateRelationships>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteServiceDependency {     
    /// List of all service dependencies to be deleted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub relationships: Option<Vec<ServiceDependenciesassociateRelationships>>,
}

/// The reference to the service that is dependent on the supporting service.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceDependenciesassociateDependentService {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    #[serde(default="ServiceDependenciesassociateDependentService::_type_default")]
    pub _type: String,
}

impl Default for ServiceDependenciesassociateDependentService {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("service_dependenciesassociate_dependent_service"),
        }
    }
}

impl ServiceDependenciesassociateDependentService {
    fn _type_default() -> String {
        String::from("service_dependenciesassociate_dependent_service")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceDependenciesassociateRelationships {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub supporting_service: Option<ServiceDependenciesassociateSupportingService>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependent_service: Option<ServiceDependenciesassociateDependentService>,
}

/// The reference to the service that supports the dependent service.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceDependenciesassociateSupportingService {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    #[serde(default="ServiceDependenciesassociateSupportingService::_type_default")]
    pub _type: String,
}

impl Default for ServiceDependenciesassociateSupportingService {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("service_dependenciesassociate_supporting_service"),
        }
    }
}

impl ServiceDependenciesassociateSupportingService {
    fn _type_default() -> String {
        String::from("service_dependenciesassociate_supporting_service")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ServiceReference {     
    /// The label of the tag.
    #[serde(default="ServiceReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: ServiceReferenceTypeEnum,
}

impl Default for ServiceReference {
    fn default() -> Self {
        Self {
            label: String::from("ServiceReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl ServiceReference {
    fn label_default() -> String {
        String::from("ServiceReference")
    }
    fn _type_default() -> String {
        String::from("service_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ServiceReferenceTypeEnum { 
    #[serde(rename = "service_reference")]
    SERVICE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ServiceReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            ServiceReferenceTypeEnum::SERVICE_REFERENCE => write!(f, "{}", "service_reference"),
            ServiceReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for ServiceReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "service_reference" => Ok(ServiceReferenceTypeEnum::SERVICE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ServiceReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            ServiceReferenceTypeEnum::SERVICE_REFERENCE => "service_reference",
            ServiceReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ServiceReferenceTypeEnum {
    fn default() -> Self {
        ServiceReferenceTypeEnum::SERVICE_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateService {     
    pub service: Service,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateService {     
    pub service: Service,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SnoozeLogEntry {     
    #[serde(rename = "type")]
    pub _type: SnoozeLogEntryTypeEnum,
    /// Time at which the log entry was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub channel: Option<Channel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub agent: Option<AgentReference>,
    /// Optional field containing a note, if one was included with the log entry.
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<String>,
    /// Contexts to be included with the trigger such as links to graphs or images.
    #[serde(skip_serializing_if="Option::is_none")]
    pub contexts: Option<Vec<Context>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub service: Option<ServiceReference>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident: Option<IncidentReference>,
    /// Will consist of references unless included
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_details: Option<LogEntryEventDetails>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_actions: Option<Vec<IncidentAction>>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum SnoozeLogEntryTypeEnum { 
    #[serde(rename = "snooze_log_entry")]
    SNOOZE_LOG_ENTRY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for SnoozeLogEntryTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            SnoozeLogEntryTypeEnum::SNOOZE_LOG_ENTRY => write!(f, "{}", "snooze_log_entry"),
            SnoozeLogEntryTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for SnoozeLogEntryTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "snooze_log_entry" => Ok(SnoozeLogEntryTypeEnum::SNOOZE_LOG_ENTRY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for SnoozeLogEntryTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            SnoozeLogEntryTypeEnum::SNOOZE_LOG_ENTRY => "snooze_log_entry",
            SnoozeLogEntryTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for SnoozeLogEntryTypeEnum {
    fn default() -> Self {
        SnoozeLogEntryTypeEnum::SNOOZE_LOG_ENTRY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct StatusUpdate {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The message of the status update.
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    /// The date/time when this status update was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<UserReference>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateUserStatusUpdateNotificationRule {     
    pub status_update_notification_rule: Value,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SubSchedule {     
    /// The name of the subschedule
    pub name: SubScheduleNameEnum,
    /// This is a list of entries on the computed layer for the current time range. Since or until must be set in order for this field to be populated.
    #[serde(skip_serializing_if="Option::is_none")]
    pub rendered_schedule_entries: Option<Vec<ScheduleLayerEntry>>,
    /// The percentage of the time range covered by this layer. Returns null unless since or until are set.
    #[serde(skip_serializing_if="Option::is_none")]
    pub rendered_coverage_percentage: Option<f64>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum SubScheduleNameEnum { 
    #[serde(rename = "Final Schedule")]
    FINAL_SCHEDULE,
    #[serde(rename = "Overrides")]
    OVERRIDES,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for SubScheduleNameEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            SubScheduleNameEnum::FINAL_SCHEDULE => write!(f, "{}", "Final Schedule"),
            SubScheduleNameEnum::OVERRIDES => write!(f, "{}", "Overrides"),
            SubScheduleNameEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for SubScheduleNameEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "Final Schedule" => Ok(SubScheduleNameEnum::FINAL_SCHEDULE),
            "Overrides" => Ok(SubScheduleNameEnum::OVERRIDES),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for SubScheduleNameEnum {
    fn as_ref(&self) -> &str {
        match self { 
            SubScheduleNameEnum::FINAL_SCHEDULE => "Final Schedule",
            SubScheduleNameEnum::OVERRIDES => "Overrides",
            SubScheduleNameEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for SubScheduleNameEnum {
    fn default() -> Self {
        SubScheduleNameEnum::FINAL_SCHEDULE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SupportHours {     
    /// The type of support hours
    #[serde(rename = "type")]
    pub _type: SupportHoursTypeEnum,
    /// The time zone for the support hours
    #[serde(skip_serializing_if="Option::is_none")]
    pub time_zone: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub days_of_week: Option<Vec<i32>>,
    /// The support hours' starting time of day (date portion is ignored)
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<String>,
    /// The support hours' ending time of day (date portion is ignored)
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<String>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum SupportHoursTypeEnum { 
    #[serde(rename = "fixed_time_per_day")]
    FIXED_TIME_PER_DAY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for SupportHoursTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            SupportHoursTypeEnum::FIXED_TIME_PER_DAY => write!(f, "{}", "fixed_time_per_day"),
            SupportHoursTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for SupportHoursTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "fixed_time_per_day" => Ok(SupportHoursTypeEnum::FIXED_TIME_PER_DAY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for SupportHoursTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            SupportHoursTypeEnum::FIXED_TIME_PER_DAY => "fixed_time_per_day",
            SupportHoursTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for SupportHoursTypeEnum {
    fn default() -> Self {
        SupportHoursTypeEnum::FIXED_TIME_PER_DAY
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Tag {     
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: TagTypeEnum,
    /// The label of the tag.
    #[serde(default="Tag::label_default")]
    pub label: String,
}

impl Default for Tag {
    fn default() -> Self {
        Self {
            _type: Default::default(),
            label: String::from("Tag"),
        }
    }
}

impl Tag {
    fn label_default() -> String {
        String::from("Tag")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum TagTypeEnum { 
    #[serde(rename = "tag")]
    TAG,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for TagTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            TagTypeEnum::TAG => write!(f, "{}", "tag"),
            TagTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for TagTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "tag" => Ok(TagTypeEnum::TAG),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for TagTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            TagTypeEnum::TAG => "tag",
            TagTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for TagTypeEnum {
    fn default() -> Self {
        TagTypeEnum::TAG
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TagReference {     
    /// The label of the tag.
    #[serde(default="TagReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: TagReferenceTypeEnum,
}

impl Default for TagReference {
    fn default() -> Self {
        Self {
            label: String::from("TagReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl TagReference {
    fn label_default() -> String {
        String::from("TagReference")
    }
    fn _type_default() -> String {
        String::from("tag_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum TagReferenceTypeEnum { 
    #[serde(rename = "tag_reference")]
    TAG_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for TagReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            TagReferenceTypeEnum::TAG_REFERENCE => write!(f, "{}", "tag_reference"),
            TagReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for TagReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "tag_reference" => Ok(TagReferenceTypeEnum::TAG_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for TagReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            TagReferenceTypeEnum::TAG_REFERENCE => "tag_reference",
            TagReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for TagReferenceTypeEnum {
    fn default() -> Self {
        TagReferenceTypeEnum::TAG_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateTags {     
    pub tag: Tag,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TagsToAdd {     
    #[serde(rename = "type")]
    pub _type: TagsToAddTypeEnum,
    /// The label of the tag. Should be used when type is \"tag\".
    #[serde(default="TagsToAdd::label_default")]
    pub label: String,
    /// The id of the tag. Should be used when type is \"tag_reference\".
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
}

impl Default for TagsToAdd {
    fn default() -> Self {
        Self {
            _type: Default::default(),
            label: String::from("Tags to add"),
            id: Default::default(),
        }
    }
}

impl TagsToAdd {
    fn label_default() -> String {
        String::from("Tags to add")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum TagsToAddTypeEnum { 
    #[serde(rename = "tag")]
    TAG,
    #[serde(rename = "tag_reference")]
    TAG_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for TagsToAddTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            TagsToAddTypeEnum::TAG => write!(f, "{}", "tag"),
            TagsToAddTypeEnum::TAG_REFERENCE => write!(f, "{}", "tag_reference"),
            TagsToAddTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for TagsToAddTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "tag" => Ok(TagsToAddTypeEnum::TAG),
            "tag_reference" => Ok(TagsToAddTypeEnum::TAG_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for TagsToAddTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            TagsToAddTypeEnum::TAG => "tag",
            TagsToAddTypeEnum::TAG_REFERENCE => "tag_reference",
            TagsToAddTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for TagsToAddTypeEnum {
    fn default() -> Self {
        TagsToAddTypeEnum::TAG
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TagsToRemove_ {     
    #[serde(rename = "type")]
    pub _type: TagsToRemove_TypeEnum,
    /// The id of the tag
    #[serde(skip_serializing_if="String::is_empty")]
    pub id: String,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum TagsToRemove_TypeEnum { 
    #[serde(rename = "tag_reference")]
    TAG_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for TagsToRemove_TypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            TagsToRemove_TypeEnum::TAG_REFERENCE => write!(f, "{}", "tag_reference"),
            TagsToRemove_TypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for TagsToRemove_TypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "tag_reference" => Ok(TagsToRemove_TypeEnum::TAG_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for TagsToRemove_TypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            TagsToRemove_TypeEnum::TAG_REFERENCE => "tag_reference",
            TagsToRemove_TypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for TagsToRemove_TypeEnum {
    fn default() -> Self {
        TagsToRemove_TypeEnum::TAG_REFERENCE
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Team {     
    /// The label of the tag.
    #[serde(default="Team::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: TeamTypeEnum,
    /// The name of the team.
    #[serde(skip_serializing_if="String::is_empty")]
    pub name: String,
    /// The description of the team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent: Option<TeamReference>,
}

impl Default for Team {
    fn default() -> Self {
        Self {
            label: String::from("Team"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            name: Default::default(),
            description: Default::default(),
            parent: Default::default(),
        }
    }
}

impl Team {
    fn label_default() -> String {
        String::from("Team")
    }
    fn _type_default() -> String {
        String::from("team")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum TeamTypeEnum { 
    #[serde(rename = "team")]
    TEAM,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for TeamTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            TeamTypeEnum::TEAM => write!(f, "{}", "team"),
            TeamTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for TeamTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "team" => Ok(TeamTypeEnum::TEAM),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for TeamTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            TeamTypeEnum::TEAM => "team",
            TeamTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for TeamTypeEnum {
    fn default() -> Self {
        TeamTypeEnum::TEAM
    }
}

/// Reference to the team that owns the business service.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Team1 {     
    /// The team ID
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
}

/// Reference to the team that owns the business service.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Team2 {     
    #[serde(skip_serializing_if="String::is_empty")]
    pub id: String,
    /// A string that determines the schema of the object.
    #[serde(rename = "type")]
    #[serde(default="Team2::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible.
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
}

impl Default for Team2 {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("team_2"),
            _self: Default::default(),
        }
    }
}

impl Team2 {
    fn _type_default() -> String {
        String::from("team_2")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TeamReference {     
    /// The label of the tag.
    #[serde(default="TeamReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: TeamReferenceTypeEnum,
}

impl Default for TeamReference {
    fn default() -> Self {
        Self {
            label: String::from("TeamReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl TeamReference {
    fn label_default() -> String {
        String::from("TeamReference")
    }
    fn _type_default() -> String {
        String::from("team_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum TeamReferenceTypeEnum { 
    #[serde(rename = "team_reference")]
    TEAM_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for TeamReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            TeamReferenceTypeEnum::TEAM_REFERENCE => write!(f, "{}", "team_reference"),
            TeamReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for TeamReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "team_reference" => Ok(TeamReferenceTypeEnum::TEAM_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for TeamReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            TeamReferenceTypeEnum::TEAM_REFERENCE => "team_reference",
            TeamReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for TeamReferenceTypeEnum {
    fn default() -> Self {
        TeamReferenceTypeEnum::TEAM_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateTeam {     
    pub team: Team,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateTeam {     
    pub team: Team,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct User {     
    /// The label of the tag.
    #[serde(default="User::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The name of the user.
    #[serde(skip_serializing_if="String::is_empty")]
    pub name: String,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: UserTypeEnum,
    /// The user's email address.
    #[serde(skip_serializing_if="String::is_empty")]
    pub email: String,
    /// The preferred time zone name. If null, the account's time zone will be used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub time_zone: Option<String>,
    /// The schedule color.
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<String>,
    /// The user role. Account must have the `read_only_users` ability to set a user as a `read_only_user` or a `read_only_limited_user`, and must have advanced permissions abilities to set a user as `observer` or `restricted_access`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<UserRoleEnum>,
    /// The URL of the user's avatar.
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    /// The user's bio.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// If true, the user has an outstanding invitation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub invitation_sent: Option<bool>,
    /// The user's title.
    #[serde(skip_serializing_if="Option::is_none")]
    pub job_title: Option<String>,
    /// The list of teams to which the user belongs. Account must have the `teams` ability to set this.
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    /// The list of contact methods for the user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub contact_methods: Option<Vec<ContactMethodReference>>,
    /// The list of notification rules for the user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_rules: Option<Vec<NotificationRuleReference>>,
}

impl Default for User {
    fn default() -> Self {
        Self {
            label: String::from("User"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            name: Default::default(),
            _type: Default::default(),
            email: Default::default(),
            time_zone: Default::default(),
            color: Default::default(),
            role: Default::default(),
            avatar_url: Default::default(),
            description: Default::default(),
            invitation_sent: Default::default(),
            job_title: Default::default(),
            teams: Default::default(),
            contact_methods: Default::default(),
            notification_rules: Default::default(),
        }
    }
}

impl User {
    fn label_default() -> String {
        String::from("User")
    }
    fn _type_default() -> String {
        String::from("user")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum UserTypeEnum { 
    #[serde(rename = "user")]
    USER,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for UserTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            UserTypeEnum::USER => write!(f, "{}", "user"),
            UserTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for UserTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "user" => Ok(UserTypeEnum::USER),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for UserTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            UserTypeEnum::USER => "user",
            UserTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for UserTypeEnum {
    fn default() -> Self {
        UserTypeEnum::USER
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum UserRoleEnum { 
    #[serde(rename = "admin")]
    ADMIN,
    #[serde(rename = "limited_user")]
    LIMITED_USER,
    #[serde(rename = "observer")]
    OBSERVER,
    #[serde(rename = "owner")]
    OWNER,
    #[serde(rename = "read_only_user")]
    READ_ONLY_USER,
    #[serde(rename = "restricted_access")]
    RESTRICTED_ACCESS,
    #[serde(rename = "read_only_limited_user")]
    READ_ONLY_LIMITED_USER,
    #[serde(rename = "user")]
    USER,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for UserRoleEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            UserRoleEnum::ADMIN => write!(f, "{}", "admin"),
            UserRoleEnum::LIMITED_USER => write!(f, "{}", "limited_user"),
            UserRoleEnum::OBSERVER => write!(f, "{}", "observer"),
            UserRoleEnum::OWNER => write!(f, "{}", "owner"),
            UserRoleEnum::READ_ONLY_USER => write!(f, "{}", "read_only_user"),
            UserRoleEnum::RESTRICTED_ACCESS => write!(f, "{}", "restricted_access"),
            UserRoleEnum::READ_ONLY_LIMITED_USER => write!(f, "{}", "read_only_limited_user"),
            UserRoleEnum::USER => write!(f, "{}", "user"),
            UserRoleEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for UserRoleEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "admin" => Ok(UserRoleEnum::ADMIN),
            "limited_user" => Ok(UserRoleEnum::LIMITED_USER),
            "observer" => Ok(UserRoleEnum::OBSERVER),
            "owner" => Ok(UserRoleEnum::OWNER),
            "read_only_user" => Ok(UserRoleEnum::READ_ONLY_USER),
            "restricted_access" => Ok(UserRoleEnum::RESTRICTED_ACCESS),
            "read_only_limited_user" => Ok(UserRoleEnum::READ_ONLY_LIMITED_USER),
            "user" => Ok(UserRoleEnum::USER),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for UserRoleEnum {
    fn as_ref(&self) -> &str {
        match self { 
            UserRoleEnum::ADMIN => "admin",
            UserRoleEnum::LIMITED_USER => "limited_user",
            UserRoleEnum::OBSERVER => "observer",
            UserRoleEnum::OWNER => "owner",
            UserRoleEnum::READ_ONLY_USER => "read_only_user",
            UserRoleEnum::RESTRICTED_ACCESS => "restricted_access",
            UserRoleEnum::READ_ONLY_LIMITED_USER => "read_only_limited_user",
            UserRoleEnum::USER => "user",
            UserRoleEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for UserRoleEnum {
    fn default() -> Self {
        UserRoleEnum::ADMIN
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct UserReference {     
    /// The label of the tag.
    #[serde(default="UserReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: UserReferenceTypeEnum,
}

impl Default for UserReference {
    fn default() -> Self {
        Self {
            label: String::from("UserReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl UserReference {
    fn label_default() -> String {
        String::from("UserReference")
    }
    fn _type_default() -> String {
        String::from("user_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum UserReferenceTypeEnum { 
    #[serde(rename = "user_reference")]
    USER_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for UserReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            UserReferenceTypeEnum::USER_REFERENCE => write!(f, "{}", "user_reference"),
            UserReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for UserReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "user_reference" => Ok(UserReferenceTypeEnum::USER_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for UserReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            UserReferenceTypeEnum::USER_REFERENCE => "user_reference",
            UserReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for UserReferenceTypeEnum {
    fn default() -> Self {
        UserReferenceTypeEnum::USER_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UserRole {     
    /// The role of the user for a set of resources.
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<UserRoleRoleEnum>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub resources: Option<Vec<Reference>>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum UserRoleRoleEnum { 
    #[serde(rename = "observer")]
    OBSERVER,
    #[serde(rename = "responder")]
    RESPONDER,
    #[serde(rename = "manager")]
    MANAGER,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for UserRoleRoleEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            UserRoleRoleEnum::OBSERVER => write!(f, "{}", "observer"),
            UserRoleRoleEnum::RESPONDER => write!(f, "{}", "responder"),
            UserRoleRoleEnum::MANAGER => write!(f, "{}", "manager"),
            UserRoleRoleEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for UserRoleRoleEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "observer" => Ok(UserRoleRoleEnum::OBSERVER),
            "responder" => Ok(UserRoleRoleEnum::RESPONDER),
            "manager" => Ok(UserRoleRoleEnum::MANAGER),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for UserRoleRoleEnum {
    fn as_ref(&self) -> &str {
        match self { 
            UserRoleRoleEnum::OBSERVER => "observer",
            UserRoleRoleEnum::RESPONDER => "responder",
            UserRoleRoleEnum::MANAGER => "manager",
            UserRoleRoleEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for UserRoleRoleEnum {
    fn default() -> Self {
        UserRoleRoleEnum::OBSERVER
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UserSession {     
    #[serde(skip_serializing_if="String::is_empty")]
    pub id: String,
    #[serde(skip_serializing_if="String::is_empty")]
    pub user_id: String,
    /// The date/time the user session was first created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The type of the session
    #[serde(rename = "type")]
    pub _type: UserSessionTypeEnum,
    /// The summary of the session
    #[serde(skip_serializing_if="String::is_empty")]
    pub summary: String,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum UserSessionTypeEnum { 
    #[serde(rename = "browser")]
    BROWSER,
    #[serde(rename = "oauth")]
    OAUTH,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for UserSessionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            UserSessionTypeEnum::BROWSER => write!(f, "{}", "browser"),
            UserSessionTypeEnum::OAUTH => write!(f, "{}", "oauth"),
            UserSessionTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for UserSessionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "browser" => Ok(UserSessionTypeEnum::BROWSER),
            "oauth" => Ok(UserSessionTypeEnum::OAUTH),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for UserSessionTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            UserSessionTypeEnum::BROWSER => "browser",
            UserSessionTypeEnum::OAUTH => "oauth",
            UserSessionTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for UserSessionTypeEnum {
    fn default() -> Self {
        UserSessionTypeEnum::BROWSER
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CreateUser {     
    pub user: User,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateUser {     
    pub user: User,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateTeamUser {     
    /// The role of the user on the team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<UpdateTeamUserRoleEnum>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum UpdateTeamUserRoleEnum { 
    #[serde(rename = "observer")]
    OBSERVER,
    #[serde(rename = "responder")]
    RESPONDER,
    #[serde(rename = "manager")]
    MANAGER,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for UpdateTeamUserRoleEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            UpdateTeamUserRoleEnum::OBSERVER => write!(f, "{}", "observer"),
            UpdateTeamUserRoleEnum::RESPONDER => write!(f, "{}", "responder"),
            UpdateTeamUserRoleEnum::MANAGER => write!(f, "{}", "manager"),
            UpdateTeamUserRoleEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for UpdateTeamUserRoleEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "observer" => Ok(UpdateTeamUserRoleEnum::OBSERVER),
            "responder" => Ok(UpdateTeamUserRoleEnum::RESPONDER),
            "manager" => Ok(UpdateTeamUserRoleEnum::MANAGER),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for UpdateTeamUserRoleEnum {
    fn as_ref(&self) -> &str {
        match self { 
            UpdateTeamUserRoleEnum::OBSERVER => "observer",
            UpdateTeamUserRoleEnum::RESPONDER => "responder",
            UpdateTeamUserRoleEnum::MANAGER => "manager",
            UpdateTeamUserRoleEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for UpdateTeamUserRoleEnum {
    fn default() -> Self {
        UpdateTeamUserRoleEnum::OBSERVER
    }
}

/// A rule for contacting the user for Incident Status Updates.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UsersidstatusUpdateNotificationRulesStatusUpdateNotificationRule {     
    pub contact_method: ContactMethodReference,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Vendor {     
    /// The label of the tag.
    #[serde(default="Vendor::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default="Vendor::_type_default")]
    pub _type: String,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The short name of the vendor
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// URL of the vendor's main website
    #[serde(skip_serializing_if="Option::is_none")]
    pub website_url: Option<String>,
    /// URL of a logo identifying the vendor
    #[serde(skip_serializing_if="Option::is_none")]
    pub logo_url: Option<String>,
    /// URL of a small thumbnail image identifying the vendor
    #[serde(skip_serializing_if="Option::is_none")]
    pub thumbnail_url: Option<String>,
    /// A short description of this vendor, and common use-cases of integrations for this vendor.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// URL of an integration guide for this vendor
    #[serde(skip_serializing_if="Option::is_none")]
    pub integration_guide_url: Option<String>,
}

impl Default for Vendor {
    fn default() -> Self {
        Self {
            label: String::from("Vendor"),
            html_url: Default::default(),
            _self: Default::default(),
            _type: String::from("vendor"),
            summary: Default::default(),
            id: Default::default(),
            name: Default::default(),
            website_url: Default::default(),
            logo_url: Default::default(),
            thumbnail_url: Default::default(),
            description: Default::default(),
            integration_guide_url: Default::default(),
        }
    }
}

impl Vendor {
    fn label_default() -> String {
        String::from("Vendor")
    }
    fn _type_default() -> String {
        String::from("vendor")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct VendorReference {     
    /// The label of the tag.
    #[serde(default="VendorReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: VendorReferenceTypeEnum,
}

impl Default for VendorReference {
    fn default() -> Self {
        Self {
            label: String::from("VendorReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl VendorReference {
    fn label_default() -> String {
        String::from("VendorReference")
    }
    fn _type_default() -> String {
        String::from("vendor_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum VendorReferenceTypeEnum { 
    #[serde(rename = "vendor_reference")]
    VENDOR_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for VendorReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            VendorReferenceTypeEnum::VENDOR_REFERENCE => write!(f, "{}", "vendor_reference"),
            VendorReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for VendorReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "vendor_reference" => Ok(VendorReferenceTypeEnum::VENDOR_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for VendorReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            VendorReferenceTypeEnum::VENDOR_REFERENCE => "vendor_reference",
            VendorReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for VendorReferenceTypeEnum {
    fn default() -> Self {
        VendorReferenceTypeEnum::VENDOR_REFERENCE
    }
}

/// Information about the configured webhook.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Webhook {     
    /// The url endpoint the webhook payload is sent to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoint_url: Option<String>,
    /// The name of the webhook.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook_object: Option<WebhookObject>,
    /// The object that contains webhook configuration values depending on the webhook type specification.
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub outbound_integration: Option<OutboundIntegrationReference>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIncidentAction {     
    /// Uniquely identifies this outgoing webhook message; can be used for idempotency when processing the messages.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<uuid::Uuid>,
    /// The date/time when this message was was sent.
    #[serde(skip_serializing_if="Option::is_none")]
    pub triggered_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook: Option<Webhook>,
    /// The type of action being reported by this message. * `incident.trigger` - Sent when an incident is newly created/triggered. * `incident.acknowledge` - Sent when an incident is acknowledged by a user. * `incident.unacknowledge` - Sent when an incident is unacknowledged due to its acknowledgement timing out. * `incident.resolve` - Sent when an incident has been resolved. * `incident.assign` - Sent when an incident has been assigned to another user. Often occurs in concert with an `acknowledge`. * `incident.escalate` - Sent when an incident has been escalated to another user in the same escalation chain. * `incident.delegate` - Sent when an incident has been reassigned to another escalation policy. * `incident.annotate` - Sent when a note is created on an incident. 
    #[serde(rename = "type")]
    pub _type: WebhookIncidentActionTypeEnum,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident: Option<Incident>,
    /// Log Entries that correspond to the action this Webhook is reporting. Includes the channels.
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_entries: Option<Vec<LogEntry>>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhookIncidentActionTypeEnum { 
    #[serde(rename = "incident.trigger")]
    TRIGGER,
    #[serde(rename = "incident.acknowledge")]
    ACKNOWLEDGE,
    #[serde(rename = "incident.unacknowledge")]
    UNACKNOWLEDGE,
    #[serde(rename = "incident.resolve")]
    RESOLVE,
    #[serde(rename = "incident.assign")]
    ASSIGN,
    #[serde(rename = "incident.escalate")]
    ESCALATE,
    #[serde(rename = "incident.delegate")]
    DELEGATE,
    #[serde(rename = "incident.annotate")]
    ANNOTATE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhookIncidentActionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            WebhookIncidentActionTypeEnum::TRIGGER => write!(f, "{}", "incident.trigger"),
            WebhookIncidentActionTypeEnum::ACKNOWLEDGE => write!(f, "{}", "incident.acknowledge"),
            WebhookIncidentActionTypeEnum::UNACKNOWLEDGE => write!(f, "{}", "incident.unacknowledge"),
            WebhookIncidentActionTypeEnum::RESOLVE => write!(f, "{}", "incident.resolve"),
            WebhookIncidentActionTypeEnum::ASSIGN => write!(f, "{}", "incident.assign"),
            WebhookIncidentActionTypeEnum::ESCALATE => write!(f, "{}", "incident.escalate"),
            WebhookIncidentActionTypeEnum::DELEGATE => write!(f, "{}", "incident.delegate"),
            WebhookIncidentActionTypeEnum::ANNOTATE => write!(f, "{}", "incident.annotate"),
            WebhookIncidentActionTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhookIncidentActionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "incident.trigger" => Ok(WebhookIncidentActionTypeEnum::TRIGGER),
            "incident.acknowledge" => Ok(WebhookIncidentActionTypeEnum::ACKNOWLEDGE),
            "incident.unacknowledge" => Ok(WebhookIncidentActionTypeEnum::UNACKNOWLEDGE),
            "incident.resolve" => Ok(WebhookIncidentActionTypeEnum::RESOLVE),
            "incident.assign" => Ok(WebhookIncidentActionTypeEnum::ASSIGN),
            "incident.escalate" => Ok(WebhookIncidentActionTypeEnum::ESCALATE),
            "incident.delegate" => Ok(WebhookIncidentActionTypeEnum::DELEGATE),
            "incident.annotate" => Ok(WebhookIncidentActionTypeEnum::ANNOTATE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhookIncidentActionTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            WebhookIncidentActionTypeEnum::TRIGGER => "incident.trigger",
            WebhookIncidentActionTypeEnum::ACKNOWLEDGE => "incident.acknowledge",
            WebhookIncidentActionTypeEnum::UNACKNOWLEDGE => "incident.unacknowledge",
            WebhookIncidentActionTypeEnum::RESOLVE => "incident.resolve",
            WebhookIncidentActionTypeEnum::ASSIGN => "incident.assign",
            WebhookIncidentActionTypeEnum::ESCALATE => "incident.escalate",
            WebhookIncidentActionTypeEnum::DELEGATE => "incident.delegate",
            WebhookIncidentActionTypeEnum::ANNOTATE => "incident.annotate",
            WebhookIncidentActionTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhookIncidentActionTypeEnum {
    fn default() -> Self {
        WebhookIncidentActionTypeEnum::TRIGGER
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookObject {     
    /// The label of the tag.
    #[serde(default="WebhookObject::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: WebhookObjectTypeEnum,
}

impl Default for WebhookObject {
    fn default() -> Self {
        Self {
            label: String::from("WebhookObject"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl WebhookObject {
    fn label_default() -> String {
        String::from("WebhookObject")
    }
    fn _type_default() -> String {
        String::from("webhook_object")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhookObjectTypeEnum { 
    #[serde(rename = "service")]
    SERVICE,
    #[serde(rename = "service_reference")]
    SERVICE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhookObjectTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            WebhookObjectTypeEnum::SERVICE => write!(f, "{}", "service"),
            WebhookObjectTypeEnum::SERVICE_REFERENCE => write!(f, "{}", "service_reference"),
            WebhookObjectTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhookObjectTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "service" => Ok(WebhookObjectTypeEnum::SERVICE),
            "service_reference" => Ok(WebhookObjectTypeEnum::SERVICE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhookObjectTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            WebhookObjectTypeEnum::SERVICE => "service",
            WebhookObjectTypeEnum::SERVICE_REFERENCE => "service_reference",
            WebhookObjectTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhookObjectTypeEnum {
    fn default() -> Self {
        WebhookObjectTypeEnum::SERVICE
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookReference {     
    /// The label of the tag.
    #[serde(default="WebhookReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: WebhookReferenceTypeEnum,
}

impl Default for WebhookReference {
    fn default() -> Self {
        Self {
            label: String::from("WebhookReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl WebhookReference {
    fn label_default() -> String {
        String::from("WebhookReference")
    }
    fn _type_default() -> String {
        String::from("webhook_reference")
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhookReferenceTypeEnum { 
    #[serde(rename = "webhook_reference")]
    WEBHOOK_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhookReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            WebhookReferenceTypeEnum::WEBHOOK_REFERENCE => write!(f, "{}", "webhook_reference"),
            WebhookReferenceTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhookReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "webhook_reference" => Ok(WebhookReferenceTypeEnum::WEBHOOK_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhookReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            WebhookReferenceTypeEnum::WEBHOOK_REFERENCE => "webhook_reference",
            WebhookReferenceTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhookReferenceTypeEnum {
    fn default() -> Self {
        WebhookReferenceTypeEnum::WEBHOOK_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksV1AssignedTo {     
    /// Time at which the assignment was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub object: Option<AllOfWebhooksV1AssignedToObject>,
}

/// The user assigned to the incident.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksV1AssignedToUser {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The user's name.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The user's email address.
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

/// The incident details at the time of the state change.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksV1IncidentData {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The number of the incident. This is unique across the account.
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident_number: Option<isize>,
    /// The date/time the incident was first triggered.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_on: Option<chrono::DateTime<chrono::Utc>>,
    /// The current status of the incident.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<WebhooksV1IncidentDataStatusEnum>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The incident's de-duplication key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident_key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub service: Option<WebhooksV1Service>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assigned_to_user: Option<WebhooksV1AssignedToUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assigned_to: Option<Vec<WebhooksV1AssignedTo>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trigger_summary_data: Option<WebhooksV1IncidentDataTriggerSummaryData>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trigger_details_html_url: Option<String>,
    /// The time at which the status of the incident last changed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_status_change_on: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_status_change_by: Option<WebhooksV1AssignedToUser>,
    /// Number of times the incident has been escalated.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number_of_escalations: Option<usize>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub urgency: Option<WebhooksV1IncidentDataUrgencyEnum>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhooksV1IncidentDataStatusEnum { 
    #[serde(rename = "triggered")]
    TRIGGERED,
    #[serde(rename = "acknowledged")]
    ACKNOWLEDGED,
    #[serde(rename = "resolved")]
    RESOLVED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhooksV1IncidentDataStatusEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            WebhooksV1IncidentDataStatusEnum::TRIGGERED => write!(f, "{}", "triggered"),
            WebhooksV1IncidentDataStatusEnum::ACKNOWLEDGED => write!(f, "{}", "acknowledged"),
            WebhooksV1IncidentDataStatusEnum::RESOLVED => write!(f, "{}", "resolved"),
            WebhooksV1IncidentDataStatusEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhooksV1IncidentDataStatusEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "triggered" => Ok(WebhooksV1IncidentDataStatusEnum::TRIGGERED),
            "acknowledged" => Ok(WebhooksV1IncidentDataStatusEnum::ACKNOWLEDGED),
            "resolved" => Ok(WebhooksV1IncidentDataStatusEnum::RESOLVED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhooksV1IncidentDataStatusEnum {
    fn as_ref(&self) -> &str {
        match self { 
            WebhooksV1IncidentDataStatusEnum::TRIGGERED => "triggered",
            WebhooksV1IncidentDataStatusEnum::ACKNOWLEDGED => "acknowledged",
            WebhooksV1IncidentDataStatusEnum::RESOLVED => "resolved",
            WebhooksV1IncidentDataStatusEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhooksV1IncidentDataStatusEnum {
    fn default() -> Self {
        WebhooksV1IncidentDataStatusEnum::TRIGGERED
    }
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhooksV1IncidentDataUrgencyEnum { 
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhooksV1IncidentDataUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            WebhooksV1IncidentDataUrgencyEnum::HIGH => write!(f, "{}", "high"),
            WebhooksV1IncidentDataUrgencyEnum::LOW => write!(f, "{}", "low"),
            WebhooksV1IncidentDataUrgencyEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhooksV1IncidentDataUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "high" => Ok(WebhooksV1IncidentDataUrgencyEnum::HIGH),
            "low" => Ok(WebhooksV1IncidentDataUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhooksV1IncidentDataUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self { 
            WebhooksV1IncidentDataUrgencyEnum::HIGH => "high",
            WebhooksV1IncidentDataUrgencyEnum::LOW => "low",
            WebhooksV1IncidentDataUrgencyEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhooksV1IncidentDataUrgencyEnum {
    fn default() -> Self {
        WebhooksV1IncidentDataUrgencyEnum::HIGH
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksV1IncidentDataTriggerSummaryData {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject: Option<String>,
}

/// A message containing information about a single PagerDuty action.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksV1Message {     
    /// Uniquely identifies this outgoing webhook message; can be used for idempotency when processing the messages.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<uuid::Uuid>,
    /// The type of action being reported by this message.
    #[serde(rename = "type")]
    pub _type: WebhooksV1MessageTypeEnum,
    /// The date/time when the incident changed state.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_on: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<WebhooksV1MessageData>,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhooksV1MessageTypeEnum { 
    #[serde(rename = "incident.trigger")]
    TRIGGER,
    #[serde(rename = "incident.acknowledge")]
    ACKNOWLEDGE,
    #[serde(rename = "incident.unacknowledge")]
    UNACKNOWLEDGE,
    #[serde(rename = "incident.resolve")]
    RESOLVE,
    #[serde(rename = "incident.assign")]
    ASSIGN,
    #[serde(rename = "incident.escalate")]
    ESCALATE,
    #[serde(rename = "incident.delegate")]
    DELEGATE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhooksV1MessageTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            WebhooksV1MessageTypeEnum::TRIGGER => write!(f, "{}", "incident.trigger"),
            WebhooksV1MessageTypeEnum::ACKNOWLEDGE => write!(f, "{}", "incident.acknowledge"),
            WebhooksV1MessageTypeEnum::UNACKNOWLEDGE => write!(f, "{}", "incident.unacknowledge"),
            WebhooksV1MessageTypeEnum::RESOLVE => write!(f, "{}", "incident.resolve"),
            WebhooksV1MessageTypeEnum::ASSIGN => write!(f, "{}", "incident.assign"),
            WebhooksV1MessageTypeEnum::ESCALATE => write!(f, "{}", "incident.escalate"),
            WebhooksV1MessageTypeEnum::DELEGATE => write!(f, "{}", "incident.delegate"),
            WebhooksV1MessageTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhooksV1MessageTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "incident.trigger" => Ok(WebhooksV1MessageTypeEnum::TRIGGER),
            "incident.acknowledge" => Ok(WebhooksV1MessageTypeEnum::ACKNOWLEDGE),
            "incident.unacknowledge" => Ok(WebhooksV1MessageTypeEnum::UNACKNOWLEDGE),
            "incident.resolve" => Ok(WebhooksV1MessageTypeEnum::RESOLVE),
            "incident.assign" => Ok(WebhooksV1MessageTypeEnum::ASSIGN),
            "incident.escalate" => Ok(WebhooksV1MessageTypeEnum::ESCALATE),
            "incident.delegate" => Ok(WebhooksV1MessageTypeEnum::DELEGATE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhooksV1MessageTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            WebhooksV1MessageTypeEnum::TRIGGER => "incident.trigger",
            WebhooksV1MessageTypeEnum::ACKNOWLEDGE => "incident.acknowledge",
            WebhooksV1MessageTypeEnum::UNACKNOWLEDGE => "incident.unacknowledge",
            WebhooksV1MessageTypeEnum::RESOLVE => "incident.resolve",
            WebhooksV1MessageTypeEnum::ASSIGN => "incident.assign",
            WebhooksV1MessageTypeEnum::ESCALATE => "incident.escalate",
            WebhooksV1MessageTypeEnum::DELEGATE => "incident.delegate",
            WebhooksV1MessageTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhooksV1MessageTypeEnum {
    fn default() -> Self {
        WebhooksV1MessageTypeEnum::TRIGGER
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksV1MessageData {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub incident: Option<WebhooksV1IncidentData>,
}

/// The service on which the incident occurred.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksV1Service {     
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The name of the service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The date/time the service was deleted, if it has been removed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The description of the service.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WeeklyRestriction {     
    /// Specify the types of `restriction`.
    #[serde(rename = "type")]
    pub _type: WeeklyRestrictionTypeEnum,
    /// The duration of the restriction in seconds.
    pub duration_seconds: isize,
    /// The start time in HH:mm:ss format.
    #[serde(skip_serializing_if="String::is_empty")]
    pub start_time_of_day: String,
    /// The first day of the weekly rotation schedule as [ISO 8601 day](https://en.wikipedia.org/wiki/ISO_week_date) (1 is Monday, etc.)
    pub start_day_of_week: u8,
}


#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WeeklyRestrictionTypeEnum { 
    #[serde(rename = "daily_restriction")]
    DAILY_RESTRICTION,
    #[serde(rename = "weekly_restriction")]
    WEEKLY_RESTRICTION,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WeeklyRestrictionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self { 
            WeeklyRestrictionTypeEnum::DAILY_RESTRICTION => write!(f, "{}", "daily_restriction"),
            WeeklyRestrictionTypeEnum::WEEKLY_RESTRICTION => write!(f, "{}", "weekly_restriction"),
            WeeklyRestrictionTypeEnum::UNKNOWN => write!(f, "{}", "unknown"),
        }
    }
}

impl ::std::str::FromStr for WeeklyRestrictionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s { 
            "daily_restriction" => Ok(WeeklyRestrictionTypeEnum::DAILY_RESTRICTION),
            "weekly_restriction" => Ok(WeeklyRestrictionTypeEnum::WEEKLY_RESTRICTION),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WeeklyRestrictionTypeEnum {
    fn as_ref(&self) -> &str {
        match self { 
            WeeklyRestrictionTypeEnum::DAILY_RESTRICTION => "daily_restriction",
            WeeklyRestrictionTypeEnum::WEEKLY_RESTRICTION => "weekly_restriction",
            WeeklyRestrictionTypeEnum::UNKNOWN => "unknown"
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WeeklyRestrictionTypeEnum {
    fn default() -> Self {
        WeeklyRestrictionTypeEnum::DAILY_RESTRICTION
    }
}
