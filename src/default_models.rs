#![allow(unused_imports, unused_qualifications, unused_extern_crates)]
/*
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::de::{DeserializeOwned, Deserializer};
use serde::ser::Serializer;
use serde::Deserialize;
use serde_json::value::Value;

use std::cmp::Eq;
use std::collections::HashMap;
use std::default::Default;
use std::fmt::{self, Display, Formatter};
use std::hash::Hash;

use chrono::DateTime;
use chrono::Utc;

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Acknowledgement {
    /// Time at which the acknowledgement was created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub at: Option<chrono::DateTime<chrono::Utc>>,
    pub acknowledger: AcknowledgerReference,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AcknowledgerReference {
    /// The label of the tag.
    #[serde(default = "AcknowledgerReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: AcknowledgerReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for AcknowledgerReference {
    fn default() -> Self {
        Self {
            label: String::from("AcknowledgerReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl AcknowledgerReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("AcknowledgerReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("acknowledger_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AcknowledgerReferenceTypeEnum {
    #[serde(rename = "user_reference")]
    USER_REFERENCE,
    #[serde(rename = "service_reference")]
    SERVICE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AcknowledgerReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AcknowledgerReferenceTypeEnum::USER_REFERENCE => write!(f, "user_reference"),
            AcknowledgerReferenceTypeEnum::SERVICE_REFERENCE => write!(f, "service_reference"),
            AcknowledgerReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AcknowledgerReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "user_reference" => Ok(AcknowledgerReferenceTypeEnum::USER_REFERENCE),
            "service_reference" => Ok(AcknowledgerReferenceTypeEnum::SERVICE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AcknowledgerReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            AcknowledgerReferenceTypeEnum::USER_REFERENCE => "user_reference",
            AcknowledgerReferenceTypeEnum::SERVICE_REFERENCE => "service_reference",
            AcknowledgerReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AcknowledgerReferenceTypeEnum {
    fn default() -> Self {
        AcknowledgerReferenceTypeEnum::USER_REFERENCE
    }
}

/// A message containing information about a single PagerDuty action.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Action {
    /// Uniquely identifies this outgoing webhook message; can be used for idempotency when processing the messages.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<uuid::Uuid>,
    /// The date/time when this message was was sent.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub triggered_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub webhook: Option<Webhook>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Addon {
    /// The label of the tag.
    #[serde(default = "Addon::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of Add-on.
    #[serde(rename = "type")]
    pub _type: AddonTypeEnum,
    /// The name of the Add-on.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub name: String,
    /// The source URL to display in a frame in the PagerDuty UI. HTTPS is required.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub src: String,
}

#[allow(clippy::derivable_impls)]
impl Default for Addon {
    fn default() -> Self {
        Self {
            label: String::from("Addon"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            name: Default::default(),
            src: Default::default(),
        }
    }
}

impl Addon {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Addon")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("addon")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AddonTypeEnum {
    #[serde(rename = "full_page_addon")]
    FULL_PAGE_ADDON,
    #[serde(rename = "incident_show_addon")]
    INCIDENT_SHOW_ADDON,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AddonTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AddonTypeEnum::FULL_PAGE_ADDON => write!(f, "full_page_addon"),
            AddonTypeEnum::INCIDENT_SHOW_ADDON => write!(f, "incident_show_addon"),
            AddonTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AddonTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "full_page_addon" => Ok(AddonTypeEnum::FULL_PAGE_ADDON),
            "incident_show_addon" => Ok(AddonTypeEnum::INCIDENT_SHOW_ADDON),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AddonTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            AddonTypeEnum::FULL_PAGE_ADDON => "full_page_addon",
            AddonTypeEnum::INCIDENT_SHOW_ADDON => "incident_show_addon",
            AddonTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AddonTypeEnum {
    fn default() -> Self {
        AddonTypeEnum::FULL_PAGE_ADDON
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AddonReference {
    /// The label of the tag.
    #[serde(default = "AddonReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The URL source of the Addon
    #[serde(skip_serializing_if = "Option::is_none")]
    pub src: Option<String>,
    /// The user entered name of the Addon.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type")]
    pub _type: AddonReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for AddonReference {
    fn default() -> Self {
        Self {
            label: String::from("AddonReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            src: Default::default(),
            name: Default::default(),
            _type: Default::default(),
        }
    }
}

impl AddonReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("AddonReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("addon_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AddonReferenceTypeEnum {
    #[serde(rename = "full_page_addon_reference")]
    FULL_PAGE_ADDON_REFERENCE,
    #[serde(rename = "incident_show_addon_reference")]
    INCIDENT_SHOW_ADDON_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AddonReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AddonReferenceTypeEnum::FULL_PAGE_ADDON_REFERENCE => write!(f, "full_page_addon_reference"),
            AddonReferenceTypeEnum::INCIDENT_SHOW_ADDON_REFERENCE => write!(f, "incident_show_addon_reference"),
            AddonReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AddonReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "full_page_addon_reference" => Ok(AddonReferenceTypeEnum::FULL_PAGE_ADDON_REFERENCE),
            "incident_show_addon_reference" => Ok(AddonReferenceTypeEnum::INCIDENT_SHOW_ADDON_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AddonReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            AddonReferenceTypeEnum::FULL_PAGE_ADDON_REFERENCE => "full_page_addon_reference",
            AddonReferenceTypeEnum::INCIDENT_SHOW_ADDON_REFERENCE => "incident_show_addon_reference",
            AddonReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AddonReferenceTypeEnum {
    fn default() -> Self {
        AddonReferenceTypeEnum::FULL_PAGE_ADDON_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateAddon {
    pub addon: Addon,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateAddon {
    pub addon: Addon,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AgentReference {
    /// The label of the tag.
    #[serde(default = "AgentReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: AgentReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for AgentReference {
    fn default() -> Self {
        Self {
            label: String::from("AgentReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl AgentReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("AgentReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("agent_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AgentReferenceTypeEnum {
    #[serde(rename = "user_reference")]
    USER_REFERENCE,
    #[serde(rename = "service_reference")]
    SERVICE_REFERENCE,
    #[serde(rename = "integration_reference")]
    INTEGRATION_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AgentReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AgentReferenceTypeEnum::USER_REFERENCE => write!(f, "user_reference"),
            AgentReferenceTypeEnum::SERVICE_REFERENCE => write!(f, "service_reference"),
            AgentReferenceTypeEnum::INTEGRATION_REFERENCE => write!(f, "integration_reference"),
            AgentReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AgentReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "user_reference" => Ok(AgentReferenceTypeEnum::USER_REFERENCE),
            "service_reference" => Ok(AgentReferenceTypeEnum::SERVICE_REFERENCE),
            "integration_reference" => Ok(AgentReferenceTypeEnum::INTEGRATION_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AgentReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            AgentReferenceTypeEnum::USER_REFERENCE => "user_reference",
            AgentReferenceTypeEnum::SERVICE_REFERENCE => "service_reference",
            AgentReferenceTypeEnum::INTEGRATION_REFERENCE => "integration_reference",
            AgentReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AgentReferenceTypeEnum {
    fn default() -> Self {
        AgentReferenceTypeEnum::USER_REFERENCE
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Alert {
    /// The label of the tag.
    #[serde(default = "Alert::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The date/time the alert was first triggered.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: AlertTypeEnum,
    /// The current status of the alert.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<AlertStatusEnum>,
    /// The alert's de-duplication key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_key: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service: Option<ServiceReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub first_trigger_log_entry: Option<LogEntryReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<IncidentReference>,
    /// Whether or not an alert is suppressed. Suppressed alerts are not created with a parent incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suppressed: Option<bool>,
    /// The magnitude of the problem as reported by the monitoring tool.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub severity: Option<AlertSeverityEnum>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub integration: Option<IntegrationReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub body: Option<Body>,
}

#[allow(clippy::derivable_impls)]
impl Default for Alert {
    fn default() -> Self {
        Self {
            label: String::from("Alert"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            created_at: Default::default(),
            _type: Default::default(),
            status: Default::default(),
            alert_key: Default::default(),
            service: Default::default(),
            first_trigger_log_entry: Default::default(),
            incident: Default::default(),
            suppressed: Default::default(),
            severity: Default::default(),
            integration: Default::default(),
            body: Default::default(),
        }
    }
}

impl Alert {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Alert")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("alert")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AlertTypeEnum {
    #[serde(rename = "alert")]
    ALERT,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AlertTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AlertTypeEnum::ALERT => write!(f, "alert"),
            AlertTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AlertTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "alert" => Ok(AlertTypeEnum::ALERT),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AlertTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            AlertTypeEnum::ALERT => "alert",
            AlertTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AlertTypeEnum {
    fn default() -> Self {
        AlertTypeEnum::ALERT
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AlertStatusEnum {
    #[serde(rename = "triggered")]
    TRIGGERED,
    #[serde(rename = "resolved")]
    RESOLVED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AlertStatusEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AlertStatusEnum::TRIGGERED => write!(f, "triggered"),
            AlertStatusEnum::RESOLVED => write!(f, "resolved"),
            AlertStatusEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AlertStatusEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "triggered" => Ok(AlertStatusEnum::TRIGGERED),
            "resolved" => Ok(AlertStatusEnum::RESOLVED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AlertStatusEnum {
    fn as_ref(&self) -> &str {
        match self {
            AlertStatusEnum::TRIGGERED => "triggered",
            AlertStatusEnum::RESOLVED => "resolved",
            AlertStatusEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AlertStatusEnum {
    fn default() -> Self {
        AlertStatusEnum::TRIGGERED
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AlertSeverityEnum {
    #[serde(rename = "info")]
    INFO,
    #[serde(rename = "warning")]
    WARNING,
    #[serde(rename = "error")]
    ERROR,
    #[serde(rename = "critical")]
    CRITICAL,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AlertSeverityEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AlertSeverityEnum::INFO => write!(f, "info"),
            AlertSeverityEnum::WARNING => write!(f, "warning"),
            AlertSeverityEnum::ERROR => write!(f, "error"),
            AlertSeverityEnum::CRITICAL => write!(f, "critical"),
            AlertSeverityEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AlertSeverityEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "info" => Ok(AlertSeverityEnum::INFO),
            "warning" => Ok(AlertSeverityEnum::WARNING),
            "error" => Ok(AlertSeverityEnum::ERROR),
            "critical" => Ok(AlertSeverityEnum::CRITICAL),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AlertSeverityEnum {
    fn as_ref(&self) -> &str {
        match self {
            AlertSeverityEnum::INFO => "info",
            AlertSeverityEnum::WARNING => "warning",
            AlertSeverityEnum::ERROR => "error",
            AlertSeverityEnum::CRITICAL => "critical",
            AlertSeverityEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AlertSeverityEnum {
    fn default() -> Self {
        AlertSeverityEnum::INFO
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AlertCount {
    /// The count of triggered alerts
    #[serde(skip_serializing_if = "Option::is_none")]
    pub triggered: Option<isize>,
    /// The count of resolved alerts
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolved: Option<isize>,
    /// The total count of alerts
    #[serde(skip_serializing_if = "Option::is_none")]
    pub all: Option<isize>,
}

/// Defines how alerts on this service will be automatically grouped into incidents. Note that the alert grouping features are available only on certain plans. 
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AlertGroupingParameters {
    /// The type of Alert Grouping. When `type` is `intelligent`, `config` can be omitted.
    #[serde(rename = "type")]
    pub _type: AlertGroupingParametersTypeEnum,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub config: Option<AlertGroupingParametersConfigEnum>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AlertGroupingParametersTypeEnum {
    #[serde(rename = "time")]
    TIME,
    #[serde(rename = "intelligent")]
    INTELLIGENT,
    #[serde(rename = "content_based")]
    CONTENT_BASED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AlertGroupingParametersTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AlertGroupingParametersTypeEnum::TIME => write!(f, "time"),
            AlertGroupingParametersTypeEnum::INTELLIGENT => write!(f, "intelligent"),
            AlertGroupingParametersTypeEnum::CONTENT_BASED => write!(f, "content_based"),
            AlertGroupingParametersTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AlertGroupingParametersTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "time" => Ok(AlertGroupingParametersTypeEnum::TIME),
            "intelligent" => Ok(AlertGroupingParametersTypeEnum::INTELLIGENT),
            "content_based" => Ok(AlertGroupingParametersTypeEnum::CONTENT_BASED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AlertGroupingParametersTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            AlertGroupingParametersTypeEnum::TIME => "time",
            AlertGroupingParametersTypeEnum::INTELLIGENT => "intelligent",
            AlertGroupingParametersTypeEnum::CONTENT_BASED => "content_based",
            AlertGroupingParametersTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AlertGroupingParametersTypeEnum {
    fn default() -> Self {
        AlertGroupingParametersTypeEnum::TIME
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AlertGroupingParametersConfigEnum {
    TIME_BASED_ALERT_GROUPING_CONFIGURATION(TimeBasedAlertGroupingConfiguration),
    CONTENT_BASED_ALERT_GROUPING_CONFIGURATION(ContentBasedAlertGroupingConfiguration),
}

impl Display for AlertGroupingParametersConfigEnum {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            AlertGroupingParametersConfigEnum::TIME_BASED_ALERT_GROUPING_CONFIGURATION(value) => write!(f, "{:?}", value),
            AlertGroupingParametersConfigEnum::CONTENT_BASED_ALERT_GROUPING_CONFIGURATION(value) => write!(f, "{:?}", value),
        }
    }
}

impl std::default::Default for AlertGroupingParametersConfigEnum {
    fn default() -> Self {
        AlertGroupingParametersConfigEnum::TIME_BASED_ALERT_GROUPING_CONFIGURATION(TimeBasedAlertGroupingConfiguration::default())
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AlertReference {
    /// The label of the tag.
    #[serde(default = "AlertReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: AlertReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for AlertReference {
    fn default() -> Self {
        Self {
            label: String::from("AlertReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl AlertReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("AlertReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("alert_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AlertReferenceTypeEnum {
    #[serde(rename = "alert_reference")]
    ALERT_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AlertReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AlertReferenceTypeEnum::ALERT_REFERENCE => write!(f, "alert_reference"),
            AlertReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AlertReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "alert_reference" => Ok(AlertReferenceTypeEnum::ALERT_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AlertReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            AlertReferenceTypeEnum::ALERT_REFERENCE => "alert_reference",
            AlertReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AlertReferenceTypeEnum {
    fn default() -> Self {
        AlertReferenceTypeEnum::ALERT_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateIncidentAlert {
    pub alert: Alert,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AllOfIncidentNoteUser {
    /// The label of the tag.
    #[serde(default = "AllOfIncidentNoteUser::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: AllOfIncidentNoteUserTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for AllOfIncidentNoteUser {
    fn default() -> Self {
        Self {
            label: String::from("AllOfIncidentNoteUser"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl AllOfIncidentNoteUser {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("AllOfIncidentNoteUser")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("all_of_incident_note_user")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AllOfIncidentNoteUserTypeEnum {
    #[serde(rename = "user_reference")]
    USER_REFERENCE,
    #[serde(rename = "bot_user_reference")]
    BOT_USER_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AllOfIncidentNoteUserTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AllOfIncidentNoteUserTypeEnum::USER_REFERENCE => write!(f, "user_reference"),
            AllOfIncidentNoteUserTypeEnum::BOT_USER_REFERENCE => write!(f, "bot_user_reference"),
            AllOfIncidentNoteUserTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AllOfIncidentNoteUserTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "user_reference" => Ok(AllOfIncidentNoteUserTypeEnum::USER_REFERENCE),
            "bot_user_reference" => Ok(AllOfIncidentNoteUserTypeEnum::BOT_USER_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AllOfIncidentNoteUserTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            AllOfIncidentNoteUserTypeEnum::USER_REFERENCE => "user_reference",
            AllOfIncidentNoteUserTypeEnum::BOT_USER_REFERENCE => "bot_user_reference",
            AllOfIncidentNoteUserTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AllOfIncidentNoteUserTypeEnum {
    fn default() -> Self {
        AllOfIncidentNoteUserTypeEnum::USER_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AllOfWebhooksV1AssignedToObject {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The user's name.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The user's email address.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    #[serde(rename = "type")]
    pub _type: AllOfWebhooksV1AssignedToObjectTypeEnum,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AllOfWebhooksV1AssignedToObjectTypeEnum {
    #[serde(rename = "user")]
    USER,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AllOfWebhooksV1AssignedToObjectTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AllOfWebhooksV1AssignedToObjectTypeEnum::USER => write!(f, "user"),
            AllOfWebhooksV1AssignedToObjectTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AllOfWebhooksV1AssignedToObjectTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "user" => Ok(AllOfWebhooksV1AssignedToObjectTypeEnum::USER),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AllOfWebhooksV1AssignedToObjectTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            AllOfWebhooksV1AssignedToObjectTypeEnum::USER => "user",
            AllOfWebhooksV1AssignedToObjectTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AllOfWebhooksV1AssignedToObjectTypeEnum {
    fn default() -> Self {
        AllOfWebhooksV1AssignedToObjectTypeEnum::USER
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AllOfinlineResponse20036ChangeEventsItems {
    /// The time at which the emitting tool detected or generated the event.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<chrono::DateTime<chrono::Utc>>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: AllOfinlineResponse20036ChangeEventsItemsTypeEnum,
    /// An array containing Service objects that this change event is associated with.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<ServiceReference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub integration: Option<Value>,
    /// This is the 32 character Integration Key for an Integration on a Service. The same Integration Key can be used for both alert and change events.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_key: Option<String>,
    /// A brief text summary of the event. Displayed in PagerDuty to provide information about the change. The maximum permitted length of this property is 1024 characters.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    /// The unique name of the location where the Change Event occurred.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    /// List of links to include.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ChangeEventLinks>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Vec<ChangeEventImages>>,
    /// Additional details about the change event.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custom_details: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub correlation_reason: Option<HashMap<String, Value>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AllOfinlineResponse20036ChangeEventsItemsTypeEnum {
    #[serde(rename = "change_event")]
    CHANGE_EVENT,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AllOfinlineResponse20036ChangeEventsItemsTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AllOfinlineResponse20036ChangeEventsItemsTypeEnum::CHANGE_EVENT => write!(f, "change_event"),
            AllOfinlineResponse20036ChangeEventsItemsTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AllOfinlineResponse20036ChangeEventsItemsTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "change_event" => Ok(AllOfinlineResponse20036ChangeEventsItemsTypeEnum::CHANGE_EVENT),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AllOfinlineResponse20036ChangeEventsItemsTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            AllOfinlineResponse20036ChangeEventsItemsTypeEnum::CHANGE_EVENT => "change_event",
            AllOfinlineResponse20036ChangeEventsItemsTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AllOfinlineResponse20036ChangeEventsItemsTypeEnum {
    fn default() -> Self {
        AllOfinlineResponse20036ChangeEventsItemsTypeEnum::CHANGE_EVENT
    }
}
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AllOfinlineResponse20036ChangeEventsItemsIntegration {
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AllOfrulesetsBodyRuleset {
    /// ID of the Ruleset.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    #[serde(rename = "type")]
    pub _type: AllOfrulesetsBodyRulesetTypeEnum,
    /// Name of the Ruleset.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub name: String,
    /// Routing keys routed to this Ruleset.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_keys: Option<Vec<String>>,
    /// The date the Ruleset was created at.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creator: Option<RulesetCreator>,
    /// The date the Ruleset was last updated.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updater: Option<RulesetUpdater>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team: Option<RulesetTeam>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AllOfrulesetsBodyRulesetTypeEnum {
    #[serde(rename = "global")]
    GLOBAL,
    #[serde(rename = "default_global")]
    DEFAULT_GLOBAL,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AllOfrulesetsBodyRulesetTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AllOfrulesetsBodyRulesetTypeEnum::GLOBAL => write!(f, "global"),
            AllOfrulesetsBodyRulesetTypeEnum::DEFAULT_GLOBAL => write!(f, "default_global"),
            AllOfrulesetsBodyRulesetTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AllOfrulesetsBodyRulesetTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "global" => Ok(AllOfrulesetsBodyRulesetTypeEnum::GLOBAL),
            "default_global" => Ok(AllOfrulesetsBodyRulesetTypeEnum::DEFAULT_GLOBAL),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AllOfrulesetsBodyRulesetTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            AllOfrulesetsBodyRulesetTypeEnum::GLOBAL => "global",
            AllOfrulesetsBodyRulesetTypeEnum::DEFAULT_GLOBAL => "default_global",
            AllOfrulesetsBodyRulesetTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AllOfrulesetsBodyRulesetTypeEnum {
    fn default() -> Self {
        AllOfrulesetsBodyRulesetTypeEnum::GLOBAL
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AnalyticsIncidentMetrics {
    /// Mean count of instances where responders were assigned an incident (including through reassignment or escalation) or accepted a responder request.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mean_assignment_count: Option<isize>,
    /// Mean engaged time across all responders for incidents that match the given filters. Engaged time is measured from the time a user engages with an incident (by acknowledging or accepting a responder request) until the incident is resolved. This may include periods in which the incidents was snoozed.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mean_engaged_seconds: Option<isize>,
    /// Mean number of users who engaged with an incident. *Engaged* is defined as acknowledging an incident or accepting a responder request in it.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mean_engaged_user_count: Option<isize>,
    /// A measure of *people response time*. This metric measures the time from the first user engagement (acknowledge or responder accept) to the last. This metric is only used for incidents with **multiple responders**; for incidents with one or no engaged users, this value is null.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mean_seconds_to_engage: Option<isize>,
    /// Mean time between the start of an incident, and the first responder to acknowledge.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mean_seconds_to_first_ack: Option<isize>,
    /// Mean time between the start of an incident, and the last additional responder to acknowledge. For incidents with one or no engaged users, this value is null.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mean_seconds_to_mobilize: Option<isize>,
    /// Mean time from when an incident was triggered until it was resolved.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mean_seconds_to_resolve: Option<isize>,
    /// ID of the service. Only included when aggregating by service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_id: Option<String>,
    /// Name of the service. Only included when aggregating by service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_name: Option<String>,
    /// ID of the team the incident was assigned to.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team_id: Option<String>,
    /// Name of the team the incident was assigned to.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team_name: Option<String>,
    /// Total number of unique interruptions during business hours. Business hour: 8am-6pm Mon-Fri, based on the user’s time zone. 
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_business_hour_interruptions: Option<isize>,
    /// Total engaged time across all responders for incidents. Engaged time is measured from the time a user engages with an incident (by acknowledging or accepting a responder request) until the incident is resolved. This may include periods in which the incidents was snoozed.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_engaged_seconds: Option<isize>,
    /// Total count of instances where an incident is escalated between responders assigned to an escalation policy.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_escalation_count: Option<isize>,
    /// The total number of incidents that were created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_incident_count: Option<isize>,
    /// Total number of unique interruptions during off hours. Off hour: 6pm-10pm Mon-Fri and all day Sat-Sun, based on the user’s time zone.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_off_hour_interruptions: Option<isize>,
    /// Total number of unique interruptions during sleep hours. Sleep hour: 10pm-8am every day, based on the user’s time zone.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_sleep_hour_interruptions: Option<isize>,
    /// Total number of seconds incidents were snoozed.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_snoozed_seconds: Option<isize>,
    /// The percentage of time in the defined date range that the service was not interrupted by a [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_time_pct: Option<f64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct GetAnalyticsMetricsIncidentsTeam {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filters: Option<AnalyticsModelFilters>,
    /// The time zone to use for the results and grouping.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_zone: Option<String>,
    /// The time unit to aggregate metrics by.  If no value is provided, the metrics will be aggregated for the entire period.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aggregate_unit: Option<GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum {
    #[serde(rename = "day")]
    DAY,
    #[serde(rename = "week")]
    WEEK,
    #[serde(rename = "month")]
    MONTH,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::DAY => write!(f, "day"),
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::WEEK => write!(f, "week"),
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::MONTH => write!(f, "month"),
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "day" => Ok(GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::DAY),
            "week" => Ok(GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::WEEK),
            "month" => Ok(GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::MONTH),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum {
    fn as_ref(&self) -> &str {
        match self {
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::DAY => "day",
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::WEEK => "week",
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::MONTH => "month",
            GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum {
    fn default() -> Self {
        GetAnalyticsMetricsIncidentsTeamAggregateUnitEnum::DAY
    }
}

/// Accepts a set of filters to apply to the Incidents before aggregating.  Any incidents that do not match the included filters will be omitted from the results
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AnalyticsModelFilters {
    /// Accepts an ISO8601 DateTime string.  Any incidents with a created_at less than this value will be omitted from the results.  The maximum supported time range in conjunction with created_at_end is one year.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at_start: Option<String>,
    /// Accepts an ISO8601 DateTime string.  Any incidents with a created_at greater than or equal to this value will be omitted from the results.  The maximum supported time range in conjunction with created_at_start is one year.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at_end: Option<String>,
    /// Any incidents whose urgency does not match the provided string will be omitted from the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub urgency: Option<AnalyticsModelFiltersUrgencyEnum>,
    /// A boolean flag including whether results should contain *only* [major incidents](https://support.pagerduty.com/docs/operational-reviews#major-incidents), or exclude major incidents. If no value is provided all incidents will be included.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub major: Option<bool>,
    /// An array of team IDs. Only incidents related to these teams will be included in the results. If omitted, all teams the requestor has access to will be included in the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team_ids: Option<Vec<String>>,
    /// An array of service IDs. Only incidents related to these services will be included in the results. If omitted, all services the requestor has access to will be included in the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_ids: Option<Vec<String>>,
    /// An array of priority IDs. Only incidents with these priorities will be included in the results. If omitted, all services the requestor has access to will be included in the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority_ids: Option<Vec<String>>,
    /// An array of user-defined priority names. Only incidents with these priorities will be included in the results. If omitted, all services the requestor has access to will be included in the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority_names: Option<Vec<String>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AnalyticsModelFiltersUrgencyEnum {
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AnalyticsModelFiltersUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AnalyticsModelFiltersUrgencyEnum::HIGH => write!(f, "high"),
            AnalyticsModelFiltersUrgencyEnum::LOW => write!(f, "low"),
            AnalyticsModelFiltersUrgencyEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AnalyticsModelFiltersUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "high" => Ok(AnalyticsModelFiltersUrgencyEnum::HIGH),
            "low" => Ok(AnalyticsModelFiltersUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AnalyticsModelFiltersUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self {
            AnalyticsModelFiltersUrgencyEnum::HIGH => "high",
            AnalyticsModelFiltersUrgencyEnum::LOW => "low",
            AnalyticsModelFiltersUrgencyEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AnalyticsModelFiltersUrgencyEnum {
    fn default() -> Self {
        AnalyticsModelFiltersUrgencyEnum::HIGH
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AnalyticsRawIncident {
    /// Total count of instances where responders were assigned an incident (including through reassignment or escalation) or accepted a responder request.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assignment_count: Option<isize>,
    /// Total number of unique interruptions during business hour. Business hour: 8am-6pm Mon-Fri, based on the user’s time zone.  
    #[serde(skip_serializing_if = "Option::is_none")]
    pub business_hour_interruptions: Option<isize>,
    /// Timestamp of when the incident was created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    /// The incident description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Total engaged time across all responders for this incident.  Engaged time is measured from the time a user engages with an incident (by acknowledging or accepting a responder request) until the incident is resolved.  This may include periods in which the incident was snoozed.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub engaged_seconds: Option<isize>,
    /// Total number of users who engaged (acknowledged, accepted responder request) in the incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub engaged_user_count: Option<isize>,
    /// Total count of instances where an incident is escalated between responders assigned to an escalation policy.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub escalation_count: Option<isize>,
    /// Incident ID
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The PagerDuty incident number
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident_number: Option<isize>,
    /// An incident is classified as a [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents) if it has one of the two highest priorities, or if multiple responders are added and acknowledge the incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub major: Option<bool>,
    /// Total number of unique interruptions during off hour. Off hour: 6pm-10pm Mon-Fri and all day Sat-Sun, based on the user’s time zone.      
    #[serde(skip_serializing_if = "Option::is_none")]
    pub off_hour_interruptions: Option<isize>,
    /// ID of the incident's priority level.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority_id: Option<String>,
    /// The user-provided short name of the priority.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority_name: Option<String>,
    /// Timestamp of when the incident was resolved.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolved_at: Option<String>,
    /// Time between start of an incident, and the first responder to acknowledge, or to accept responder request.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub seconds_to_engage: Option<isize>,
    /// Time between start of an incident, and the first responder to acknowledge.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub seconds_to_first_ack: Option<isize>,
    /// Time between start of an incident, and the last additional responder to acknowledge.  If an incident has one or less responders, the value will be null.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub seconds_to_mobilize: Option<isize>,
    /// Time from when incident triggered until it was resolved.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub seconds_to_resolve: Option<isize>,
    /// ID of the service that the incident triggered on.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_id: Option<String>,
    /// Name of the service that the incident triggered on.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_name: Option<String>,
    /// Total number of unique interruptions during sleep hour. Sleep hour: 10pm-8am every day, based on the user’s time zone.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sleep_hour_interruptions: Option<isize>,
    /// Total seconds the incident has been snoozed for.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub snoozed_seconds: Option<isize>,
    /// ID of the team the incident was assigned to.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team_id: Option<String>,
    /// Name of the team the incident was assigned to.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team_name: Option<String>,
    /// Notification level
    #[serde(skip_serializing_if = "Option::is_none")]
    pub urgency: Option<String>,
    /// The total response effort in seconds, [as defined by the user](https://support.pagerduty.com/docs/editing-incidents#edit-incident-duration).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_defined_effort_seconds: Option<isize>,
}

/// Filters the result, only show incidents that match the conditions passed in the filter.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AnalyticsrawincidentsFilters {
    /// Filters the result, showing only the incidents where the creation timestamp is greater than the filter value.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at_start: Option<String>,
    /// Filters the result, showing only the incidents where the creation timestamp is less than the filter value.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at_end: Option<String>,
    /// Filters the result, showing only the incidents where urgency matches the filter value.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub urgency: Option<String>,
    /// An incident is classified as a [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents) if it has one of the two highest priorities, or if multiple responders are added and acknowledge the incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub major: Option<bool>,
    /// An array of team IDs. Only results related to these teams will be returned. Account must have the teams ability to use this parameter.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team_ids: Option<Vec<String>>,
    /// An array of service IDs. Only results related to these services will be returned.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_ids: Option<Vec<String>>,
    /// The priority_ids filter applied to the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority_ids: Option<Vec<String>>,
    /// The priority_names filter applied to the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority_names: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AssignLogEntry {
    #[serde(rename = "type")]
    pub _type: AssignLogEntryTypeEnum,
    /// Time at which the log entry was created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel: Option<Channel>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent: Option<AgentReference>,
    /// Optional field containing a note, if one was included with the log entry.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub note: Option<String>,
    /// Contexts to be included with the trigger such as links to graphs or images.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contexts: Option<Vec<Context>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service: Option<ServiceReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<UserReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<IncidentReference>,
    /// Will consist of references unless included
    #[serde(skip_serializing_if = "Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_details: Option<LogEntryEventDetails>,
    /// An array of assigned Users for this log entry
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assignees: Option<Vec<UserReference>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AssignLogEntryTypeEnum {
    #[serde(rename = "assign_log_entry")]
    ASSIGN_LOG_ENTRY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for AssignLogEntryTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            AssignLogEntryTypeEnum::ASSIGN_LOG_ENTRY => write!(f, "assign_log_entry"),
            AssignLogEntryTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for AssignLogEntryTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "assign_log_entry" => Ok(AssignLogEntryTypeEnum::ASSIGN_LOG_ENTRY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for AssignLogEntryTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            AssignLogEntryTypeEnum::ASSIGN_LOG_ENTRY => "assign_log_entry",
            AssignLogEntryTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for AssignLogEntryTypeEnum {
    fn default() -> Self {
        AssignLogEntryTypeEnum::ASSIGN_LOG_ENTRY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Assignment {
    /// Time at which the assignment was created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub at: Option<chrono::DateTime<chrono::Utc>>,
    pub assignee: UserReference,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AuditMetadata {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub messages: Option<Vec<String>>,
}

/// An Audit Trail record
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AuditRecord {
    #[serde(skip_serializing_if = "String::is_empty")]
    pub id: String,
    /// Record URL.
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// The date/time the action executed, in ISO8601 format and millisecond precision.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_time: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_context: Option<AuditRecordExecutionContext>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actors: Option<Vec<Reference>>,
    pub method: AuditRecordMethod,
    pub root_resource: Reference,
    #[serde(skip_serializing_if = "String::is_empty")]
    pub action: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<AuditRecordDetails>,
}

/// Additional details to provide further information about the action or the resource that has been audited. 
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AuditRecordDetails {
    pub resource: Reference,
    /// A set of fields that have been affected. The fields that have not been affected MAY be returned. 
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<AuditRecordDetailsFields>>,
    /// A set of references that have been affected.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub references: Option<Vec<AuditRecordDetailsReferences>>,
}

/// Information about the affected field. When available, field's before and after values are returned:    #### Resource creation - `value` MAY be returned  #### Resource update - `value` MAY be returned - `before_value` MAY be returned  #### Resource deletion - `before_value` MAY be returned 
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AuditRecordDetailsFields {
    /// Name of the resource field
    #[serde(skip_serializing_if = "String::is_empty")]
    pub name: String,
    /// Human readable description of the resource field
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// new or updated value of the field
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// previous or deleted value of the field
    #[serde(skip_serializing_if = "Option::is_none")]
    pub before_value: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AuditRecordDetailsReferences {
    /// Name of the reference field
    #[serde(skip_serializing_if = "String::is_empty")]
    pub name: String,
    /// Human readable description of the references field
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub added: Option<Vec<Reference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub removed: Option<Vec<Reference>>,
}

/// Action execution context
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AuditRecordExecutionContext {
    /// Request Id
    #[serde(skip_serializing_if = "Option::is_none")]
    pub request_id: Option<String>,
    /// remote address
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remote_address: Option<String>,
}

/// The method information
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AuditRecordMethod {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Truncated token containing the last 4 chars of the token's actual value.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truncated_token: Option<String>,
    #[serde(rename = "type")]
    #[serde(default = "AuditRecordMethod::_type_default")]
    pub _type: String,
}

#[allow(clippy::derivable_impls)]
impl Default for AuditRecordMethod {
    fn default() -> Self {
        Self {
            description: Default::default(),
            truncated_token: Default::default(),
            _type: String::from("audit_record_method"),
        }
    }
}

impl AuditRecordMethod {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("audit_record_method")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AuditRecordResponseSchema {
    /// The minimum of the `limit` parameter used in the request or the maximum request size of the API.
    pub limit: isize,
    /// An opaque string than will deliver the next set of results when provided as the `cursor` parameter in a subsequent request.  A `null` value for this field indicates that there are no additional results. 
    #[serde(skip_serializing_if = "String::is_empty")]
    pub next_cursor: String,
}

/// Defines how alerts on this service are automatically suspended for a period of time before triggering, when identified as likely being transient. Note that automatically pausing notifications is only available on certain plans.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AutoPauseNotificationsParameters {
    /// Indicates whether alerts should be automatically suspended when identified as transient
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// Indicates in seconds how long alerts should be suspended before triggering
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<isize>,
}

/// A JSON object containing data describing the alert.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Body {
    /// The type of the body.
    #[serde(rename = "type")]
    pub _type: BodyTypeEnum,
    /// Contexts to be included with the body such as links to graphs or images.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contexts: Option<Vec<Context>>,
    /// An arbitrary JSON object or string containing any data explaining the nature of the alert.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<HashMap<String, Value>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum BodyTypeEnum {
    #[serde(rename = "alert_body")]
    ALERT_BODY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for BodyTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            BodyTypeEnum::ALERT_BODY => write!(f, "alert_body"),
            BodyTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for BodyTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "alert_body" => Ok(BodyTypeEnum::ALERT_BODY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for BodyTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            BodyTypeEnum::ALERT_BODY => "alert_body",
            BodyTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for BodyTypeEnum {
    fn default() -> Self {
        BodyTypeEnum::ALERT_BODY
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct BusinessService {
    /// The label of the tag.
    #[serde(default = "BusinessService::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default = "BusinessService::_type_default")]
    pub _type: String,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The name of the business service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The user-provided description of the business service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The point of contact assigned to this service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub point_of_contact: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team: Option<Team3>,
}

#[allow(clippy::derivable_impls)]
impl Default for BusinessService {
    fn default() -> Self {
        Self {
            label: String::from("BusinessService"),
            html_url: Default::default(),
            _self: Default::default(),
            _type: String::from("business_service"),
            summary: Default::default(),
            id: Default::default(),
            name: Default::default(),
            description: Default::default(),
            point_of_contact: Default::default(),
            team: Default::default(),
        }
    }
}

impl BusinessService {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("BusinessService")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("business_service")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct PutIncidentManualBusinessServiceAssociation {
    pub relation: PutIncidentManualBusinessServiceAssociationRelationEnum,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum PutIncidentManualBusinessServiceAssociationRelationEnum {
    #[serde(rename = "impacted")]
    IMPACTED,
    #[serde(rename = "not_impacted")]
    NOT_IMPACTED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for PutIncidentManualBusinessServiceAssociationRelationEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            PutIncidentManualBusinessServiceAssociationRelationEnum::IMPACTED => write!(f, "impacted"),
            PutIncidentManualBusinessServiceAssociationRelationEnum::NOT_IMPACTED => write!(f, "not_impacted"),
            PutIncidentManualBusinessServiceAssociationRelationEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for PutIncidentManualBusinessServiceAssociationRelationEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "impacted" => Ok(PutIncidentManualBusinessServiceAssociationRelationEnum::IMPACTED),
            "not_impacted" => Ok(PutIncidentManualBusinessServiceAssociationRelationEnum::NOT_IMPACTED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for PutIncidentManualBusinessServiceAssociationRelationEnum {
    fn as_ref(&self) -> &str {
        match self {
            PutIncidentManualBusinessServiceAssociationRelationEnum::IMPACTED => "impacted",
            PutIncidentManualBusinessServiceAssociationRelationEnum::NOT_IMPACTED => "not_impacted",
            PutIncidentManualBusinessServiceAssociationRelationEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for PutIncidentManualBusinessServiceAssociationRelationEnum {
    fn default() -> Self {
        PutIncidentManualBusinessServiceAssociationRelationEnum::IMPACTED
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct BusinessServiceReference {
    /// The label of the tag.
    #[serde(default = "BusinessServiceReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: BusinessServiceReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for BusinessServiceReference {
    fn default() -> Self {
        Self {
            label: String::from("BusinessServiceReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl BusinessServiceReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("BusinessServiceReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("business_service_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum BusinessServiceReferenceTypeEnum {
    #[serde(rename = "business_service_reference")]
    BUSINESS_SERVICE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for BusinessServiceReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            BusinessServiceReferenceTypeEnum::BUSINESS_SERVICE_REFERENCE => write!(f, "business_service_reference"),
            BusinessServiceReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for BusinessServiceReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "business_service_reference" => Ok(BusinessServiceReferenceTypeEnum::BUSINESS_SERVICE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for BusinessServiceReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            BusinessServiceReferenceTypeEnum::BUSINESS_SERVICE_REFERENCE => "business_service_reference",
            BusinessServiceReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for BusinessServiceReferenceTypeEnum {
    fn default() -> Self {
        BusinessServiceReferenceTypeEnum::BUSINESS_SERVICE_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateBusinessService {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub business_service: Option<BusinessServicesBusinessService>,
}

/// The Business Service to be created
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct BusinessServicesBusinessService {
    /// The name of the Business Service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The description of the Business Service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The owner of the Business Service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub point_of_contact: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team: Option<Team1>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateBusinessService {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub business_service: Option<BusinessServicesidBusinessService>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct PutBusinessServicePriorityThresholds {
    pub global_threshold: BusinessServicespriorityThresholdsGlobalThreshold,
}

/// The Business Service to be created
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct BusinessServicesidBusinessService {
    /// The name of the Business Service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The description of the Business Service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The owner of the Business Service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub point_of_contact: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team: Option<Team2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct BusinessServicespriorityThresholdsGlobalThreshold {
    #[serde(skip_serializing_if = "String::is_empty")]
    pub id: String,
    pub order: f64,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ChangeEvent {
    /// The label of the tag.
    #[serde(default = "ChangeEvent::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The time at which the emitting tool detected or generated the event.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<chrono::DateTime<chrono::Utc>>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: ChangeEventTypeEnum,
    /// An array containing Service objects that this change event is associated with.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<ServiceReference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub integration: Option<Value>,
    /// This is the 32 character Integration Key for an Integration on a Service. The same Integration Key can be used for both alert and change events.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_key: Option<String>,
    /// A brief text summary of the event. Displayed in PagerDuty to provide information about the change. The maximum permitted length of this property is 1024 characters.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    /// The unique name of the location where the Change Event occurred.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    /// List of links to include.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub links: Option<Vec<ChangeEventLinks>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Vec<ChangeEventImages>>,
    /// Additional details about the change event.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custom_details: Option<HashMap<String, Value>>,
}

#[allow(clippy::derivable_impls)]
impl Default for ChangeEvent {
    fn default() -> Self {
        Self {
            label: String::from("ChangeEvent"),
            html_url: Default::default(),
            _self: Default::default(),
            id: Default::default(),
            timestamp: Default::default(),
            _type: Default::default(),
            services: Default::default(),
            integration: Default::default(),
            routing_key: Default::default(),
            summary: Default::default(),
            source: Default::default(),
            links: Default::default(),
            images: Default::default(),
            custom_details: Default::default(),
        }
    }
}

impl ChangeEvent {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("ChangeEvent")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("change_event")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ChangeEventTypeEnum {
    #[serde(rename = "change_event")]
    CHANGE_EVENT,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ChangeEventTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ChangeEventTypeEnum::CHANGE_EVENT => write!(f, "change_event"),
            ChangeEventTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ChangeEventTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "change_event" => Ok(ChangeEventTypeEnum::CHANGE_EVENT),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ChangeEventTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ChangeEventTypeEnum::CHANGE_EVENT => "change_event",
            ChangeEventTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ChangeEventTypeEnum {
    fn default() -> Self {
        ChangeEventTypeEnum::CHANGE_EVENT
    }
}
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ChangeEventIntegration {
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ChangeEventImages {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub src: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub href: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alt: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ChangeEventLinks {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub href: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateChangeEvent {
    pub change_event: ChangeEvent,
}

/// Polymorphic object representation of the means by which the action was channeled. Has different formats depending on type, indicated by channel[type]. Will be one of `auto`, `email`, `api`, `nagios`, or `timeout` if `agent[type]` is `service`. Will be one of `email`, `sms`, `website`, `web_trigger`, or `note` if `agent[type]` is `user`. See [below](https://developer.pagerduty.com/documentation/rest/log_entries/show#channel_types) for detailed information about channel formats.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Channel {
    /// type
    #[serde(rename = "type")]
    #[serde(default = "Channel::_type_default")]
    pub _type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notification: Option<Notification>,
    /// channel
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel: Option<HashMap<String, Value>>,
}

#[allow(clippy::derivable_impls)]
impl Default for Channel {
    fn default() -> Self {
        Self {
            _type: String::from("channel"),
            user: Default::default(),
            team: Default::default(),
            notification: Default::default(),
            channel: Default::default(),
        }
    }
}

impl Channel {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("channel")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ConferenceBridge {
    /// The phone number of the conference call for the conference bridge. Phone numbers should be formatted like +1 415-555-1212,,,,1234#, where a comma (,) represents a one-second wait and pound (#) completes access code input.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conference_number: Option<String>,
    /// An URL for the conference bridge. This could be a link to a web conference or Slack channel.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conference_url: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ContactMethod {
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of contact method being created.
    #[serde(rename = "type")]
    pub _type: ContactMethodTypeEnum,
    /// The label (e.g., \"Work\", \"Mobile\", etc.).
    #[serde(default = "ContactMethod::label_default")]
    pub label: String,
    /// The \"address\" to deliver to: email, phone number, etc., depending on the type.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub address: String,
}

#[allow(clippy::derivable_impls)]
impl Default for ContactMethod {
    fn default() -> Self {
        Self {
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            label: String::from("ContactMethod"),
            address: Default::default(),
        }
    }
}

impl ContactMethod {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("ContactMethod")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("contact_method")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ContactMethodTypeEnum {
    #[serde(rename = "email_contact_method")]
    EMAIL_CONTACT_METHOD,
    #[serde(rename = "phone_contact_method")]
    PHONE_CONTACT_METHOD,
    #[serde(rename = "push_notification_contact_method")]
    PUSH_NOTIFICATION_CONTACT_METHOD,
    #[serde(rename = "sms_contact_method")]
    SMS_CONTACT_METHOD,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ContactMethodTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ContactMethodTypeEnum::EMAIL_CONTACT_METHOD => write!(f, "email_contact_method"),
            ContactMethodTypeEnum::PHONE_CONTACT_METHOD => write!(f, "phone_contact_method"),
            ContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD => write!(f, "push_notification_contact_method"),
            ContactMethodTypeEnum::SMS_CONTACT_METHOD => write!(f, "sms_contact_method"),
            ContactMethodTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ContactMethodTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "email_contact_method" => Ok(ContactMethodTypeEnum::EMAIL_CONTACT_METHOD),
            "phone_contact_method" => Ok(ContactMethodTypeEnum::PHONE_CONTACT_METHOD),
            "push_notification_contact_method" => Ok(ContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD),
            "sms_contact_method" => Ok(ContactMethodTypeEnum::SMS_CONTACT_METHOD),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ContactMethodTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ContactMethodTypeEnum::EMAIL_CONTACT_METHOD => "email_contact_method",
            ContactMethodTypeEnum::PHONE_CONTACT_METHOD => "phone_contact_method",
            ContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD => "push_notification_contact_method",
            ContactMethodTypeEnum::SMS_CONTACT_METHOD => "sms_contact_method",
            ContactMethodTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ContactMethodTypeEnum {
    fn default() -> Self {
        ContactMethodTypeEnum::EMAIL_CONTACT_METHOD
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ContactMethodReference {
    /// The label of the tag.
    #[serde(default = "ContactMethodReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: ContactMethodReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for ContactMethodReference {
    fn default() -> Self {
        Self {
            label: String::from("ContactMethodReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl ContactMethodReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("ContactMethodReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("contact_method_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ContactMethodReferenceTypeEnum {
    #[serde(rename = "email_contact_method_reference")]
    EMAIL_CONTACT_METHOD_REFERENCE,
    #[serde(rename = "phone_contact_method_reference")]
    PHONE_CONTACT_METHOD_REFERENCE,
    #[serde(rename = "push_notification_contact_method_reference")]
    PUSH_NOTIFICATION_CONTACT_METHOD_REFERENCE,
    #[serde(rename = "sms_contact_method_reference")]
    SMS_CONTACT_METHOD_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ContactMethodReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ContactMethodReferenceTypeEnum::EMAIL_CONTACT_METHOD_REFERENCE => write!(f, "email_contact_method_reference"),
            ContactMethodReferenceTypeEnum::PHONE_CONTACT_METHOD_REFERENCE => write!(f, "phone_contact_method_reference"),
            ContactMethodReferenceTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD_REFERENCE => write!(f, "push_notification_contact_method_reference"),
            ContactMethodReferenceTypeEnum::SMS_CONTACT_METHOD_REFERENCE => write!(f, "sms_contact_method_reference"),
            ContactMethodReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ContactMethodReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "email_contact_method_reference" => Ok(ContactMethodReferenceTypeEnum::EMAIL_CONTACT_METHOD_REFERENCE),
            "phone_contact_method_reference" => Ok(ContactMethodReferenceTypeEnum::PHONE_CONTACT_METHOD_REFERENCE),
            "push_notification_contact_method_reference" => Ok(ContactMethodReferenceTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD_REFERENCE),
            "sms_contact_method_reference" => Ok(ContactMethodReferenceTypeEnum::SMS_CONTACT_METHOD_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ContactMethodReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ContactMethodReferenceTypeEnum::EMAIL_CONTACT_METHOD_REFERENCE => "email_contact_method_reference",
            ContactMethodReferenceTypeEnum::PHONE_CONTACT_METHOD_REFERENCE => "phone_contact_method_reference",
            ContactMethodReferenceTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD_REFERENCE => "push_notification_contact_method_reference",
            ContactMethodReferenceTypeEnum::SMS_CONTACT_METHOD_REFERENCE => "sms_contact_method_reference",
            ContactMethodReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ContactMethodReferenceTypeEnum {
    fn default() -> Self {
        ContactMethodReferenceTypeEnum::EMAIL_CONTACT_METHOD_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateUserContactMethod {
    pub contact_method: UpdateUserContactMethodContactMethodEnum,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserContactMethodContactMethodEnum {
    PHONE_CONTACT_METHOD(PhoneContactMethod),
    PUSH_CONTACT_METHOD(PushContactMethod),
    EMAIL_CONTACT_METHOD(EmailContactMethod),
}

impl Display for UpdateUserContactMethodContactMethodEnum {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            UpdateUserContactMethodContactMethodEnum::PHONE_CONTACT_METHOD(value) => write!(f, "{:?}", value),
            UpdateUserContactMethodContactMethodEnum::PUSH_CONTACT_METHOD(value) => write!(f, "{:?}", value),
            UpdateUserContactMethodContactMethodEnum::EMAIL_CONTACT_METHOD(value) => write!(f, "{:?}", value),
        }
    }
}

impl std::default::Default for UpdateUserContactMethodContactMethodEnum {
    fn default() -> Self {
        UpdateUserContactMethodContactMethodEnum::PHONE_CONTACT_METHOD(PhoneContactMethod::default())
    }
}

/// The configuration for Content Based Alert Grouping
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ContentBasedAlertGroupingConfiguration {
    /// Whether Alerts should be grouped if `all` or `any` specified fields match. If `all` is selected, an exact match on every specified field name must occur for Alerts to be grouped. If `any` is selected, Alerts will be grouped when there is an exact match on at least one of the specified fields.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aggregate: Option<ContentBasedAlertGroupingConfigurationAggregateEnum>,
    /// The fields with which to group against. Depending on the aggregate, Alerts will group if some or all the fields match
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<Value>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ContentBasedAlertGroupingConfigurationAggregateEnum {
    #[serde(rename = "all, any")]
    ALL_ANY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ContentBasedAlertGroupingConfigurationAggregateEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ContentBasedAlertGroupingConfigurationAggregateEnum::ALL_ANY => write!(f, "all, any"),
            ContentBasedAlertGroupingConfigurationAggregateEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ContentBasedAlertGroupingConfigurationAggregateEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "all, any" => Ok(ContentBasedAlertGroupingConfigurationAggregateEnum::ALL_ANY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ContentBasedAlertGroupingConfigurationAggregateEnum {
    fn as_ref(&self) -> &str {
        match self {
            ContentBasedAlertGroupingConfigurationAggregateEnum::ALL_ANY => "all, any",
            ContentBasedAlertGroupingConfigurationAggregateEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ContentBasedAlertGroupingConfigurationAggregateEnum {
    fn default() -> Self {
        ContentBasedAlertGroupingConfigurationAggregateEnum::ALL_ANY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Context {
    /// The type of context being attached to the incident.
    #[serde(rename = "type")]
    pub _type: ContextTypeEnum,
    /// The link's target url
    #[serde(skip_serializing_if = "Option::is_none")]
    pub href: Option<String>,
    /// The image's source url
    #[serde(skip_serializing_if = "Option::is_none")]
    pub src: Option<String>,
    /// The alternate display for an image
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ContextTypeEnum {
    #[serde(rename = "link")]
    LINK,
    #[serde(rename = "image")]
    IMAGE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ContextTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ContextTypeEnum::LINK => write!(f, "link"),
            ContextTypeEnum::IMAGE => write!(f, "image"),
            ContextTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ContextTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "link" => Ok(ContextTypeEnum::LINK),
            "image" => Ok(ContextTypeEnum::IMAGE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ContextTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ContextTypeEnum::LINK => "link",
            ContextTypeEnum::IMAGE => "image",
            ContextTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ContextTypeEnum {
    fn default() -> Self {
        ContextTypeEnum::LINK
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CursorPagination {
    /// The minimum of the `limit` parameter used in the request or the maximum request size of the API.
    pub limit: isize,
    /// An opaque string than will deliver the next set of results when provided as the `cursor` parameter in a subsequent request.  A `null` value for this field indicates that there are no additional results. 
    #[serde(skip_serializing_if = "String::is_empty")]
    pub next_cursor: String,
}

/// The Email Contact Method of the User.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EmailContactMethod {
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: EmailContactMethodTypeEnum,
    /// The label (e.g., \"Work\", \"Mobile\", etc.).
    #[serde(default = "EmailContactMethod::label_default")]
    pub label: String,
    /// The \"address\" to deliver to: email, phone number, etc., depending on the type.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub address: String,
    /// Send an abbreviated email message instead of the standard email output. Useful for email-to-SMS gateways and email based pagers.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub send_short_email: Option<bool>,
}

#[allow(clippy::derivable_impls)]
impl Default for EmailContactMethod {
    fn default() -> Self {
        Self {
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            label: String::from("EmailContactMethod"),
            address: Default::default(),
            send_short_email: Default::default(),
        }
    }
}

impl EmailContactMethod {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("EmailContactMethod")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("email_contact_method")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EmailContactMethodTypeEnum {
    #[serde(rename = "email_contact_method")]
    EMAIL_CONTACT_METHOD,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EmailContactMethodTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EmailContactMethodTypeEnum::EMAIL_CONTACT_METHOD => write!(f, "email_contact_method"),
            EmailContactMethodTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EmailContactMethodTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "email_contact_method" => Ok(EmailContactMethodTypeEnum::EMAIL_CONTACT_METHOD),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EmailContactMethodTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            EmailContactMethodTypeEnum::EMAIL_CONTACT_METHOD => "email_contact_method",
            EmailContactMethodTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EmailContactMethodTypeEnum {
    fn default() -> Self {
        EmailContactMethodTypeEnum::EMAIL_CONTACT_METHOD
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EmailParser {
    pub action: EmailParserActionEnum,
    pub match_predicate: MatchPredicate,
    /// Additional values that will be pulled in to the Incident object. Exactly one value extractor must have a `value_name` of `incident_key`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value_extractors: Option<Vec<EmailParserValueExtractors>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EmailParserActionEnum {
    #[serde(rename = "trigger")]
    TRIGGER,
    #[serde(rename = "resolve")]
    RESOLVE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EmailParserActionEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EmailParserActionEnum::TRIGGER => write!(f, "trigger"),
            EmailParserActionEnum::RESOLVE => write!(f, "resolve"),
            EmailParserActionEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EmailParserActionEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "trigger" => Ok(EmailParserActionEnum::TRIGGER),
            "resolve" => Ok(EmailParserActionEnum::RESOLVE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EmailParserActionEnum {
    fn as_ref(&self) -> &str {
        match self {
            EmailParserActionEnum::TRIGGER => "trigger",
            EmailParserActionEnum::RESOLVE => "resolve",
            EmailParserActionEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EmailParserActionEnum {
    fn default() -> Self {
        EmailParserActionEnum::TRIGGER
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EmailParserValueExtractors {
    #[serde(rename = "type")]
    pub _type: EmailParserValueExtractorsTypeEnum,
    pub part: EmailParserValueExtractorsPartEnum,
    /// The field name to set in the Incident object. Exactly one must use the `value_name` of `incident_key`
    #[serde(skip_serializing_if = "String::is_empty")]
    pub value_name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub starts_after: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ends_with: Option<String>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EmailParserValueExtractorsTypeEnum {
    #[serde(rename = "entire")]
    ENTIRE,
    #[serde(rename = "regex")]
    REGEX,
    #[serde(rename = "between")]
    BETWEEN,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EmailParserValueExtractorsTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EmailParserValueExtractorsTypeEnum::ENTIRE => write!(f, "entire"),
            EmailParserValueExtractorsTypeEnum::REGEX => write!(f, "regex"),
            EmailParserValueExtractorsTypeEnum::BETWEEN => write!(f, "between"),
            EmailParserValueExtractorsTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EmailParserValueExtractorsTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "entire" => Ok(EmailParserValueExtractorsTypeEnum::ENTIRE),
            "regex" => Ok(EmailParserValueExtractorsTypeEnum::REGEX),
            "between" => Ok(EmailParserValueExtractorsTypeEnum::BETWEEN),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EmailParserValueExtractorsTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            EmailParserValueExtractorsTypeEnum::ENTIRE => "entire",
            EmailParserValueExtractorsTypeEnum::REGEX => "regex",
            EmailParserValueExtractorsTypeEnum::BETWEEN => "between",
            EmailParserValueExtractorsTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EmailParserValueExtractorsTypeEnum {
    fn default() -> Self {
        EmailParserValueExtractorsTypeEnum::ENTIRE
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EmailParserValueExtractorsPartEnum {
    #[serde(rename = "body")]
    BODY,
    #[serde(rename = "subject")]
    SUBJECT,
    #[serde(rename = "from_addresses")]
    FROM_ADDRESSES,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EmailParserValueExtractorsPartEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EmailParserValueExtractorsPartEnum::BODY => write!(f, "body"),
            EmailParserValueExtractorsPartEnum::SUBJECT => write!(f, "subject"),
            EmailParserValueExtractorsPartEnum::FROM_ADDRESSES => write!(f, "from_addresses"),
            EmailParserValueExtractorsPartEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EmailParserValueExtractorsPartEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "body" => Ok(EmailParserValueExtractorsPartEnum::BODY),
            "subject" => Ok(EmailParserValueExtractorsPartEnum::SUBJECT),
            "from_addresses" => Ok(EmailParserValueExtractorsPartEnum::FROM_ADDRESSES),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EmailParserValueExtractorsPartEnum {
    fn as_ref(&self) -> &str {
        match self {
            EmailParserValueExtractorsPartEnum::BODY => "body",
            EmailParserValueExtractorsPartEnum::SUBJECT => "subject",
            EmailParserValueExtractorsPartEnum::FROM_ADDRESSES => "from_addresses",
            EmailParserValueExtractorsPartEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EmailParserValueExtractorsPartEnum {
    fn default() -> Self {
        EmailParserValueExtractorsPartEnum::BODY
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EntityReference {
    /// The label of the tag.
    #[serde(default = "EntityReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: EntityReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for EntityReference {
    fn default() -> Self {
        Self {
            label: String::from("EntityReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl EntityReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("EntityReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("entity_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EntityReferenceTypeEnum {
    #[serde(rename = "user_reference")]
    USER_REFERENCE,
    #[serde(rename = "team_reference")]
    TEAM_REFERENCE,
    #[serde(rename = "escalation_policy_reference")]
    ESCALATION_POLICY_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EntityReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EntityReferenceTypeEnum::USER_REFERENCE => write!(f, "user_reference"),
            EntityReferenceTypeEnum::TEAM_REFERENCE => write!(f, "team_reference"),
            EntityReferenceTypeEnum::ESCALATION_POLICY_REFERENCE => write!(f, "escalation_policy_reference"),
            EntityReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EntityReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "user_reference" => Ok(EntityReferenceTypeEnum::USER_REFERENCE),
            "team_reference" => Ok(EntityReferenceTypeEnum::TEAM_REFERENCE),
            "escalation_policy_reference" => Ok(EntityReferenceTypeEnum::ESCALATION_POLICY_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EntityReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            EntityReferenceTypeEnum::USER_REFERENCE => "user_reference",
            EntityReferenceTypeEnum::TEAM_REFERENCE => "team_reference",
            EntityReferenceTypeEnum::ESCALATION_POLICY_REFERENCE => "escalation_policy_reference",
            EntityReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EntityReferenceTypeEnum {
    fn default() -> Self {
        EntityReferenceTypeEnum::USER_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EscalateLogEntry {
    #[serde(rename = "type")]
    pub _type: EscalateLogEntryTypeEnum,
    /// Time at which the log entry was created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel: Option<Channel>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent: Option<AgentReference>,
    /// Optional field containing a note, if one was included with the log entry.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub note: Option<String>,
    /// Contexts to be included with the trigger such as links to graphs or images.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contexts: Option<Vec<Context>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service: Option<ServiceReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<UserReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<IncidentReference>,
    /// Will consist of references unless included
    #[serde(skip_serializing_if = "Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_details: Option<LogEntryEventDetails>,
    /// An array of assigned Users for this log entry
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assignees: Option<Vec<UserReference>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EscalateLogEntryTypeEnum {
    #[serde(rename = "escalate_log_entry")]
    ESCALATE_LOG_ENTRY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EscalateLogEntryTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EscalateLogEntryTypeEnum::ESCALATE_LOG_ENTRY => write!(f, "escalate_log_entry"),
            EscalateLogEntryTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EscalateLogEntryTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "escalate_log_entry" => Ok(EscalateLogEntryTypeEnum::ESCALATE_LOG_ENTRY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EscalateLogEntryTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            EscalateLogEntryTypeEnum::ESCALATE_LOG_ENTRY => "escalate_log_entry",
            EscalateLogEntryTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EscalateLogEntryTypeEnum {
    fn default() -> Self {
        EscalateLogEntryTypeEnum::ESCALATE_LOG_ENTRY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateEscalationPolicy {
    pub escalation_policy: EscalationPolicy,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateEscalationPolicy {
    pub escalation_policy: EscalationPolicy,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EscalationPolicy {
    /// The label of the tag.
    #[serde(default = "EscalationPolicy::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: EscalationPolicyTypeEnum,
    /// The name of the escalation policy.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub name: String,
    /// Escalation policy description.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The number of times the escalation policy will repeat after reaching the end of its escalation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub num_loops: Option<usize>,
    /// Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to \"if_has_services\".
    #[serde(skip_serializing_if = "Option::is_none")]
    pub on_call_handoff_notifications: Option<EscalationPolicyOnCallHandoffNotificationsEnum>,
    pub escalation_rules: Vec<EscalationRule>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<ServiceReference>>,
    /// Teams associated with the policy. Account must have the `teams` ability to use this parameter.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
}

#[allow(clippy::derivable_impls)]
impl Default for EscalationPolicy {
    fn default() -> Self {
        Self {
            label: String::from("EscalationPolicy"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            name: Default::default(),
            description: Default::default(),
            num_loops: Default::default(),
            on_call_handoff_notifications: Default::default(),
            escalation_rules: Default::default(),
            services: Default::default(),
            teams: Default::default(),
        }
    }
}

impl EscalationPolicy {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("EscalationPolicy")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("escalation_policy")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EscalationPolicyTypeEnum {
    #[serde(rename = "escalation_policy")]
    ESCALATION_POLICY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EscalationPolicyTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EscalationPolicyTypeEnum::ESCALATION_POLICY => write!(f, "escalation_policy"),
            EscalationPolicyTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EscalationPolicyTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "escalation_policy" => Ok(EscalationPolicyTypeEnum::ESCALATION_POLICY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EscalationPolicyTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            EscalationPolicyTypeEnum::ESCALATION_POLICY => "escalation_policy",
            EscalationPolicyTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EscalationPolicyTypeEnum {
    fn default() -> Self {
        EscalationPolicyTypeEnum::ESCALATION_POLICY
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EscalationPolicyOnCallHandoffNotificationsEnum {
    #[serde(rename = "if_has_services")]
    IF_HAS_SERVICES,
    #[serde(rename = "always")]
    ALWAYS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EscalationPolicyOnCallHandoffNotificationsEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EscalationPolicyOnCallHandoffNotificationsEnum::IF_HAS_SERVICES => write!(f, "if_has_services"),
            EscalationPolicyOnCallHandoffNotificationsEnum::ALWAYS => write!(f, "always"),
            EscalationPolicyOnCallHandoffNotificationsEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EscalationPolicyOnCallHandoffNotificationsEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "if_has_services" => Ok(EscalationPolicyOnCallHandoffNotificationsEnum::IF_HAS_SERVICES),
            "always" => Ok(EscalationPolicyOnCallHandoffNotificationsEnum::ALWAYS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EscalationPolicyOnCallHandoffNotificationsEnum {
    fn as_ref(&self) -> &str {
        match self {
            EscalationPolicyOnCallHandoffNotificationsEnum::IF_HAS_SERVICES => "if_has_services",
            EscalationPolicyOnCallHandoffNotificationsEnum::ALWAYS => "always",
            EscalationPolicyOnCallHandoffNotificationsEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EscalationPolicyOnCallHandoffNotificationsEnum {
    fn default() -> Self {
        EscalationPolicyOnCallHandoffNotificationsEnum::IF_HAS_SERVICES
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EscalationPolicyReference {
    /// The label of the tag.
    #[serde(default = "EscalationPolicyReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: EscalationPolicyReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for EscalationPolicyReference {
    fn default() -> Self {
        Self {
            label: String::from("EscalationPolicyReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl EscalationPolicyReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("EscalationPolicyReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("escalation_policy_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EscalationPolicyReferenceTypeEnum {
    #[serde(rename = "escalation_policy_reference")]
    ESCALATION_POLICY_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EscalationPolicyReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EscalationPolicyReferenceTypeEnum::ESCALATION_POLICY_REFERENCE => write!(f, "escalation_policy_reference"),
            EscalationPolicyReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EscalationPolicyReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "escalation_policy_reference" => Ok(EscalationPolicyReferenceTypeEnum::ESCALATION_POLICY_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EscalationPolicyReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            EscalationPolicyReferenceTypeEnum::ESCALATION_POLICY_REFERENCE => "escalation_policy_reference",
            EscalationPolicyReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EscalationPolicyReferenceTypeEnum {
    fn default() -> Self {
        EscalationPolicyReferenceTypeEnum::ESCALATION_POLICY_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EscalationRule {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The number of minutes before an unacknowledged incident escalates away from this rule.
    pub escalation_delay_in_minutes: isize,
    /// The targets an incident should be assigned to upon reaching this rule.
    pub targets: Vec<EscalationTargetReference>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EscalationTargetReference {
    /// The label of the tag.
    #[serde(default = "EscalationTargetReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: EscalationTargetReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for EscalationTargetReference {
    fn default() -> Self {
        Self {
            label: String::from("EscalationTargetReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl EscalationTargetReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("EscalationTargetReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("escalation_target_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EscalationTargetReferenceTypeEnum {
    #[serde(rename = "user")]
    USER,
    #[serde(rename = "schedule")]
    SCHEDULE,
    #[serde(rename = "user_reference")]
    USER_REFERENCE,
    #[serde(rename = "schedule_reference")]
    SCHEDULE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EscalationTargetReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EscalationTargetReferenceTypeEnum::USER => write!(f, "user"),
            EscalationTargetReferenceTypeEnum::SCHEDULE => write!(f, "schedule"),
            EscalationTargetReferenceTypeEnum::USER_REFERENCE => write!(f, "user_reference"),
            EscalationTargetReferenceTypeEnum::SCHEDULE_REFERENCE => write!(f, "schedule_reference"),
            EscalationTargetReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EscalationTargetReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "user" => Ok(EscalationTargetReferenceTypeEnum::USER),
            "schedule" => Ok(EscalationTargetReferenceTypeEnum::SCHEDULE),
            "user_reference" => Ok(EscalationTargetReferenceTypeEnum::USER_REFERENCE),
            "schedule_reference" => Ok(EscalationTargetReferenceTypeEnum::SCHEDULE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EscalationTargetReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            EscalationTargetReferenceTypeEnum::USER => "user",
            EscalationTargetReferenceTypeEnum::SCHEDULE => "schedule",
            EscalationTargetReferenceTypeEnum::USER_REFERENCE => "user_reference",
            EscalationTargetReferenceTypeEnum::SCHEDULE_REFERENCE => "schedule_reference",
            EscalationTargetReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EscalationTargetReferenceTypeEnum {
    fn default() -> Self {
        EscalationTargetReferenceTypeEnum::USER
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateOrchestration {
    pub orchestration: Orchestration,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct PostOrchestration {
    pub orchestration: Orchestration,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRule {
    /// Position/index of the Event Rule in the Ruleset.  Starting from position 0 (the first rule), rules are evaluated one-by-one until a matching rule is found.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<isize>,
    /// Indicates whether the Event Rule is the last Event Rule of the Ruleset that serves as a catch-all. It has limited functionality compared to other rules and always matches.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub catch_all: Option<bool>,
    /// When an event matches this rule, the actions that will be taken to change the resulting alert and incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<Value>,
}
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleActions {
    /// Set the service ID of the target service for the resulting alert. You can find the service you want to route to by calling the services endpoint.
    #[serde(rename = "route")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub route: Option<HashMap<String, Value>>,
}

/// When an event matches this Event Rule, the actions that will be taken to change the resulting Alert and Incident.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleActionsCommon {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub annotate: Option<EventRuleActionsCommonAnnotate>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_action: Option<EventRuleActionsCommonEventAction>,
    /// Dynamically extract values to set and modify new and existing PD-CEF fields.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extractions: Option<Vec<EventRuleActionsCommonExtractionsItems>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<EventRuleActionsCommonPriority>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub severity: Option<EventRuleActionsCommonSeverity>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suppress: Option<EventRuleActionsCommonSuppress>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suspend: Option<EventRuleActionsCommonSuspend>,
}

#[allow(non_camel_case_types, clippy::derive_partial_eq_without_eq)]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventRuleActionsCommonExtractionsItems {
    ExtractionsItems0 { target: String, source: String, regex: String },
    ExtractionsItems1 { target: String, template: String },
}

impl Display for EventRuleActionsCommonExtractionsItems {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            EventRuleActionsCommonExtractionsItems::ExtractionsItems0 { target, source, regex } => write!(f, "ExtractionsItems0{{ {:?}, {:?}, {:?} }}", target, source, regex),
            EventRuleActionsCommonExtractionsItems::ExtractionsItems1 { target, template } => write!(f, "ExtractionsItems1{{ {:?}, {:?} }}", target, template),
        }
    }
}

impl std::default::Default for EventRuleActionsCommonExtractionsItems {
    fn default() -> Self {
        EventRuleActionsCommonExtractionsItems::ExtractionsItems0 { target: String::default(), source: String::default(), regex: String::default() }
    }
}

/// Set a note on the resulting incident.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleActionsCommonAnnotate {
    /// The content of the note.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub value: String,
}

/// Set whether the resulting alert status is trigger or resolve.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleActionsCommonEventAction {
    pub value: EventRuleActionsCommonEventActionValueEnum,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EventRuleActionsCommonEventActionValueEnum {
    #[serde(rename = "trigger")]
    TRIGGER,
    #[serde(rename = "resolve")]
    RESOLVE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EventRuleActionsCommonEventActionValueEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EventRuleActionsCommonEventActionValueEnum::TRIGGER => write!(f, "trigger"),
            EventRuleActionsCommonEventActionValueEnum::RESOLVE => write!(f, "resolve"),
            EventRuleActionsCommonEventActionValueEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EventRuleActionsCommonEventActionValueEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "trigger" => Ok(EventRuleActionsCommonEventActionValueEnum::TRIGGER),
            "resolve" => Ok(EventRuleActionsCommonEventActionValueEnum::RESOLVE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EventRuleActionsCommonEventActionValueEnum {
    fn as_ref(&self) -> &str {
        match self {
            EventRuleActionsCommonEventActionValueEnum::TRIGGER => "trigger",
            EventRuleActionsCommonEventActionValueEnum::RESOLVE => "resolve",
            EventRuleActionsCommonEventActionValueEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EventRuleActionsCommonEventActionValueEnum {
    fn default() -> Self {
        EventRuleActionsCommonEventActionValueEnum::TRIGGER
    }
}

/// Set the priority ID for the resulting incident. You can find the priority you want by calling the priorities endpoint.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleActionsCommonPriority {
    /// The priority ID.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub value: String,
}

/// Set the severity of the resulting alert.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleActionsCommonSeverity {
    pub value: EventRuleActionsCommonSeverityValueEnum,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EventRuleActionsCommonSeverityValueEnum {
    #[serde(rename = "info")]
    INFO,
    #[serde(rename = "warning")]
    WARNING,
    #[serde(rename = "error")]
    ERROR,
    #[serde(rename = "critical")]
    CRITICAL,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EventRuleActionsCommonSeverityValueEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EventRuleActionsCommonSeverityValueEnum::INFO => write!(f, "info"),
            EventRuleActionsCommonSeverityValueEnum::WARNING => write!(f, "warning"),
            EventRuleActionsCommonSeverityValueEnum::ERROR => write!(f, "error"),
            EventRuleActionsCommonSeverityValueEnum::CRITICAL => write!(f, "critical"),
            EventRuleActionsCommonSeverityValueEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EventRuleActionsCommonSeverityValueEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "info" => Ok(EventRuleActionsCommonSeverityValueEnum::INFO),
            "warning" => Ok(EventRuleActionsCommonSeverityValueEnum::WARNING),
            "error" => Ok(EventRuleActionsCommonSeverityValueEnum::ERROR),
            "critical" => Ok(EventRuleActionsCommonSeverityValueEnum::CRITICAL),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EventRuleActionsCommonSeverityValueEnum {
    fn as_ref(&self) -> &str {
        match self {
            EventRuleActionsCommonSeverityValueEnum::INFO => "info",
            EventRuleActionsCommonSeverityValueEnum::WARNING => "warning",
            EventRuleActionsCommonSeverityValueEnum::ERROR => "error",
            EventRuleActionsCommonSeverityValueEnum::CRITICAL => "critical",
            EventRuleActionsCommonSeverityValueEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EventRuleActionsCommonSeverityValueEnum {
    fn default() -> Self {
        EventRuleActionsCommonSeverityValueEnum::INFO
    }
}

/// Set whether the resulting alert is suppressed. Can optionally be used with a threshold where resulting alerts will be suppressed until the threshold is met in a window of time. If using a threshold the rule must also set a route action.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleActionsCommonSuppress {
    pub value: bool,
    /// The number of occurences needed during the window of time to trigger the theshold.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub threshold_value: Option<isize>,
    /// The time unit for the window of time.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub threshold_time_unit: Option<EventRuleActionsCommonSuppressThresholdTimeUnitEnum>,
    /// The amount of time units for the window of time.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub threshold_time_amount: Option<isize>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EventRuleActionsCommonSuppressThresholdTimeUnitEnum {
    #[serde(rename = "seconds")]
    SECONDS,
    #[serde(rename = "minutes")]
    MINUTES,
    #[serde(rename = "hours")]
    HOURS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EventRuleActionsCommonSuppressThresholdTimeUnitEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EventRuleActionsCommonSuppressThresholdTimeUnitEnum::SECONDS => write!(f, "seconds"),
            EventRuleActionsCommonSuppressThresholdTimeUnitEnum::MINUTES => write!(f, "minutes"),
            EventRuleActionsCommonSuppressThresholdTimeUnitEnum::HOURS => write!(f, "hours"),
            EventRuleActionsCommonSuppressThresholdTimeUnitEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EventRuleActionsCommonSuppressThresholdTimeUnitEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "seconds" => Ok(EventRuleActionsCommonSuppressThresholdTimeUnitEnum::SECONDS),
            "minutes" => Ok(EventRuleActionsCommonSuppressThresholdTimeUnitEnum::MINUTES),
            "hours" => Ok(EventRuleActionsCommonSuppressThresholdTimeUnitEnum::HOURS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EventRuleActionsCommonSuppressThresholdTimeUnitEnum {
    fn as_ref(&self) -> &str {
        match self {
            EventRuleActionsCommonSuppressThresholdTimeUnitEnum::SECONDS => "seconds",
            EventRuleActionsCommonSuppressThresholdTimeUnitEnum::MINUTES => "minutes",
            EventRuleActionsCommonSuppressThresholdTimeUnitEnum::HOURS => "hours",
            EventRuleActionsCommonSuppressThresholdTimeUnitEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EventRuleActionsCommonSuppressThresholdTimeUnitEnum {
    fn default() -> Self {
        EventRuleActionsCommonSuppressThresholdTimeUnitEnum::SECONDS
    }
}

/// Set the length of time to suspend the resulting alert before triggering. Rules with a suspend action must also set a route action, and cannot have a suppress with threshold action
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleActionsCommonSuspend {
    /// The amount of time to suspend the alert in seconds.
    pub value: isize,
}

/// Conditions evaluated to check if an event matches this Event Rule. Is always empty for the catch_all rule, though.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleConditions {
    /// Operator to combine sub-conditions.
    pub operator: EventRuleConditionsOperatorEnum,
    /// Array of sub-conditions.
    pub subconditions: Vec<EventRuleConditionsSubconditions>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EventRuleConditionsOperatorEnum {
    #[serde(rename = "and")]
    AND,
    #[serde(rename = "or")]
    OR,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EventRuleConditionsOperatorEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EventRuleConditionsOperatorEnum::AND => write!(f, "and"),
            EventRuleConditionsOperatorEnum::OR => write!(f, "or"),
            EventRuleConditionsOperatorEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EventRuleConditionsOperatorEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "and" => Ok(EventRuleConditionsOperatorEnum::AND),
            "or" => Ok(EventRuleConditionsOperatorEnum::OR),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EventRuleConditionsOperatorEnum {
    fn as_ref(&self) -> &str {
        match self {
            EventRuleConditionsOperatorEnum::AND => "and",
            EventRuleConditionsOperatorEnum::OR => "or",
            EventRuleConditionsOperatorEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EventRuleConditionsOperatorEnum {
    fn default() -> Self {
        EventRuleConditionsOperatorEnum::AND
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleConditionsParameters {
    /// Path to a field in an event, in dot-notation.  For Event Rules on a serivce, this will have to be a PD-CEF field.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub path: String,
    /// Value to apply to the operator.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub value: String,
    /// Options to configure the operator.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<HashMap<String, Value>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleConditionsSubconditions {
    /// The type of operator to apply.
    pub operator: EventRuleConditionsSubconditionsOperatorEnum,
    pub parameters: EventRuleConditionsParameters,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EventRuleConditionsSubconditionsOperatorEnum {
    #[serde(rename = "exists")]
    EXISTS,
    #[serde(rename = "nexists")]
    NEXISTS,
    #[serde(rename = "equals")]
    EQUALS,
    #[serde(rename = "nequals")]
    NEQUALS,
    #[serde(rename = "contains")]
    CONTAINS,
    #[serde(rename = "ncontains")]
    NCONTAINS,
    #[serde(rename = "matches")]
    MATCHES,
    #[serde(rename = "nmatches")]
    NMATCHES,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EventRuleConditionsSubconditionsOperatorEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EventRuleConditionsSubconditionsOperatorEnum::EXISTS => write!(f, "exists"),
            EventRuleConditionsSubconditionsOperatorEnum::NEXISTS => write!(f, "nexists"),
            EventRuleConditionsSubconditionsOperatorEnum::EQUALS => write!(f, "equals"),
            EventRuleConditionsSubconditionsOperatorEnum::NEQUALS => write!(f, "nequals"),
            EventRuleConditionsSubconditionsOperatorEnum::CONTAINS => write!(f, "contains"),
            EventRuleConditionsSubconditionsOperatorEnum::NCONTAINS => write!(f, "ncontains"),
            EventRuleConditionsSubconditionsOperatorEnum::MATCHES => write!(f, "matches"),
            EventRuleConditionsSubconditionsOperatorEnum::NMATCHES => write!(f, "nmatches"),
            EventRuleConditionsSubconditionsOperatorEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EventRuleConditionsSubconditionsOperatorEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "exists" => Ok(EventRuleConditionsSubconditionsOperatorEnum::EXISTS),
            "nexists" => Ok(EventRuleConditionsSubconditionsOperatorEnum::NEXISTS),
            "equals" => Ok(EventRuleConditionsSubconditionsOperatorEnum::EQUALS),
            "nequals" => Ok(EventRuleConditionsSubconditionsOperatorEnum::NEQUALS),
            "contains" => Ok(EventRuleConditionsSubconditionsOperatorEnum::CONTAINS),
            "ncontains" => Ok(EventRuleConditionsSubconditionsOperatorEnum::NCONTAINS),
            "matches" => Ok(EventRuleConditionsSubconditionsOperatorEnum::MATCHES),
            "nmatches" => Ok(EventRuleConditionsSubconditionsOperatorEnum::NMATCHES),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EventRuleConditionsSubconditionsOperatorEnum {
    fn as_ref(&self) -> &str {
        match self {
            EventRuleConditionsSubconditionsOperatorEnum::EXISTS => "exists",
            EventRuleConditionsSubconditionsOperatorEnum::NEXISTS => "nexists",
            EventRuleConditionsSubconditionsOperatorEnum::EQUALS => "equals",
            EventRuleConditionsSubconditionsOperatorEnum::NEQUALS => "nequals",
            EventRuleConditionsSubconditionsOperatorEnum::CONTAINS => "contains",
            EventRuleConditionsSubconditionsOperatorEnum::NCONTAINS => "ncontains",
            EventRuleConditionsSubconditionsOperatorEnum::MATCHES => "matches",
            EventRuleConditionsSubconditionsOperatorEnum::NMATCHES => "nmatches",
            EventRuleConditionsSubconditionsOperatorEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EventRuleConditionsSubconditionsOperatorEnum {
    fn default() -> Self {
        EventRuleConditionsSubconditionsOperatorEnum::EXISTS
    }
}

/// The parameters for performing the operation to populate the
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleParameters {
    /// The value for the operation. For example, an RE2 regular expression for regex-type variables.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub value: String,
    /// Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a PD-CEF field.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub path: String,
}

/// Time-based conditions for limiting when the rule is active.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleTimeFrame {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub active_between: Option<EventRuleTimeFrameActiveBetween>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_weekly: Option<EventRuleTimeFrameScheduledWeekly>,
}

/// A fixed window of time during which the rule is active.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleTimeFrameActiveBetween {
    /// The start time in milliseconds.
    pub start_time: isize,
    /// End time in milliseconds.
    pub end_time: isize,
}

/// A reccuring window of time based on the day of the week, during which the rule is active.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleTimeFrameScheduledWeekly {
    /// The amount of milliseconds into the day at which the window starts.
    pub start_time: isize,
    /// The duration of the window in milliseconds.
    pub duration: isize,
    /// The timezone.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub timezone: String,
    /// An array of day values. Ex [1, 3, 5] is Monday, Wednesday, Friday.
    pub weekdays: Vec<i32>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct EventRuleVariables {
    /// The type of operation to populate the variable.
    #[serde(rename = "type")]
    pub _type: EventRuleVariablesTypeEnum,
    /// The name of the variable.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub name: String,
    pub parameters: EventRuleParameters,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EventRuleVariablesTypeEnum {
    #[serde(rename = "regex")]
    REGEX,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for EventRuleVariablesTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            EventRuleVariablesTypeEnum::REGEX => write!(f, "regex"),
            EventRuleVariablesTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for EventRuleVariablesTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "regex" => Ok(EventRuleVariablesTypeEnum::REGEX),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for EventRuleVariablesTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            EventRuleVariablesTypeEnum::REGEX => "regex",
            EventRuleVariablesTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for EventRuleVariablesTypeEnum {
    fn default() -> Self {
        EventRuleVariablesTypeEnum::REGEX
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Extension {
    /// The label of the tag.
    #[serde(default = "Extension::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The name of the extension.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub name: String,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: ExtensionTypeEnum,
    /// The url of the extension.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint_url: Option<String>,
    /// The objects for which the extension applies
    pub extension_objects: Vec<ServiceReference>,
    pub extension_schema: ExtensionSchemaReference,
    /// Whether or not this extension is temporarily disabled; for example, a webhook extension that is repeatedly rejected by the server.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temporarily_disabled: Option<bool>,
    /// The object that contains extension configuration values depending on the extension schema specification.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub config: Option<HashMap<String, Value>>,
}

#[allow(clippy::derivable_impls)]
impl Default for Extension {
    fn default() -> Self {
        Self {
            label: String::from("Extension"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            name: Default::default(),
            _type: Default::default(),
            endpoint_url: Default::default(),
            extension_objects: Default::default(),
            extension_schema: Default::default(),
            temporarily_disabled: Default::default(),
            config: Default::default(),
        }
    }
}

impl Extension {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Extension")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("extension")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ExtensionTypeEnum {
    #[serde(rename = "extension")]
    EXTENSION,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ExtensionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ExtensionTypeEnum::EXTENSION => write!(f, "extension"),
            ExtensionTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ExtensionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "extension" => Ok(ExtensionTypeEnum::EXTENSION),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ExtensionTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ExtensionTypeEnum::EXTENSION => "extension",
            ExtensionTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ExtensionTypeEnum {
    fn default() -> Self {
        ExtensionTypeEnum::EXTENSION
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ExtensionReference {
    /// The label of the tag.
    #[serde(default = "ExtensionReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: ExtensionReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for ExtensionReference {
    fn default() -> Self {
        Self {
            label: String::from("ExtensionReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl ExtensionReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("ExtensionReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("extension_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ExtensionReferenceTypeEnum {
    #[serde(rename = "extension_reference")]
    EXTENSION_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ExtensionReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ExtensionReferenceTypeEnum::EXTENSION_REFERENCE => write!(f, "extension_reference"),
            ExtensionReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ExtensionReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "extension_reference" => Ok(ExtensionReferenceTypeEnum::EXTENSION_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ExtensionReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ExtensionReferenceTypeEnum::EXTENSION_REFERENCE => "extension_reference",
            ExtensionReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ExtensionReferenceTypeEnum {
    fn default() -> Self {
        ExtensionReferenceTypeEnum::EXTENSION_REFERENCE
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ExtensionSchema {
    /// A small logo, 18-by-18 pixels.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon_url: Option<String>,
    /// A large logo, 75 pixels high and no more than 300 pixels wide.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logo_url: Option<String>,
    /// Human friendly display label
    #[serde(default = "ExtensionSchema::label_default")]
    pub label: String,
    /// Machine friendly display label
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// The long description for the Extension
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// A link to the extension's support guide
    #[serde(skip_serializing_if = "Option::is_none")]
    pub guide_url: Option<String>,
    /// The types of PagerDuty incident events that will activate this Extension
    #[serde(skip_serializing_if = "Option::is_none")]
    pub send_types: Option<Vec<String>>,
    /// The url that the webhook payload will be sent to for this Extension.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for ExtensionSchema {
    fn default() -> Self {
        Self {
            icon_url: Default::default(),
            logo_url: Default::default(),
            label: String::from("ExtensionSchema"),
            key: Default::default(),
            description: Default::default(),
            guide_url: Default::default(),
            send_types: Default::default(),
            url: Default::default(),
        }
    }
}

impl ExtensionSchema {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("ExtensionSchema")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ExtensionSchemaReference {
    /// The label of the tag.
    #[serde(default = "ExtensionSchemaReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: ExtensionSchemaReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for ExtensionSchemaReference {
    fn default() -> Self {
        Self {
            label: String::from("ExtensionSchemaReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl ExtensionSchemaReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("ExtensionSchemaReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("extension_schema_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ExtensionSchemaReferenceTypeEnum {
    #[serde(rename = "extension_schema_reference")]
    EXTENSION_SCHEMA_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ExtensionSchemaReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ExtensionSchemaReferenceTypeEnum::EXTENSION_SCHEMA_REFERENCE => write!(f, "extension_schema_reference"),
            ExtensionSchemaReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ExtensionSchemaReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "extension_schema_reference" => Ok(ExtensionSchemaReferenceTypeEnum::EXTENSION_SCHEMA_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ExtensionSchemaReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ExtensionSchemaReferenceTypeEnum::EXTENSION_SCHEMA_REFERENCE => "extension_schema_reference",
            ExtensionSchemaReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ExtensionSchemaReferenceTypeEnum {
    fn default() -> Self {
        ExtensionSchemaReferenceTypeEnum::EXTENSION_SCHEMA_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateExtension {
    pub extension: Extension,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateExtension {
    pub extension: Extension,
}

/// A rule for contacting the user for Handoff Notifications.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct HandoffNotificationRule {
    #[serde(skip_serializing_if = "String::is_empty")]
    pub id: String,
    /// The delay before firing the rule, in minutes.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_advance_in_minutes: Option<usize>,
    /// The type of handoff being created.
    pub handoff_type: HandoffNotificationRuleHandoffTypeEnum,
    pub contact_method: ContactMethodReference,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum HandoffNotificationRuleHandoffTypeEnum {
    #[serde(rename = "both")]
    BOTH,
    #[serde(rename = "oncall")]
    ONCALL,
    #[serde(rename = "offcall")]
    OFFCALL,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for HandoffNotificationRuleHandoffTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            HandoffNotificationRuleHandoffTypeEnum::BOTH => write!(f, "both"),
            HandoffNotificationRuleHandoffTypeEnum::ONCALL => write!(f, "oncall"),
            HandoffNotificationRuleHandoffTypeEnum::OFFCALL => write!(f, "offcall"),
            HandoffNotificationRuleHandoffTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for HandoffNotificationRuleHandoffTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "both" => Ok(HandoffNotificationRuleHandoffTypeEnum::BOTH),
            "oncall" => Ok(HandoffNotificationRuleHandoffTypeEnum::ONCALL),
            "offcall" => Ok(HandoffNotificationRuleHandoffTypeEnum::OFFCALL),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for HandoffNotificationRuleHandoffTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            HandoffNotificationRuleHandoffTypeEnum::BOTH => "both",
            HandoffNotificationRuleHandoffTypeEnum::ONCALL => "oncall",
            HandoffNotificationRuleHandoffTypeEnum::OFFCALL => "offcall",
            HandoffNotificationRuleHandoffTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for HandoffNotificationRuleHandoffTypeEnum {
    fn default() -> Self {
        HandoffNotificationRuleHandoffTypeEnum::BOTH
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateIncidentAlerts {
    /// An array of alerts, including the parameters to update for each alert.
    pub alerts: Vec<Alert>,
}

/// Tags to add to or remove from the entity.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateEntityTypeByIdChangeTags {
    /// Array of tags and/or tag references to add to the entity. For elements with type `tag_reference`, the tag with the corresponding `id` is added to the entity. For elements with type `tag`, if there is an existing tag with the given label that tag is added to the entity. If there is no existing tag with that label and the user has permission to create tags, a new tag is created with that label and assigned to the entity. 
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add: Option<Vec<TagsToAdd>>,
    /// Array of tag references to remove from the entity.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remove: Option<Vec<TagsToRemove_>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateLogEntryChannel {
    pub channel: LogEntriesidchannelChannel,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateUserContactMethod {
    pub contact_method: CreateUserContactMethodContactMethodEnum,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserContactMethodContactMethodEnum {
    PHONE_CONTACT_METHOD(PhoneContactMethod),
    PUSH_CONTACT_METHOD(PushContactMethod),
    EMAIL_CONTACT_METHOD(EmailContactMethod),
}

impl Display for CreateUserContactMethodContactMethodEnum {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            CreateUserContactMethodContactMethodEnum::PHONE_CONTACT_METHOD(value) => write!(f, "{:?}", value),
            CreateUserContactMethodContactMethodEnum::PUSH_CONTACT_METHOD(value) => write!(f, "{:?}", value),
            CreateUserContactMethodContactMethodEnum::EMAIL_CONTACT_METHOD(value) => write!(f, "{:?}", value),
        }
    }
}

impl std::default::Default for CreateUserContactMethodContactMethodEnum {
    fn default() -> Self {
        CreateUserContactMethodContactMethodEnum::PHONE_CONTACT_METHOD(PhoneContactMethod::default())
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateServiceIntegration {
    pub integration: Integration,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct MergeIncidents {
    /// The source incidents that will be merged into the target incident and resolved.
    pub source_incidents: Vec<IncidentReference>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateIncidentNote {
    pub note: IncidentsidnotesNote,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateUserNotificationRule {
    pub notification_rule: NotificationRule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateTeamNotificationSubscriptions {
    pub subscribables: Vec<NotificationSubscribable>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateUserNotificationSubscriptions {
    pub subscribables: Vec<NotificationSubscribable>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateUserHandoffNotificationRule {
    pub oncall_handoff_notification_rule: HandoffNotificationRule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateScheduleOverride {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub overrides: Option<Vec<ModelOverride>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateIncidentResponderRequest {
    /// The user id of the requester.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub requester_id: String,
    /// The message sent with the responder request.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub message: String,
    /// The array of targets the responder request is sent to.
    pub responder_request_targets: Vec<ResponderRequestTargetReference>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateRulesetEventRule {
    pub rule: EventRule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateServiceEventRule {
    pub rule: ServiceEventRule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateIncidentSnooze {
    /// The number of seconds to snooze the incident for. After this number of seconds has elapsed, the incident will return to the \"triggered\" state.
    pub duration: isize,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateUserStatusUpdateNotificationRule {
    pub status_update_notification_rule: StatusUpdateNotificationRule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateIncidentStatusUpdate {
    /// The message to be posted as a status update.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub message: String,
    /// The subject to be sent for the custom html email status update. Required if sending custom html email.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subject: Option<String>,
    /// The html content to be sent for the custom html email status update. Required if sending custom html email.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_message: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateBusinessServiceNotificationSubscribers {
    pub subscribers: Vec<NotificationSubscriber>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct RemoveBusinessServiceNotificationSubscriber {
    pub subscribers: Vec<NotificationSubscriber>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Impact {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The kind of object that has been impacted
    #[serde(rename = "type")]
    pub _type: ImpactTypeEnum,
    /// The current impact status of the object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ImpactStatusEnum>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_fields: Option<ImpactAdditionalFields>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ImpactTypeEnum {
    #[serde(rename = "business_service")]
    BUSINESS_SERVICE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ImpactTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ImpactTypeEnum::BUSINESS_SERVICE => write!(f, "business_service"),
            ImpactTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ImpactTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "business_service" => Ok(ImpactTypeEnum::BUSINESS_SERVICE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ImpactTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ImpactTypeEnum::BUSINESS_SERVICE => "business_service",
            ImpactTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ImpactTypeEnum {
    fn default() -> Self {
        ImpactTypeEnum::BUSINESS_SERVICE
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ImpactStatusEnum {
    #[serde(rename = "impacted")]
    IMPACTED,
    #[serde(rename = "not_impacted")]
    NOT_IMPACTED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ImpactStatusEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ImpactStatusEnum::IMPACTED => write!(f, "impacted"),
            ImpactStatusEnum::NOT_IMPACTED => write!(f, "not_impacted"),
            ImpactStatusEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ImpactStatusEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "impacted" => Ok(ImpactStatusEnum::IMPACTED),
            "not_impacted" => Ok(ImpactStatusEnum::NOT_IMPACTED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ImpactStatusEnum {
    fn as_ref(&self) -> &str {
        match self {
            ImpactStatusEnum::IMPACTED => "impacted",
            ImpactStatusEnum::NOT_IMPACTED => "not_impacted",
            ImpactStatusEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ImpactStatusEnum {
    fn default() -> Self {
        ImpactStatusEnum::IMPACTED
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ImpactAdditionalFields {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub highest_impacting_priority: Option<ImpactAdditionalFieldsHighestImpactingPriority>,
}

/// Priority information for the highest priority level that is affecting the impacted object.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ImpactAdditionalFieldsHighestImpactingPriority {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub order: Option<isize>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Impactor {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The kind of object that is impacting
    #[serde(rename = "type")]
    pub _type: ImpactorTypeEnum,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ImpactorTypeEnum {
    #[serde(rename = "incident")]
    INCIDENT,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ImpactorTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ImpactorTypeEnum::INCIDENT => write!(f, "incident"),
            ImpactorTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ImpactorTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "incident" => Ok(ImpactorTypeEnum::INCIDENT),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ImpactorTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ImpactorTypeEnum::INCIDENT => "incident",
            ImpactorTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ImpactorTypeEnum {
    fn default() -> Self {
        ImpactorTypeEnum::INCIDENT
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Incident {
    /// The label of the tag.
    #[serde(default = "Incident::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default = "Incident::_type_default")]
    pub _type: String,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The number of the incident. This is unique across your account.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident_number: Option<isize>,
    /// The date/time the incident was first triggered.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The current status of the incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<IncidentStatusEnum>,
    /// A succinct description of the nature, symptoms, cause, or effect of the incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// The list of pending_actions on the incident. A pending_action object contains a type of action which can be escalate, unacknowledge, resolve or urgency_change. A pending_action object contains at, the time at which the action will take place. An urgency_change pending_action will contain to, the urgency that the incident will change to.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pending_actions: Option<Vec<IncidentAction>>,
    /// The incident's de-duplication key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident_key: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service: Option<ServiceReference>,
    /// List of all assignments for this incident. This list will be empty if the `Incident.status` is `resolved`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assignments: Option<Vec<Assignment>>,
    /// How the current incident assignments were decided.  Note that `direct_assignment` incidents will not escalate up the attached `escalation_policy`
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assigned_via: Option<IncidentAssignedViaEnum>,
    /// List of all acknowledgements for this incident. This list will be empty if the `Incident.status` is `resolved` or `triggered`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub acknowledgements: Option<Vec<Acknowledgement>>,
    /// The time at which the status of the incident last changed.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_status_change_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_status_change_by: Option<AgentReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub first_trigger_log_entry: Option<LogEntryReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub escalation_policy: Option<EscalationPolicyReference>,
    /// The teams involved in the incident’s lifecycle.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<PriorityReference>,
    /// The current urgency of the incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub urgency: Option<IncidentUrgencyEnum>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolve_reason: Option<ResolveReason>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_counts: Option<AlertCount>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conference_bridge: Option<ConferenceBridge>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub body: Option<IncidentBody>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub occurrence: Option<IncidentOccurrence>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incidents_responders: Option<Vec<IncidentsRespondersReference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub responder_requests: Option<Vec<ResponderRequest>>,
}

#[allow(clippy::derivable_impls)]
impl Default for Incident {
    fn default() -> Self {
        Self {
            label: String::from("Incident"),
            html_url: Default::default(),
            _self: Default::default(),
            _type: String::from("incident"),
            summary: Default::default(),
            id: Default::default(),
            incident_number: Default::default(),
            created_at: Default::default(),
            status: Default::default(),
            title: Default::default(),
            pending_actions: Default::default(),
            incident_key: Default::default(),
            service: Default::default(),
            assignments: Default::default(),
            assigned_via: Default::default(),
            acknowledgements: Default::default(),
            last_status_change_at: Default::default(),
            last_status_change_by: Default::default(),
            first_trigger_log_entry: Default::default(),
            escalation_policy: Default::default(),
            teams: Default::default(),
            priority: Default::default(),
            urgency: Default::default(),
            resolve_reason: Default::default(),
            alert_counts: Default::default(),
            conference_bridge: Default::default(),
            body: Default::default(),
            occurrence: Default::default(),
            incidents_responders: Default::default(),
            responder_requests: Default::default(),
        }
    }
}

impl Incident {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Incident")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("incident")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentStatusEnum {
    #[serde(rename = "triggered")]
    TRIGGERED,
    #[serde(rename = "acknowledged")]
    ACKNOWLEDGED,
    #[serde(rename = "resolved")]
    RESOLVED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentStatusEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentStatusEnum::TRIGGERED => write!(f, "triggered"),
            IncidentStatusEnum::ACKNOWLEDGED => write!(f, "acknowledged"),
            IncidentStatusEnum::RESOLVED => write!(f, "resolved"),
            IncidentStatusEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentStatusEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "triggered" => Ok(IncidentStatusEnum::TRIGGERED),
            "acknowledged" => Ok(IncidentStatusEnum::ACKNOWLEDGED),
            "resolved" => Ok(IncidentStatusEnum::RESOLVED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentStatusEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentStatusEnum::TRIGGERED => "triggered",
            IncidentStatusEnum::ACKNOWLEDGED => "acknowledged",
            IncidentStatusEnum::RESOLVED => "resolved",
            IncidentStatusEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentStatusEnum {
    fn default() -> Self {
        IncidentStatusEnum::TRIGGERED
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentAssignedViaEnum {
    #[serde(rename = "escalation_policy")]
    ESCALATION_POLICY,
    #[serde(rename = "direct_assignment")]
    DIRECT_ASSIGNMENT,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentAssignedViaEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentAssignedViaEnum::ESCALATION_POLICY => write!(f, "escalation_policy"),
            IncidentAssignedViaEnum::DIRECT_ASSIGNMENT => write!(f, "direct_assignment"),
            IncidentAssignedViaEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentAssignedViaEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "escalation_policy" => Ok(IncidentAssignedViaEnum::ESCALATION_POLICY),
            "direct_assignment" => Ok(IncidentAssignedViaEnum::DIRECT_ASSIGNMENT),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentAssignedViaEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentAssignedViaEnum::ESCALATION_POLICY => "escalation_policy",
            IncidentAssignedViaEnum::DIRECT_ASSIGNMENT => "direct_assignment",
            IncidentAssignedViaEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentAssignedViaEnum {
    fn default() -> Self {
        IncidentAssignedViaEnum::ESCALATION_POLICY
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentUrgencyEnum {
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentUrgencyEnum::HIGH => write!(f, "high"),
            IncidentUrgencyEnum::LOW => write!(f, "low"),
            IncidentUrgencyEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "high" => Ok(IncidentUrgencyEnum::HIGH),
            "low" => Ok(IncidentUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentUrgencyEnum::HIGH => "high",
            IncidentUrgencyEnum::LOW => "low",
            IncidentUrgencyEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentUrgencyEnum {
    fn default() -> Self {
        IncidentUrgencyEnum::HIGH
    }
}

/// An incident action is a pending change to an incident that will automatically happen at some future time.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentAction {
    #[serde(rename = "type")]
    pub _type: IncidentActionTypeEnum,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub at: Option<chrono::DateTime<chrono::Utc>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentActionTypeEnum {
    #[serde(rename = "unacknowledge")]
    UNACKNOWLEDGE,
    #[serde(rename = "escalate")]
    ESCALATE,
    #[serde(rename = "resolve")]
    RESOLVE,
    #[serde(rename = "urgency_change")]
    URGENCY_CHANGE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentActionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentActionTypeEnum::UNACKNOWLEDGE => write!(f, "unacknowledge"),
            IncidentActionTypeEnum::ESCALATE => write!(f, "escalate"),
            IncidentActionTypeEnum::RESOLVE => write!(f, "resolve"),
            IncidentActionTypeEnum::URGENCY_CHANGE => write!(f, "urgency_change"),
            IncidentActionTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentActionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "unacknowledge" => Ok(IncidentActionTypeEnum::UNACKNOWLEDGE),
            "escalate" => Ok(IncidentActionTypeEnum::ESCALATE),
            "resolve" => Ok(IncidentActionTypeEnum::RESOLVE),
            "urgency_change" => Ok(IncidentActionTypeEnum::URGENCY_CHANGE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentActionTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentActionTypeEnum::UNACKNOWLEDGE => "unacknowledge",
            IncidentActionTypeEnum::ESCALATE => "escalate",
            IncidentActionTypeEnum::RESOLVE => "resolve",
            IncidentActionTypeEnum::URGENCY_CHANGE => "urgency_change",
            IncidentActionTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentActionTypeEnum {
    fn default() -> Self {
        IncidentActionTypeEnum::UNACKNOWLEDGE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentAddon {
    /// The type of Add-on.
    #[serde(rename = "type")]
    pub _type: IncidentAddonTypeEnum,
    /// The name of the Add-on.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub name: String,
    /// The source URL to display in a frame in the PagerDuty UI. HTTPS is required.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub src: String,
    /// The services this Add-on is associated with. If non-empty, the Add-on will appear only on incidents for those services. If empty, it will appear on incidents for all services. 
    #[serde(skip_serializing_if = "Option::is_none")]
    pub services: Option<Vec<ServiceReference>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentAddonTypeEnum {
    #[serde(rename = "full_page_addon")]
    FULL_PAGE_ADDON,
    #[serde(rename = "incident_show_addon")]
    INCIDENT_SHOW_ADDON,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentAddonTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentAddonTypeEnum::FULL_PAGE_ADDON => write!(f, "full_page_addon"),
            IncidentAddonTypeEnum::INCIDENT_SHOW_ADDON => write!(f, "incident_show_addon"),
            IncidentAddonTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentAddonTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "full_page_addon" => Ok(IncidentAddonTypeEnum::FULL_PAGE_ADDON),
            "incident_show_addon" => Ok(IncidentAddonTypeEnum::INCIDENT_SHOW_ADDON),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentAddonTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentAddonTypeEnum::FULL_PAGE_ADDON => "full_page_addon",
            IncidentAddonTypeEnum::INCIDENT_SHOW_ADDON => "incident_show_addon",
            IncidentAddonTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentAddonTypeEnum {
    fn default() -> Self {
        IncidentAddonTypeEnum::FULL_PAGE_ADDON
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentBody {
    #[serde(rename = "type")]
    pub _type: IncidentBodyTypeEnum,
    /// Additional incident details.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<String>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentBodyTypeEnum {
    #[serde(rename = "incident_body")]
    INCIDENT_BODY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentBodyTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentBodyTypeEnum::INCIDENT_BODY => write!(f, "incident_body"),
            IncidentBodyTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentBodyTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "incident_body" => Ok(IncidentBodyTypeEnum::INCIDENT_BODY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentBodyTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentBodyTypeEnum::INCIDENT_BODY => "incident_body",
            IncidentBodyTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentBodyTypeEnum {
    fn default() -> Self {
        IncidentBodyTypeEnum::INCIDENT_BODY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentNote {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<AllOfIncidentNoteUser>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel: Option<IncidentNoteChannel>,
    /// The note content
    #[serde(skip_serializing_if = "String::is_empty")]
    pub content: String,
    /// The time at which the note was submitted
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentNoteUser {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _type: Option<String>,
}

/// The means by which this Note was created. Has different formats depending on type.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentNoteChannel {
    /// A string describing the source of the Note.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub summary: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A string that determines the schema of the object
    #[serde(rename = "type")]
    #[serde(default = "IncidentNoteChannel::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for IncidentNoteChannel {
    fn default() -> Self {
        Self {
            summary: Default::default(),
            id: Default::default(),
            _type: String::from("incident_note_channel"),
            _self: Default::default(),
            html_url: Default::default(),
        }
    }
}

impl IncidentNoteChannel {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("incident_note_channel")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentOccurrence {
    /// The ID of the Service referenced.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<isize>,
    /// The percentage that this kind of Incident has occurred on this Service over the given period of time.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<f64>,
    /// The classifcation of the Outlier Incident. The values can be one of [\"novel\", \"rare\",  \"frequent\", \"other\"]. \"novel\": It means this Incident hasn't occured. \"rare\": It means this Incident occurs with a low frequency. \"frequent\": It means this Incident occurs with a high frequency. \"other\": It means this Incident occurs with a medium frequency. 
    #[serde(skip_serializing_if = "Option::is_none")]
    pub category: Option<IncidentOccurrenceCategoryEnum>,
    /// The start of the date/time range over which Outlier Incident was calculated.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub since: Option<chrono::DateTime<chrono::Utc>>,
    /// The end of the date/time range over which Outlier Incident was calculated.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub until: Option<chrono::DateTime<chrono::Utc>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentOccurrenceCategoryEnum {
    #[serde(rename = "novel")]
    NOVEL,
    #[serde(rename = "rare")]
    RARE,
    #[serde(rename = "frequent")]
    FREQUENT,
    #[serde(rename = "other")]
    OTHER,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentOccurrenceCategoryEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentOccurrenceCategoryEnum::NOVEL => write!(f, "novel"),
            IncidentOccurrenceCategoryEnum::RARE => write!(f, "rare"),
            IncidentOccurrenceCategoryEnum::FREQUENT => write!(f, "frequent"),
            IncidentOccurrenceCategoryEnum::OTHER => write!(f, "other"),
            IncidentOccurrenceCategoryEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentOccurrenceCategoryEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "novel" => Ok(IncidentOccurrenceCategoryEnum::NOVEL),
            "rare" => Ok(IncidentOccurrenceCategoryEnum::RARE),
            "frequent" => Ok(IncidentOccurrenceCategoryEnum::FREQUENT),
            "other" => Ok(IncidentOccurrenceCategoryEnum::OTHER),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentOccurrenceCategoryEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentOccurrenceCategoryEnum::NOVEL => "novel",
            IncidentOccurrenceCategoryEnum::RARE => "rare",
            IncidentOccurrenceCategoryEnum::FREQUENT => "frequent",
            IncidentOccurrenceCategoryEnum::OTHER => "other",
            IncidentOccurrenceCategoryEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentOccurrenceCategoryEnum {
    fn default() -> Self {
        IncidentOccurrenceCategoryEnum::NOVEL
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentReference {
    /// The label of the tag.
    #[serde(default = "IncidentReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: IncidentReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for IncidentReference {
    fn default() -> Self {
        Self {
            label: String::from("IncidentReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl IncidentReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("IncidentReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("incident_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentReferenceTypeEnum {
    #[serde(rename = "incident_reference")]
    INCIDENT_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentReferenceTypeEnum::INCIDENT_REFERENCE => write!(f, "incident_reference"),
            IncidentReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "incident_reference" => Ok(IncidentReferenceTypeEnum::INCIDENT_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentReferenceTypeEnum::INCIDENT_REFERENCE => "incident_reference",
            IncidentReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentReferenceTypeEnum {
    fn default() -> Self {
        IncidentReferenceTypeEnum::INCIDENT_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentUrgencyRule {
    /// The type of incident urgency: whether it's constant, or it's dependent on the support hours.
    #[serde(rename = "type")]
    pub _type: IncidentUrgencyRuleTypeEnum,
    /// The incidents' urgency, if type is constant.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub urgency: Option<IncidentUrgencyRuleUrgencyEnum>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub during_support_hours: Option<IncidentUrgencyType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub outside_support_hours: Option<IncidentUrgencyType>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentUrgencyRuleTypeEnum {
    #[serde(rename = "constant")]
    CONSTANT,
    #[serde(rename = "use_support_hours")]
    USE_SUPPORT_HOURS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentUrgencyRuleTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentUrgencyRuleTypeEnum::CONSTANT => write!(f, "constant"),
            IncidentUrgencyRuleTypeEnum::USE_SUPPORT_HOURS => write!(f, "use_support_hours"),
            IncidentUrgencyRuleTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentUrgencyRuleTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "constant" => Ok(IncidentUrgencyRuleTypeEnum::CONSTANT),
            "use_support_hours" => Ok(IncidentUrgencyRuleTypeEnum::USE_SUPPORT_HOURS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentUrgencyRuleTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentUrgencyRuleTypeEnum::CONSTANT => "constant",
            IncidentUrgencyRuleTypeEnum::USE_SUPPORT_HOURS => "use_support_hours",
            IncidentUrgencyRuleTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentUrgencyRuleTypeEnum {
    fn default() -> Self {
        IncidentUrgencyRuleTypeEnum::CONSTANT
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentUrgencyRuleUrgencyEnum {
    #[serde(rename = "low")]
    LOW,
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "severity_based")]
    SEVERITY_BASED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentUrgencyRuleUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentUrgencyRuleUrgencyEnum::LOW => write!(f, "low"),
            IncidentUrgencyRuleUrgencyEnum::HIGH => write!(f, "high"),
            IncidentUrgencyRuleUrgencyEnum::SEVERITY_BASED => write!(f, "severity_based"),
            IncidentUrgencyRuleUrgencyEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentUrgencyRuleUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "low" => Ok(IncidentUrgencyRuleUrgencyEnum::LOW),
            "high" => Ok(IncidentUrgencyRuleUrgencyEnum::HIGH),
            "severity_based" => Ok(IncidentUrgencyRuleUrgencyEnum::SEVERITY_BASED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentUrgencyRuleUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentUrgencyRuleUrgencyEnum::LOW => "low",
            IncidentUrgencyRuleUrgencyEnum::HIGH => "high",
            IncidentUrgencyRuleUrgencyEnum::SEVERITY_BASED => "severity_based",
            IncidentUrgencyRuleUrgencyEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentUrgencyRuleUrgencyEnum {
    fn default() -> Self {
        IncidentUrgencyRuleUrgencyEnum::LOW
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentUrgencyType {
    /// The type of incident urgency: whether it's constant, or it's dependent on the support hours.
    #[serde(rename = "type")]
    pub _type: IncidentUrgencyTypeTypeEnum,
    /// The incidents' urgency, if type is constant.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub urgency: Option<IncidentUrgencyTypeUrgencyEnum>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentUrgencyTypeTypeEnum {
    #[serde(rename = "constant")]
    CONSTANT,
    #[serde(rename = "use_support_hours")]
    USE_SUPPORT_HOURS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentUrgencyTypeTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentUrgencyTypeTypeEnum::CONSTANT => write!(f, "constant"),
            IncidentUrgencyTypeTypeEnum::USE_SUPPORT_HOURS => write!(f, "use_support_hours"),
            IncidentUrgencyTypeTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentUrgencyTypeTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "constant" => Ok(IncidentUrgencyTypeTypeEnum::CONSTANT),
            "use_support_hours" => Ok(IncidentUrgencyTypeTypeEnum::USE_SUPPORT_HOURS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentUrgencyTypeTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentUrgencyTypeTypeEnum::CONSTANT => "constant",
            IncidentUrgencyTypeTypeEnum::USE_SUPPORT_HOURS => "use_support_hours",
            IncidentUrgencyTypeTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentUrgencyTypeTypeEnum {
    fn default() -> Self {
        IncidentUrgencyTypeTypeEnum::CONSTANT
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentUrgencyTypeUrgencyEnum {
    #[serde(rename = "low")]
    LOW,
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "severity_based")]
    SEVERITY_BASED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentUrgencyTypeUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentUrgencyTypeUrgencyEnum::LOW => write!(f, "low"),
            IncidentUrgencyTypeUrgencyEnum::HIGH => write!(f, "high"),
            IncidentUrgencyTypeUrgencyEnum::SEVERITY_BASED => write!(f, "severity_based"),
            IncidentUrgencyTypeUrgencyEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentUrgencyTypeUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "low" => Ok(IncidentUrgencyTypeUrgencyEnum::LOW),
            "high" => Ok(IncidentUrgencyTypeUrgencyEnum::HIGH),
            "severity_based" => Ok(IncidentUrgencyTypeUrgencyEnum::SEVERITY_BASED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentUrgencyTypeUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentUrgencyTypeUrgencyEnum::LOW => "low",
            IncidentUrgencyTypeUrgencyEnum::HIGH => "high",
            IncidentUrgencyTypeUrgencyEnum::SEVERITY_BASED => "severity_based",
            IncidentUrgencyTypeUrgencyEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentUrgencyTypeUrgencyEnum {
    fn default() -> Self {
        IncidentUrgencyTypeUrgencyEnum::LOW
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentsAssignments {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assignee: Option<UserReference>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateIncidents {
    /// An array of incidents, including the parameters to update.
    pub incidents: Vec<IncidentsIncidents>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateIncident {
    pub incident: IncidentsIncident,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateIncident {
    pub incident: IncidentsidIncident,
}

/// Details of the incident to be created.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentsIncident {
    #[serde(rename = "type")]
    pub _type: IncidentsIncidentTypeEnum,
    /// A succinct description of the nature, symptoms, cause, or effect of the incident.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub title: String,
    pub service: ServiceReference,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<PriorityReference>,
    /// The urgency of the incident
    #[serde(skip_serializing_if = "Option::is_none")]
    pub urgency: Option<IncidentsIncidentUrgencyEnum>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub body: Option<IncidentBody>,
    /// A string which identifies the incident. Sending subsequent requests referencing the same service and with the same incident_key will result in those requests being rejected if an open incident matches that incident_key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident_key: Option<String>,
    /// Assign the incident to these assignees. Cannot be specified if an escalation policy is given.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assignments: Option<Vec<IncidentsAssignments>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub escalation_policy: Option<EscalationPolicyReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conference_bridge: Option<ConferenceBridge>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsIncidentTypeEnum {
    #[serde(rename = "incident")]
    INCIDENT,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsIncidentTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentsIncidentTypeEnum::INCIDENT => write!(f, "incident"),
            IncidentsIncidentTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsIncidentTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "incident" => Ok(IncidentsIncidentTypeEnum::INCIDENT),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsIncidentTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentsIncidentTypeEnum::INCIDENT => "incident",
            IncidentsIncidentTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsIncidentTypeEnum {
    fn default() -> Self {
        IncidentsIncidentTypeEnum::INCIDENT
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsIncidentUrgencyEnum {
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsIncidentUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentsIncidentUrgencyEnum::HIGH => write!(f, "high"),
            IncidentsIncidentUrgencyEnum::LOW => write!(f, "low"),
            IncidentsIncidentUrgencyEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsIncidentUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "high" => Ok(IncidentsIncidentUrgencyEnum::HIGH),
            "low" => Ok(IncidentsIncidentUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsIncidentUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentsIncidentUrgencyEnum::HIGH => "high",
            IncidentsIncidentUrgencyEnum::LOW => "low",
            IncidentsIncidentUrgencyEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsIncidentUrgencyEnum {
    fn default() -> Self {
        IncidentsIncidentUrgencyEnum::HIGH
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentsIncidents {
    /// The id of the incident to update.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub id: String,
    /// The incident type.
    #[serde(rename = "type")]
    pub _type: IncidentsIncidentsTypeEnum,
    /// The new status of the incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<IncidentsIncidentsStatusEnum>,
    /// The resolution for this incident if status is set to resolved.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolution: Option<String>,
    /// A succinct description of the nature, symptoms, cause, or effect of the incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<PriorityReference>,
    /// Escalate the incident to this level in the escalation policy.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub escalation_level: Option<isize>,
    /// Assign the incident to these assignees.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assignments: Option<Vec<IncidentsAssignments>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub escalation_policy: Option<EscalationPolicyReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conference_bridge: Option<ConferenceBridge>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsIncidentsTypeEnum {
    #[serde(rename = "incident")]
    INCIDENT,
    #[serde(rename = "incident_reference")]
    INCIDENT_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsIncidentsTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentsIncidentsTypeEnum::INCIDENT => write!(f, "incident"),
            IncidentsIncidentsTypeEnum::INCIDENT_REFERENCE => write!(f, "incident_reference"),
            IncidentsIncidentsTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsIncidentsTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "incident" => Ok(IncidentsIncidentsTypeEnum::INCIDENT),
            "incident_reference" => Ok(IncidentsIncidentsTypeEnum::INCIDENT_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsIncidentsTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentsIncidentsTypeEnum::INCIDENT => "incident",
            IncidentsIncidentsTypeEnum::INCIDENT_REFERENCE => "incident_reference",
            IncidentsIncidentsTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsIncidentsTypeEnum {
    fn default() -> Self {
        IncidentsIncidentsTypeEnum::INCIDENT
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsIncidentsStatusEnum {
    #[serde(rename = "resolved")]
    RESOLVED,
    #[serde(rename = "acknowledged")]
    ACKNOWLEDGED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsIncidentsStatusEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentsIncidentsStatusEnum::RESOLVED => write!(f, "resolved"),
            IncidentsIncidentsStatusEnum::ACKNOWLEDGED => write!(f, "acknowledged"),
            IncidentsIncidentsStatusEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsIncidentsStatusEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "resolved" => Ok(IncidentsIncidentsStatusEnum::RESOLVED),
            "acknowledged" => Ok(IncidentsIncidentsStatusEnum::ACKNOWLEDGED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsIncidentsStatusEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentsIncidentsStatusEnum::RESOLVED => "resolved",
            IncidentsIncidentsStatusEnum::ACKNOWLEDGED => "acknowledged",
            IncidentsIncidentsStatusEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsIncidentsStatusEnum {
    fn default() -> Self {
        IncidentsIncidentsStatusEnum::RESOLVED
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentsRespondersReference {
    /// The status of the responder being added to the incident
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<UserReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<IncidentReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<String>,
    /// The message sent with the responder request
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester: Option<UserReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requested_at: Option<String>,
}

/// The parameters of the incident to update.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentsidIncident {
    /// The incident type.
    #[serde(rename = "type")]
    pub _type: IncidentsidIncidentTypeEnum,
    /// The new status of the incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<IncidentsidIncidentStatusEnum>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<PriorityReference>,
    /// The resolution for this incident if status is set to resolved.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolution: Option<String>,
    /// The new title of the incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// Escalate the incident to this level in the escalation policy.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub escalation_level: Option<isize>,
    /// Assign the incident to these assignees.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assignments: Option<Vec<IncidentsAssignments>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub escalation_policy: Option<EscalationPolicyReference>,
    /// The urgency of the incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub urgency: Option<IncidentsidIncidentUrgencyEnum>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conference_bridge: Option<ConferenceBridge>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsidIncidentTypeEnum {
    #[serde(rename = "incident")]
    INCIDENT,
    #[serde(rename = "incident_reference")]
    INCIDENT_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsidIncidentTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentsidIncidentTypeEnum::INCIDENT => write!(f, "incident"),
            IncidentsidIncidentTypeEnum::INCIDENT_REFERENCE => write!(f, "incident_reference"),
            IncidentsidIncidentTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsidIncidentTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "incident" => Ok(IncidentsidIncidentTypeEnum::INCIDENT),
            "incident_reference" => Ok(IncidentsidIncidentTypeEnum::INCIDENT_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsidIncidentTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentsidIncidentTypeEnum::INCIDENT => "incident",
            IncidentsidIncidentTypeEnum::INCIDENT_REFERENCE => "incident_reference",
            IncidentsidIncidentTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsidIncidentTypeEnum {
    fn default() -> Self {
        IncidentsidIncidentTypeEnum::INCIDENT
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsidIncidentStatusEnum {
    #[serde(rename = "resolved")]
    RESOLVED,
    #[serde(rename = "acknowledged")]
    ACKNOWLEDGED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsidIncidentStatusEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentsidIncidentStatusEnum::RESOLVED => write!(f, "resolved"),
            IncidentsidIncidentStatusEnum::ACKNOWLEDGED => write!(f, "acknowledged"),
            IncidentsidIncidentStatusEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsidIncidentStatusEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "resolved" => Ok(IncidentsidIncidentStatusEnum::RESOLVED),
            "acknowledged" => Ok(IncidentsidIncidentStatusEnum::ACKNOWLEDGED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsidIncidentStatusEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentsidIncidentStatusEnum::RESOLVED => "resolved",
            IncidentsidIncidentStatusEnum::ACKNOWLEDGED => "acknowledged",
            IncidentsidIncidentStatusEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsidIncidentStatusEnum {
    fn default() -> Self {
        IncidentsidIncidentStatusEnum::RESOLVED
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IncidentsidIncidentUrgencyEnum {
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IncidentsidIncidentUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IncidentsidIncidentUrgencyEnum::HIGH => write!(f, "high"),
            IncidentsidIncidentUrgencyEnum::LOW => write!(f, "low"),
            IncidentsidIncidentUrgencyEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IncidentsidIncidentUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "high" => Ok(IncidentsidIncidentUrgencyEnum::HIGH),
            "low" => Ok(IncidentsidIncidentUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IncidentsidIncidentUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self {
            IncidentsidIncidentUrgencyEnum::HIGH => "high",
            IncidentsidIncidentUrgencyEnum::LOW => "low",
            IncidentsidIncidentUrgencyEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IncidentsidIncidentUrgencyEnum {
    fn default() -> Self {
        IncidentsidIncidentUrgencyEnum::HIGH
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IncidentsidnotesNote {
    /// The note content
    #[serde(skip_serializing_if = "String::is_empty")]
    pub content: String,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct AdditionalFields {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_impacted_count: Option<isize>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct GlobalThreshold {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub order: Option<isize>,
}

/// Outlier Incident information calculated over the same Service as the given Incident.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OutlierIncident {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<Incident>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident_template: Option<OutlierIncidentIncidentTemplate>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OutlierIncidentIncidentTemplate {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The cluster the Incident Template pattern belongs to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cluster_id: Option<String>,
    /// The Incident Template mined pattern text
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mined_text: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct PastIncidents {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<Incident>,
    /// The computed similarity score associated with the incident and parent incident 
    #[serde(skip_serializing_if = "Option::is_none")]
    pub score: Option<f64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct RelatedIncidents {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<Incident>,
    /// A list of reasons for why the Incident is considered related.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub relationships: Option<Vec<Relationships>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Relationships {
    /// The type of relationship. A relationship outlines the reason why two Incidents are considered related.
    #[serde(rename = "type")]
    pub _type: RelationshipsTypeEnum,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<RelationshipsMetadataEnum>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RelationshipsTypeEnum {
    #[serde(rename = "machine_learning_inferred")]
    MACHINE_LEARNING_INFERRED,
    #[serde(rename = "service_dependency")]
    SERVICE_DEPENDENCY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for RelationshipsTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            RelationshipsTypeEnum::MACHINE_LEARNING_INFERRED => write!(f, "machine_learning_inferred"),
            RelationshipsTypeEnum::SERVICE_DEPENDENCY => write!(f, "service_dependency"),
            RelationshipsTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for RelationshipsTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "machine_learning_inferred" => Ok(RelationshipsTypeEnum::MACHINE_LEARNING_INFERRED),
            "service_dependency" => Ok(RelationshipsTypeEnum::SERVICE_DEPENDENCY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for RelationshipsTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            RelationshipsTypeEnum::MACHINE_LEARNING_INFERRED => "machine_learning_inferred",
            RelationshipsTypeEnum::SERVICE_DEPENDENCY => "service_dependency",
            RelationshipsTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for RelationshipsTypeEnum {
    fn default() -> Self {
        RelationshipsTypeEnum::MACHINE_LEARNING_INFERRED
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RelationshipsMetadataEnum {
    RELATED_INCIDENT_MACHINE_LEARNING_RELATIONSHIP(RelatedIncidentMachineLearningRelationship),
    RELATED_INCIDENT_SERVICE_DEPENDENCY_RELATIONSHIP(RelatedIncidentServiceDependencyRelationship),
}

impl Display for RelationshipsMetadataEnum {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            RelationshipsMetadataEnum::RELATED_INCIDENT_MACHINE_LEARNING_RELATIONSHIP(value) => write!(f, "{:?}", value),
            RelationshipsMetadataEnum::RELATED_INCIDENT_SERVICE_DEPENDENCY_RELATIONSHIP(value) => write!(f, "{:?}", value),
        }
    }
}

impl std::default::Default for RelationshipsMetadataEnum {
    fn default() -> Self {
        RelationshipsMetadataEnum::RELATED_INCIDENT_MACHINE_LEARNING_RELATIONSHIP(RelatedIncidentMachineLearningRelationship::default())
    }
}

/// A list of the 5 most recent paused Alerts that weere triggered and 5 most recent Alerts that were reesolved before being triggerd.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct PausedIncidentReportingAlerts {
    /// The start of the date range over which the report data is represented.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub since: Option<String>,
    /// The end of the date range over which the report data is represented.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub until: Option<String>,
    /// An array of Alerts that were triggered after being paused.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub triggered_after_pause_alerts: Option<Vec<PausedIncidentReportingAlertsTriggeredAfterPauseAlerts>>,
    /// An array of Alerts that were resolved after being paused.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolved_after_pause_alerts: Option<Vec<PausedIncidentReportingAlertsTriggeredAfterPauseAlerts>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct PausedIncidentReportingAlertsTriggeredAfterPauseAlerts {
    /// The Alert ID
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The Alert's Service ID
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_id: Option<String>,
    /// The date/time the Alert was created
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
}

/// A representation of Alerts that were paused, triggered after pause, and resolved after pause.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct PausedIncidentReportingCounts {
    /// The start of the date range over which the report data is represented.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub since: Option<String>,
    /// The end of the date range over which the report data is represented.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub until: Option<String>,
    /// The total number of paused Alerts for the Account or Servce.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub paused_count: Option<f64>,
    /// The total number of paused Alerts for the Account or Service that were triggerd after being paused (non-transient Alerts).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub triggered_after_pause_count: Option<f64>,
    /// The total number of paused Alerts for the Account or Service that were resolved after being paused and not triggered (transient Alerts).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolved_after_pause_count: Option<f64>,
}

/// A collection of filters that were applied to the results.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Filters {
    /// The lower boundary for the created_at range filter applied to the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at_start: Option<String>,
    /// The upper boundary for the created_at range filter applied to the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at_end: Option<String>,
    /// The urgency filter applied to the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub urgency: Option<FiltersUrgencyEnum>,
    /// The [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents) filter applied to the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub major: Option<bool>,
    /// The team_ids filter applied to the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team_ids: Option<Vec<String>>,
    /// The service_ids filter applied to the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_ids: Option<Vec<String>>,
    /// The priority_ids filter applied to the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority_ids: Option<Vec<String>>,
    /// The priority_names filter applied to the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority_names: Option<Vec<String>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum FiltersUrgencyEnum {
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for FiltersUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            FiltersUrgencyEnum::HIGH => write!(f, "high"),
            FiltersUrgencyEnum::LOW => write!(f, "low"),
            FiltersUrgencyEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for FiltersUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "high" => Ok(FiltersUrgencyEnum::HIGH),
            "low" => Ok(FiltersUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for FiltersUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self {
            FiltersUrgencyEnum::HIGH => "high",
            FiltersUrgencyEnum::LOW => "low",
            FiltersUrgencyEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for FiltersUrgencyEnum {
    fn default() -> Self {
        FiltersUrgencyEnum::HIGH
    }
}

/// The reference to the service that is dependent on the technical service.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct DependentService {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    #[serde(default = "DependentService::_type_default")]
    pub _type: String,
}

#[allow(clippy::derivable_impls)]
impl Default for DependentService {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("inline_response_200_54_dependent_service"),
        }
    }
}

impl DependentService {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("inline_response_200_54_dependent_service")
    }
}

/// The reference to the service that supports the Business Service.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct SupportingService {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    #[serde(default = "SupportingService::_type_default")]
    pub _type: String,
}

#[allow(clippy::derivable_impls)]
impl Default for SupportingService {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("inline_response_200_55_supporting_service"),
        }
    }
}

impl SupportingService {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("inline_response_200_55_supporting_service")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Members {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<UserReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Subscriptions {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscription: Option<NotificationSubscription>,
    /// The name of the subscribable
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribable_name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Error {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<isize>,
    /// Error message string
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub errors: Option<Vec<String>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Integration {
    /// The label of the tag.
    #[serde(default = "Integration::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: IntegrationTypeEnum,
    /// The name of this integration.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service: Option<ServiceReference>,
    /// The date/time when this integration was created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vendor: Option<VendorReference>,
    /// Specify for generic_email_inbound_integration. Must be set to an email address @your-subdomain.pagerduty.com
    #[serde(skip_serializing_if = "Option::is_none")]
    pub integration_email: Option<String>,
    /// Specify for generic_email_inbound_integration
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email_incident_creation: Option<IntegrationEmailIncidentCreationEnum>,
    /// Specify for generic_email_inbound_integration. May override email_incident_creation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email_filter_mode: Option<IntegrationEmailFilterModeEnum>,
    /// Specify for generic_email_inbound_integration.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email_parsers: Option<Vec<EmailParser>>,
    /// Specify for generic_email_inbound_integration.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email_parsing_fallback: Option<IntegrationEmailParsingFallbackEnum>,
    /// Specify for generic_email_inbound_integration.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email_filters: Option<Vec<IntegrationEmailFilters>>,
}

#[allow(clippy::derivable_impls)]
impl Default for Integration {
    fn default() -> Self {
        Self {
            label: String::from("Integration"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            name: Default::default(),
            service: Default::default(),
            created_at: Default::default(),
            vendor: Default::default(),
            integration_email: Default::default(),
            email_incident_creation: Default::default(),
            email_filter_mode: Default::default(),
            email_parsers: Default::default(),
            email_parsing_fallback: Default::default(),
            email_filters: Default::default(),
        }
    }
}

impl Integration {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Integration")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("integration")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IntegrationTypeEnum {
    #[serde(rename = "aws_cloudwatch_inbound_integration")]
    AWS_CLOUDWATCH_INBOUND_INTEGRATION,
    #[serde(rename = "cloudkick_inbound_integration")]
    CLOUDKICK_INBOUND_INTEGRATION,
    #[serde(rename = "event_transformer_api_inbound_integration")]
    EVENT_TRANSFORMER_API_INBOUND_INTEGRATION,
    #[serde(rename = "generic_email_inbound_integration")]
    GENERIC_EMAIL_INBOUND_INTEGRATION,
    #[serde(rename = "generic_events_api_inbound_integration")]
    GENERIC_EVENTS_API_INBOUND_INTEGRATION,
    #[serde(rename = "keynote_inbound_integration")]
    KEYNOTE_INBOUND_INTEGRATION,
    #[serde(rename = "nagios_inbound_integration")]
    NAGIOS_INBOUND_INTEGRATION,
    #[serde(rename = "pingdom_inbound_integration")]
    PINGDOM_INBOUND_INTEGRATION,
    #[serde(rename = "sql_monitor_inbound_integration")]
    SQL_MONITOR_INBOUND_INTEGRATION,
    #[serde(rename = "events_api_v2_inbound_integration")]
    EVENTS_API_V2_INBOUND_INTEGRATION,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IntegrationTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IntegrationTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION => write!(f, "aws_cloudwatch_inbound_integration"),
            IntegrationTypeEnum::CLOUDKICK_INBOUND_INTEGRATION => write!(f, "cloudkick_inbound_integration"),
            IntegrationTypeEnum::EVENT_TRANSFORMER_API_INBOUND_INTEGRATION => write!(f, "event_transformer_api_inbound_integration"),
            IntegrationTypeEnum::GENERIC_EMAIL_INBOUND_INTEGRATION => write!(f, "generic_email_inbound_integration"),
            IntegrationTypeEnum::GENERIC_EVENTS_API_INBOUND_INTEGRATION => write!(f, "generic_events_api_inbound_integration"),
            IntegrationTypeEnum::KEYNOTE_INBOUND_INTEGRATION => write!(f, "keynote_inbound_integration"),
            IntegrationTypeEnum::NAGIOS_INBOUND_INTEGRATION => write!(f, "nagios_inbound_integration"),
            IntegrationTypeEnum::PINGDOM_INBOUND_INTEGRATION => write!(f, "pingdom_inbound_integration"),
            IntegrationTypeEnum::SQL_MONITOR_INBOUND_INTEGRATION => write!(f, "sql_monitor_inbound_integration"),
            IntegrationTypeEnum::EVENTS_API_V2_INBOUND_INTEGRATION => write!(f, "events_api_v2_inbound_integration"),
            IntegrationTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IntegrationTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "aws_cloudwatch_inbound_integration" => Ok(IntegrationTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION),
            "cloudkick_inbound_integration" => Ok(IntegrationTypeEnum::CLOUDKICK_INBOUND_INTEGRATION),
            "event_transformer_api_inbound_integration" => Ok(IntegrationTypeEnum::EVENT_TRANSFORMER_API_INBOUND_INTEGRATION),
            "generic_email_inbound_integration" => Ok(IntegrationTypeEnum::GENERIC_EMAIL_INBOUND_INTEGRATION),
            "generic_events_api_inbound_integration" => Ok(IntegrationTypeEnum::GENERIC_EVENTS_API_INBOUND_INTEGRATION),
            "keynote_inbound_integration" => Ok(IntegrationTypeEnum::KEYNOTE_INBOUND_INTEGRATION),
            "nagios_inbound_integration" => Ok(IntegrationTypeEnum::NAGIOS_INBOUND_INTEGRATION),
            "pingdom_inbound_integration" => Ok(IntegrationTypeEnum::PINGDOM_INBOUND_INTEGRATION),
            "sql_monitor_inbound_integration" => Ok(IntegrationTypeEnum::SQL_MONITOR_INBOUND_INTEGRATION),
            "events_api_v2_inbound_integration" => Ok(IntegrationTypeEnum::EVENTS_API_V2_INBOUND_INTEGRATION),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IntegrationTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IntegrationTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION => "aws_cloudwatch_inbound_integration",
            IntegrationTypeEnum::CLOUDKICK_INBOUND_INTEGRATION => "cloudkick_inbound_integration",
            IntegrationTypeEnum::EVENT_TRANSFORMER_API_INBOUND_INTEGRATION => "event_transformer_api_inbound_integration",
            IntegrationTypeEnum::GENERIC_EMAIL_INBOUND_INTEGRATION => "generic_email_inbound_integration",
            IntegrationTypeEnum::GENERIC_EVENTS_API_INBOUND_INTEGRATION => "generic_events_api_inbound_integration",
            IntegrationTypeEnum::KEYNOTE_INBOUND_INTEGRATION => "keynote_inbound_integration",
            IntegrationTypeEnum::NAGIOS_INBOUND_INTEGRATION => "nagios_inbound_integration",
            IntegrationTypeEnum::PINGDOM_INBOUND_INTEGRATION => "pingdom_inbound_integration",
            IntegrationTypeEnum::SQL_MONITOR_INBOUND_INTEGRATION => "sql_monitor_inbound_integration",
            IntegrationTypeEnum::EVENTS_API_V2_INBOUND_INTEGRATION => "events_api_v2_inbound_integration",
            IntegrationTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IntegrationTypeEnum {
    fn default() -> Self {
        IntegrationTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IntegrationEmailIncidentCreationEnum {
    #[serde(rename = "on_new_email")]
    ON_NEW_EMAIL,
    #[serde(rename = "on_new_email_subject")]
    ON_NEW_EMAIL_SUBJECT,
    #[serde(rename = "only_if_no_open_incidents")]
    ONLY_IF_NO_OPEN_INCIDENTS,
    #[serde(rename = "use_rules")]
    USE_RULES,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IntegrationEmailIncidentCreationEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IntegrationEmailIncidentCreationEnum::ON_NEW_EMAIL => write!(f, "on_new_email"),
            IntegrationEmailIncidentCreationEnum::ON_NEW_EMAIL_SUBJECT => write!(f, "on_new_email_subject"),
            IntegrationEmailIncidentCreationEnum::ONLY_IF_NO_OPEN_INCIDENTS => write!(f, "only_if_no_open_incidents"),
            IntegrationEmailIncidentCreationEnum::USE_RULES => write!(f, "use_rules"),
            IntegrationEmailIncidentCreationEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IntegrationEmailIncidentCreationEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "on_new_email" => Ok(IntegrationEmailIncidentCreationEnum::ON_NEW_EMAIL),
            "on_new_email_subject" => Ok(IntegrationEmailIncidentCreationEnum::ON_NEW_EMAIL_SUBJECT),
            "only_if_no_open_incidents" => Ok(IntegrationEmailIncidentCreationEnum::ONLY_IF_NO_OPEN_INCIDENTS),
            "use_rules" => Ok(IntegrationEmailIncidentCreationEnum::USE_RULES),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IntegrationEmailIncidentCreationEnum {
    fn as_ref(&self) -> &str {
        match self {
            IntegrationEmailIncidentCreationEnum::ON_NEW_EMAIL => "on_new_email",
            IntegrationEmailIncidentCreationEnum::ON_NEW_EMAIL_SUBJECT => "on_new_email_subject",
            IntegrationEmailIncidentCreationEnum::ONLY_IF_NO_OPEN_INCIDENTS => "only_if_no_open_incidents",
            IntegrationEmailIncidentCreationEnum::USE_RULES => "use_rules",
            IntegrationEmailIncidentCreationEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IntegrationEmailIncidentCreationEnum {
    fn default() -> Self {
        IntegrationEmailIncidentCreationEnum::ON_NEW_EMAIL
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IntegrationEmailFilterModeEnum {
    #[serde(rename = "all-email")]
    ALL_EMAIL,
    #[serde(rename = "or-rules-email")]
    OR_RULES_EMAIL,
    #[serde(rename = "and-rules-email")]
    AND_RULES_EMAIL,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IntegrationEmailFilterModeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IntegrationEmailFilterModeEnum::ALL_EMAIL => write!(f, "all-email"),
            IntegrationEmailFilterModeEnum::OR_RULES_EMAIL => write!(f, "or-rules-email"),
            IntegrationEmailFilterModeEnum::AND_RULES_EMAIL => write!(f, "and-rules-email"),
            IntegrationEmailFilterModeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IntegrationEmailFilterModeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "all-email" => Ok(IntegrationEmailFilterModeEnum::ALL_EMAIL),
            "or-rules-email" => Ok(IntegrationEmailFilterModeEnum::OR_RULES_EMAIL),
            "and-rules-email" => Ok(IntegrationEmailFilterModeEnum::AND_RULES_EMAIL),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IntegrationEmailFilterModeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IntegrationEmailFilterModeEnum::ALL_EMAIL => "all-email",
            IntegrationEmailFilterModeEnum::OR_RULES_EMAIL => "or-rules-email",
            IntegrationEmailFilterModeEnum::AND_RULES_EMAIL => "and-rules-email",
            IntegrationEmailFilterModeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IntegrationEmailFilterModeEnum {
    fn default() -> Self {
        IntegrationEmailFilterModeEnum::ALL_EMAIL
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IntegrationEmailParsingFallbackEnum {
    #[serde(rename = "open_new_incident")]
    OPEN_NEW_INCIDENT,
    #[serde(rename = "discard")]
    DISCARD,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IntegrationEmailParsingFallbackEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IntegrationEmailParsingFallbackEnum::OPEN_NEW_INCIDENT => write!(f, "open_new_incident"),
            IntegrationEmailParsingFallbackEnum::DISCARD => write!(f, "discard"),
            IntegrationEmailParsingFallbackEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IntegrationEmailParsingFallbackEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "open_new_incident" => Ok(IntegrationEmailParsingFallbackEnum::OPEN_NEW_INCIDENT),
            "discard" => Ok(IntegrationEmailParsingFallbackEnum::DISCARD),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IntegrationEmailParsingFallbackEnum {
    fn as_ref(&self) -> &str {
        match self {
            IntegrationEmailParsingFallbackEnum::OPEN_NEW_INCIDENT => "open_new_incident",
            IntegrationEmailParsingFallbackEnum::DISCARD => "discard",
            IntegrationEmailParsingFallbackEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IntegrationEmailParsingFallbackEnum {
    fn default() -> Self {
        IntegrationEmailParsingFallbackEnum::OPEN_NEW_INCIDENT
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IntegrationEmailFilters {
    pub subject_mode: IntegrationEmailFiltersSubjectModeEnum,
    /// Specify if subject_mode is set to match or no-match
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subject_regex: Option<String>,
    pub body_mode: IntegrationEmailFiltersBodyModeEnum,
    /// Specify if body_mode is set to match or no-match
    #[serde(skip_serializing_if = "Option::is_none")]
    pub body_regex: Option<String>,
    pub from_email_mode: IntegrationEmailFiltersFromEmailModeEnum,
    /// Specify if from_email_mode is set to match or no-match
    #[serde(skip_serializing_if = "Option::is_none")]
    pub from_email_regex: Option<String>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IntegrationEmailFiltersSubjectModeEnum {
    #[serde(rename = "match")]
    MATCH,
    #[serde(rename = "no-match")]
    NO_MATCH,
    #[serde(rename = "always")]
    ALWAYS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IntegrationEmailFiltersSubjectModeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IntegrationEmailFiltersSubjectModeEnum::MATCH => write!(f, "match"),
            IntegrationEmailFiltersSubjectModeEnum::NO_MATCH => write!(f, "no-match"),
            IntegrationEmailFiltersSubjectModeEnum::ALWAYS => write!(f, "always"),
            IntegrationEmailFiltersSubjectModeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IntegrationEmailFiltersSubjectModeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "match" => Ok(IntegrationEmailFiltersSubjectModeEnum::MATCH),
            "no-match" => Ok(IntegrationEmailFiltersSubjectModeEnum::NO_MATCH),
            "always" => Ok(IntegrationEmailFiltersSubjectModeEnum::ALWAYS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IntegrationEmailFiltersSubjectModeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IntegrationEmailFiltersSubjectModeEnum::MATCH => "match",
            IntegrationEmailFiltersSubjectModeEnum::NO_MATCH => "no-match",
            IntegrationEmailFiltersSubjectModeEnum::ALWAYS => "always",
            IntegrationEmailFiltersSubjectModeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IntegrationEmailFiltersSubjectModeEnum {
    fn default() -> Self {
        IntegrationEmailFiltersSubjectModeEnum::MATCH
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IntegrationEmailFiltersBodyModeEnum {
    #[serde(rename = "match")]
    MATCH,
    #[serde(rename = "no-match")]
    NO_MATCH,
    #[serde(rename = "always")]
    ALWAYS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IntegrationEmailFiltersBodyModeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IntegrationEmailFiltersBodyModeEnum::MATCH => write!(f, "match"),
            IntegrationEmailFiltersBodyModeEnum::NO_MATCH => write!(f, "no-match"),
            IntegrationEmailFiltersBodyModeEnum::ALWAYS => write!(f, "always"),
            IntegrationEmailFiltersBodyModeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IntegrationEmailFiltersBodyModeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "match" => Ok(IntegrationEmailFiltersBodyModeEnum::MATCH),
            "no-match" => Ok(IntegrationEmailFiltersBodyModeEnum::NO_MATCH),
            "always" => Ok(IntegrationEmailFiltersBodyModeEnum::ALWAYS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IntegrationEmailFiltersBodyModeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IntegrationEmailFiltersBodyModeEnum::MATCH => "match",
            IntegrationEmailFiltersBodyModeEnum::NO_MATCH => "no-match",
            IntegrationEmailFiltersBodyModeEnum::ALWAYS => "always",
            IntegrationEmailFiltersBodyModeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IntegrationEmailFiltersBodyModeEnum {
    fn default() -> Self {
        IntegrationEmailFiltersBodyModeEnum::MATCH
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IntegrationEmailFiltersFromEmailModeEnum {
    #[serde(rename = "match")]
    MATCH,
    #[serde(rename = "no-match")]
    NO_MATCH,
    #[serde(rename = "always")]
    ALWAYS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IntegrationEmailFiltersFromEmailModeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IntegrationEmailFiltersFromEmailModeEnum::MATCH => write!(f, "match"),
            IntegrationEmailFiltersFromEmailModeEnum::NO_MATCH => write!(f, "no-match"),
            IntegrationEmailFiltersFromEmailModeEnum::ALWAYS => write!(f, "always"),
            IntegrationEmailFiltersFromEmailModeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IntegrationEmailFiltersFromEmailModeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "match" => Ok(IntegrationEmailFiltersFromEmailModeEnum::MATCH),
            "no-match" => Ok(IntegrationEmailFiltersFromEmailModeEnum::NO_MATCH),
            "always" => Ok(IntegrationEmailFiltersFromEmailModeEnum::ALWAYS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IntegrationEmailFiltersFromEmailModeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IntegrationEmailFiltersFromEmailModeEnum::MATCH => "match",
            IntegrationEmailFiltersFromEmailModeEnum::NO_MATCH => "no-match",
            IntegrationEmailFiltersFromEmailModeEnum::ALWAYS => "always",
            IntegrationEmailFiltersFromEmailModeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IntegrationEmailFiltersFromEmailModeEnum {
    fn default() -> Self {
        IntegrationEmailFiltersFromEmailModeEnum::MATCH
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct IntegrationReference {
    /// The label of the tag.
    #[serde(default = "IntegrationReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: IntegrationReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for IntegrationReference {
    fn default() -> Self {
        Self {
            label: String::from("IntegrationReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl IntegrationReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("IntegrationReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("integration_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum IntegrationReferenceTypeEnum {
    #[serde(rename = "aws_cloudwatch_inbound_integration_reference")]
    AWS_CLOUDWATCH_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "cloudkick_inbound_integration_reference")]
    CLOUDKICK_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "event_transformer_api_inbound_integration_reference")]
    EVENT_TRANSFORMER_API_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "generic_email_inbound_integration_reference")]
    GENERIC_EMAIL_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "generic_events_api_inbound_integration_reference")]
    GENERIC_EVENTS_API_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "keynote_inbound_integration_reference")]
    KEYNOTE_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "nagios_inbound_integration_reference")]
    NAGIOS_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "pingdom_inbound_integration_reference")]
    PINGDOM_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "sql_monitor_inbound_integration_reference")]
    SQL_MONITOR_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "events_api_v2_inbound_integration_reference")]
    EVENTS_API_V2_INBOUND_INTEGRATION_REFERENCE,
    #[serde(rename = "inbound_integration_reference")]
    INBOUND_INTEGRATION_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for IntegrationReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            IntegrationReferenceTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION_REFERENCE => write!(f, "aws_cloudwatch_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::CLOUDKICK_INBOUND_INTEGRATION_REFERENCE => write!(f, "cloudkick_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::EVENT_TRANSFORMER_API_INBOUND_INTEGRATION_REFERENCE => write!(f, "event_transformer_api_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::GENERIC_EMAIL_INBOUND_INTEGRATION_REFERENCE => write!(f, "generic_email_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::GENERIC_EVENTS_API_INBOUND_INTEGRATION_REFERENCE => write!(f, "generic_events_api_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::KEYNOTE_INBOUND_INTEGRATION_REFERENCE => write!(f, "keynote_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::NAGIOS_INBOUND_INTEGRATION_REFERENCE => write!(f, "nagios_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::PINGDOM_INBOUND_INTEGRATION_REFERENCE => write!(f, "pingdom_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::SQL_MONITOR_INBOUND_INTEGRATION_REFERENCE => write!(f, "sql_monitor_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::EVENTS_API_V2_INBOUND_INTEGRATION_REFERENCE => write!(f, "events_api_v2_inbound_integration_reference"),
            IntegrationReferenceTypeEnum::INBOUND_INTEGRATION_REFERENCE => write!(f, "inbound_integration_reference"),
            IntegrationReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for IntegrationReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "aws_cloudwatch_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION_REFERENCE),
            "cloudkick_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::CLOUDKICK_INBOUND_INTEGRATION_REFERENCE),
            "event_transformer_api_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::EVENT_TRANSFORMER_API_INBOUND_INTEGRATION_REFERENCE),
            "generic_email_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::GENERIC_EMAIL_INBOUND_INTEGRATION_REFERENCE),
            "generic_events_api_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::GENERIC_EVENTS_API_INBOUND_INTEGRATION_REFERENCE),
            "keynote_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::KEYNOTE_INBOUND_INTEGRATION_REFERENCE),
            "nagios_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::NAGIOS_INBOUND_INTEGRATION_REFERENCE),
            "pingdom_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::PINGDOM_INBOUND_INTEGRATION_REFERENCE),
            "sql_monitor_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::SQL_MONITOR_INBOUND_INTEGRATION_REFERENCE),
            "events_api_v2_inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::EVENTS_API_V2_INBOUND_INTEGRATION_REFERENCE),
            "inbound_integration_reference" => Ok(IntegrationReferenceTypeEnum::INBOUND_INTEGRATION_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for IntegrationReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            IntegrationReferenceTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION_REFERENCE => "aws_cloudwatch_inbound_integration_reference",
            IntegrationReferenceTypeEnum::CLOUDKICK_INBOUND_INTEGRATION_REFERENCE => "cloudkick_inbound_integration_reference",
            IntegrationReferenceTypeEnum::EVENT_TRANSFORMER_API_INBOUND_INTEGRATION_REFERENCE => "event_transformer_api_inbound_integration_reference",
            IntegrationReferenceTypeEnum::GENERIC_EMAIL_INBOUND_INTEGRATION_REFERENCE => "generic_email_inbound_integration_reference",
            IntegrationReferenceTypeEnum::GENERIC_EVENTS_API_INBOUND_INTEGRATION_REFERENCE => "generic_events_api_inbound_integration_reference",
            IntegrationReferenceTypeEnum::KEYNOTE_INBOUND_INTEGRATION_REFERENCE => "keynote_inbound_integration_reference",
            IntegrationReferenceTypeEnum::NAGIOS_INBOUND_INTEGRATION_REFERENCE => "nagios_inbound_integration_reference",
            IntegrationReferenceTypeEnum::PINGDOM_INBOUND_INTEGRATION_REFERENCE => "pingdom_inbound_integration_reference",
            IntegrationReferenceTypeEnum::SQL_MONITOR_INBOUND_INTEGRATION_REFERENCE => "sql_monitor_inbound_integration_reference",
            IntegrationReferenceTypeEnum::EVENTS_API_V2_INBOUND_INTEGRATION_REFERENCE => "events_api_v2_inbound_integration_reference",
            IntegrationReferenceTypeEnum::INBOUND_INTEGRATION_REFERENCE => "inbound_integration_reference",
            IntegrationReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for IntegrationReferenceTypeEnum {
    fn default() -> Self {
        IntegrationReferenceTypeEnum::AWS_CLOUDWATCH_INBOUND_INTEGRATION_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateServiceIntegration {
    pub integration: Integration,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct LiveListResponse {
    /// Echoes limit pagination property.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<isize>,
    /// Indicates if there are additional records to return
    #[serde(skip_serializing_if = "Option::is_none")]
    pub more: Option<bool>,
}

/// The parameters to update.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct LogEntriesidchannelChannel {
    /// New channel details
    #[serde(skip_serializing_if = "String::is_empty")]
    pub details: String,
    /// Channel type. Cannot be changed and must match the present value.
    #[serde(rename = "type")]
    pub _type: LogEntriesidchannelChannelTypeEnum,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum LogEntriesidchannelChannelTypeEnum {
    #[serde(rename = "web_trigger")]
    WEB_TRIGGER,
    #[serde(rename = "mobile")]
    MOBILE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for LogEntriesidchannelChannelTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            LogEntriesidchannelChannelTypeEnum::WEB_TRIGGER => write!(f, "web_trigger"),
            LogEntriesidchannelChannelTypeEnum::MOBILE => write!(f, "mobile"),
            LogEntriesidchannelChannelTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for LogEntriesidchannelChannelTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "web_trigger" => Ok(LogEntriesidchannelChannelTypeEnum::WEB_TRIGGER),
            "mobile" => Ok(LogEntriesidchannelChannelTypeEnum::MOBILE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for LogEntriesidchannelChannelTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            LogEntriesidchannelChannelTypeEnum::WEB_TRIGGER => "web_trigger",
            LogEntriesidchannelChannelTypeEnum::MOBILE => "mobile",
            LogEntriesidchannelChannelTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for LogEntriesidchannelChannelTypeEnum {
    fn default() -> Self {
        LogEntriesidchannelChannelTypeEnum::WEB_TRIGGER
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct LogEntry {
    /// The label of the tag.
    #[serde(default = "LogEntry::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: LogEntryTypeEnum,
    /// Time at which the log entry was created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel: Option<Channel>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent: Option<AgentReference>,
    /// Optional field containing a note, if one was included with the log entry.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub note: Option<String>,
    /// Contexts to be included with the trigger such as links to graphs or images.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contexts: Option<Vec<Context>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service: Option<ServiceReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<UserReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<IncidentReference>,
    /// Will consist of references unless included
    #[serde(skip_serializing_if = "Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_details: Option<LogEntryEventDetails>,
}

#[allow(clippy::derivable_impls)]
impl Default for LogEntry {
    fn default() -> Self {
        Self {
            label: String::from("LogEntry"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            created_at: Default::default(),
            channel: Default::default(),
            agent: Default::default(),
            note: Default::default(),
            contexts: Default::default(),
            service: Default::default(),
            user: Default::default(),
            incident: Default::default(),
            teams: Default::default(),
            event_details: Default::default(),
        }
    }
}

impl LogEntry {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("LogEntry")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("log_entry")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum LogEntryTypeEnum {
    #[serde(rename = "acknowledge_log_entry")]
    ACKNOWLEDGE_LOG_ENTRY,
    #[serde(rename = "annotate_log_entry")]
    ANNOTATE_LOG_ENTRY,
    #[serde(rename = "assign_log_entry")]
    ASSIGN_LOG_ENTRY,
    #[serde(rename = "escalate_log_entry")]
    ESCALATE_LOG_ENTRY,
    #[serde(rename = "exhaust_escalation_path_log_entry")]
    EXHAUST_ESCALATION_PATH_LOG_ENTRY,
    #[serde(rename = "notify_log_entry")]
    NOTIFY_LOG_ENTRY,
    #[serde(rename = "reach_trigger_limit_log_entry")]
    REACH_TRIGGER_LIMIT_LOG_ENTRY,
    #[serde(rename = "repeat_escalation_path_log_entry")]
    REPEAT_ESCALATION_PATH_LOG_ENTRY,
    #[serde(rename = "resolve_log_entry")]
    RESOLVE_LOG_ENTRY,
    #[serde(rename = "snooze_log_entry")]
    SNOOZE_LOG_ENTRY,
    #[serde(rename = "trigger_log_entry")]
    TRIGGER_LOG_ENTRY,
    #[serde(rename = "unacknowledge_log_entry")]
    UNACKNOWLEDGE_LOG_ENTRY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for LogEntryTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            LogEntryTypeEnum::ACKNOWLEDGE_LOG_ENTRY => write!(f, "acknowledge_log_entry"),
            LogEntryTypeEnum::ANNOTATE_LOG_ENTRY => write!(f, "annotate_log_entry"),
            LogEntryTypeEnum::ASSIGN_LOG_ENTRY => write!(f, "assign_log_entry"),
            LogEntryTypeEnum::ESCALATE_LOG_ENTRY => write!(f, "escalate_log_entry"),
            LogEntryTypeEnum::EXHAUST_ESCALATION_PATH_LOG_ENTRY => write!(f, "exhaust_escalation_path_log_entry"),
            LogEntryTypeEnum::NOTIFY_LOG_ENTRY => write!(f, "notify_log_entry"),
            LogEntryTypeEnum::REACH_TRIGGER_LIMIT_LOG_ENTRY => write!(f, "reach_trigger_limit_log_entry"),
            LogEntryTypeEnum::REPEAT_ESCALATION_PATH_LOG_ENTRY => write!(f, "repeat_escalation_path_log_entry"),
            LogEntryTypeEnum::RESOLVE_LOG_ENTRY => write!(f, "resolve_log_entry"),
            LogEntryTypeEnum::SNOOZE_LOG_ENTRY => write!(f, "snooze_log_entry"),
            LogEntryTypeEnum::TRIGGER_LOG_ENTRY => write!(f, "trigger_log_entry"),
            LogEntryTypeEnum::UNACKNOWLEDGE_LOG_ENTRY => write!(f, "unacknowledge_log_entry"),
            LogEntryTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for LogEntryTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "acknowledge_log_entry" => Ok(LogEntryTypeEnum::ACKNOWLEDGE_LOG_ENTRY),
            "annotate_log_entry" => Ok(LogEntryTypeEnum::ANNOTATE_LOG_ENTRY),
            "assign_log_entry" => Ok(LogEntryTypeEnum::ASSIGN_LOG_ENTRY),
            "escalate_log_entry" => Ok(LogEntryTypeEnum::ESCALATE_LOG_ENTRY),
            "exhaust_escalation_path_log_entry" => Ok(LogEntryTypeEnum::EXHAUST_ESCALATION_PATH_LOG_ENTRY),
            "notify_log_entry" => Ok(LogEntryTypeEnum::NOTIFY_LOG_ENTRY),
            "reach_trigger_limit_log_entry" => Ok(LogEntryTypeEnum::REACH_TRIGGER_LIMIT_LOG_ENTRY),
            "repeat_escalation_path_log_entry" => Ok(LogEntryTypeEnum::REPEAT_ESCALATION_PATH_LOG_ENTRY),
            "resolve_log_entry" => Ok(LogEntryTypeEnum::RESOLVE_LOG_ENTRY),
            "snooze_log_entry" => Ok(LogEntryTypeEnum::SNOOZE_LOG_ENTRY),
            "trigger_log_entry" => Ok(LogEntryTypeEnum::TRIGGER_LOG_ENTRY),
            "unacknowledge_log_entry" => Ok(LogEntryTypeEnum::UNACKNOWLEDGE_LOG_ENTRY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for LogEntryTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            LogEntryTypeEnum::ACKNOWLEDGE_LOG_ENTRY => "acknowledge_log_entry",
            LogEntryTypeEnum::ANNOTATE_LOG_ENTRY => "annotate_log_entry",
            LogEntryTypeEnum::ASSIGN_LOG_ENTRY => "assign_log_entry",
            LogEntryTypeEnum::ESCALATE_LOG_ENTRY => "escalate_log_entry",
            LogEntryTypeEnum::EXHAUST_ESCALATION_PATH_LOG_ENTRY => "exhaust_escalation_path_log_entry",
            LogEntryTypeEnum::NOTIFY_LOG_ENTRY => "notify_log_entry",
            LogEntryTypeEnum::REACH_TRIGGER_LIMIT_LOG_ENTRY => "reach_trigger_limit_log_entry",
            LogEntryTypeEnum::REPEAT_ESCALATION_PATH_LOG_ENTRY => "repeat_escalation_path_log_entry",
            LogEntryTypeEnum::RESOLVE_LOG_ENTRY => "resolve_log_entry",
            LogEntryTypeEnum::SNOOZE_LOG_ENTRY => "snooze_log_entry",
            LogEntryTypeEnum::TRIGGER_LOG_ENTRY => "trigger_log_entry",
            LogEntryTypeEnum::UNACKNOWLEDGE_LOG_ENTRY => "unacknowledge_log_entry",
            LogEntryTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for LogEntryTypeEnum {
    fn default() -> Self {
        LogEntryTypeEnum::ACKNOWLEDGE_LOG_ENTRY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct LogEntryEventDetails {
    /// Additional details about the event.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct LogEntryReference {
    /// The label of the tag.
    #[serde(default = "LogEntryReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: LogEntryReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for LogEntryReference {
    fn default() -> Self {
        Self {
            label: String::from("LogEntryReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl LogEntryReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("LogEntryReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("log_entry_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum LogEntryReferenceTypeEnum {
    #[serde(rename = "acknowledge_log_entry_reference")]
    ACKNOWLEDGE_LOG_ENTRY_REFERENCE,
    #[serde(rename = "annotate_log_entry_reference")]
    ANNOTATE_LOG_ENTRY_REFERENCE,
    #[serde(rename = "assign_log_entry_reference")]
    ASSIGN_LOG_ENTRY_REFERENCE,
    #[serde(rename = "escalate_log_entry_reference")]
    ESCALATE_LOG_ENTRY_REFERENCE,
    #[serde(rename = "exhaust_escalation_path_log_entry_reference")]
    EXHAUST_ESCALATION_PATH_LOG_ENTRY_REFERENCE,
    #[serde(rename = "notify_log_entry_reference")]
    NOTIFY_LOG_ENTRY_REFERENCE,
    #[serde(rename = "reach_trigger_limit_log_entry_reference")]
    REACH_TRIGGER_LIMIT_LOG_ENTRY_REFERENCE,
    #[serde(rename = "repeat_escalation_path_log_entry_reference")]
    REPEAT_ESCALATION_PATH_LOG_ENTRY_REFERENCE,
    #[serde(rename = "resolve_log_entry_reference")]
    RESOLVE_LOG_ENTRY_REFERENCE,
    #[serde(rename = "snooze_log_entry_reference")]
    SNOOZE_LOG_ENTRY_REFERENCE,
    #[serde(rename = "trigger_log_entry_reference")]
    TRIGGER_LOG_ENTRY_REFERENCE,
    #[serde(rename = "unacknowledge_log_entry_reference")]
    UNACKNOWLEDGE_LOG_ENTRY_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for LogEntryReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            LogEntryReferenceTypeEnum::ACKNOWLEDGE_LOG_ENTRY_REFERENCE => write!(f, "acknowledge_log_entry_reference"),
            LogEntryReferenceTypeEnum::ANNOTATE_LOG_ENTRY_REFERENCE => write!(f, "annotate_log_entry_reference"),
            LogEntryReferenceTypeEnum::ASSIGN_LOG_ENTRY_REFERENCE => write!(f, "assign_log_entry_reference"),
            LogEntryReferenceTypeEnum::ESCALATE_LOG_ENTRY_REFERENCE => write!(f, "escalate_log_entry_reference"),
            LogEntryReferenceTypeEnum::EXHAUST_ESCALATION_PATH_LOG_ENTRY_REFERENCE => write!(f, "exhaust_escalation_path_log_entry_reference"),
            LogEntryReferenceTypeEnum::NOTIFY_LOG_ENTRY_REFERENCE => write!(f, "notify_log_entry_reference"),
            LogEntryReferenceTypeEnum::REACH_TRIGGER_LIMIT_LOG_ENTRY_REFERENCE => write!(f, "reach_trigger_limit_log_entry_reference"),
            LogEntryReferenceTypeEnum::REPEAT_ESCALATION_PATH_LOG_ENTRY_REFERENCE => write!(f, "repeat_escalation_path_log_entry_reference"),
            LogEntryReferenceTypeEnum::RESOLVE_LOG_ENTRY_REFERENCE => write!(f, "resolve_log_entry_reference"),
            LogEntryReferenceTypeEnum::SNOOZE_LOG_ENTRY_REFERENCE => write!(f, "snooze_log_entry_reference"),
            LogEntryReferenceTypeEnum::TRIGGER_LOG_ENTRY_REFERENCE => write!(f, "trigger_log_entry_reference"),
            LogEntryReferenceTypeEnum::UNACKNOWLEDGE_LOG_ENTRY_REFERENCE => write!(f, "unacknowledge_log_entry_reference"),
            LogEntryReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for LogEntryReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "acknowledge_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::ACKNOWLEDGE_LOG_ENTRY_REFERENCE),
            "annotate_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::ANNOTATE_LOG_ENTRY_REFERENCE),
            "assign_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::ASSIGN_LOG_ENTRY_REFERENCE),
            "escalate_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::ESCALATE_LOG_ENTRY_REFERENCE),
            "exhaust_escalation_path_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::EXHAUST_ESCALATION_PATH_LOG_ENTRY_REFERENCE),
            "notify_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::NOTIFY_LOG_ENTRY_REFERENCE),
            "reach_trigger_limit_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::REACH_TRIGGER_LIMIT_LOG_ENTRY_REFERENCE),
            "repeat_escalation_path_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::REPEAT_ESCALATION_PATH_LOG_ENTRY_REFERENCE),
            "resolve_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::RESOLVE_LOG_ENTRY_REFERENCE),
            "snooze_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::SNOOZE_LOG_ENTRY_REFERENCE),
            "trigger_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::TRIGGER_LOG_ENTRY_REFERENCE),
            "unacknowledge_log_entry_reference" => Ok(LogEntryReferenceTypeEnum::UNACKNOWLEDGE_LOG_ENTRY_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for LogEntryReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            LogEntryReferenceTypeEnum::ACKNOWLEDGE_LOG_ENTRY_REFERENCE => "acknowledge_log_entry_reference",
            LogEntryReferenceTypeEnum::ANNOTATE_LOG_ENTRY_REFERENCE => "annotate_log_entry_reference",
            LogEntryReferenceTypeEnum::ASSIGN_LOG_ENTRY_REFERENCE => "assign_log_entry_reference",
            LogEntryReferenceTypeEnum::ESCALATE_LOG_ENTRY_REFERENCE => "escalate_log_entry_reference",
            LogEntryReferenceTypeEnum::EXHAUST_ESCALATION_PATH_LOG_ENTRY_REFERENCE => "exhaust_escalation_path_log_entry_reference",
            LogEntryReferenceTypeEnum::NOTIFY_LOG_ENTRY_REFERENCE => "notify_log_entry_reference",
            LogEntryReferenceTypeEnum::REACH_TRIGGER_LIMIT_LOG_ENTRY_REFERENCE => "reach_trigger_limit_log_entry_reference",
            LogEntryReferenceTypeEnum::REPEAT_ESCALATION_PATH_LOG_ENTRY_REFERENCE => "repeat_escalation_path_log_entry_reference",
            LogEntryReferenceTypeEnum::RESOLVE_LOG_ENTRY_REFERENCE => "resolve_log_entry_reference",
            LogEntryReferenceTypeEnum::SNOOZE_LOG_ENTRY_REFERENCE => "snooze_log_entry_reference",
            LogEntryReferenceTypeEnum::TRIGGER_LOG_ENTRY_REFERENCE => "trigger_log_entry_reference",
            LogEntryReferenceTypeEnum::UNACKNOWLEDGE_LOG_ENTRY_REFERENCE => "unacknowledge_log_entry_reference",
            LogEntryReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for LogEntryReferenceTypeEnum {
    fn default() -> Self {
        LogEntryReferenceTypeEnum::ACKNOWLEDGE_LOG_ENTRY_REFERENCE
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct MaintenanceWindow {
    /// The label of the tag.
    #[serde(default = "MaintenanceWindow::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: MaintenanceWindowTypeEnum,
    /// The order in which the maintenance window was created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sequence_number: Option<isize>,
    /// This maintenance window's start time. This is when the services will stop creating incidents. If this date is in the past, it will be updated to be the current time.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_time: Option<chrono::DateTime<chrono::Utc>>,
    /// This maintenance window's end time. This is when the services will start creating incidents again. This date must be in the future and after the `start_time`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_time: Option<chrono::DateTime<chrono::Utc>>,
    /// A description for this maintenance window.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_by: Option<UserReference>,
    pub services: Vec<ServiceReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
}

#[allow(clippy::derivable_impls)]
impl Default for MaintenanceWindow {
    fn default() -> Self {
        Self {
            label: String::from("MaintenanceWindow"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            sequence_number: Default::default(),
            start_time: Default::default(),
            end_time: Default::default(),
            description: Default::default(),
            created_by: Default::default(),
            services: Default::default(),
            teams: Default::default(),
        }
    }
}

impl MaintenanceWindow {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("MaintenanceWindow")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("maintenance_window")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum MaintenanceWindowTypeEnum {
    #[serde(rename = "maintenance_window")]
    MAINTENANCE_WINDOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for MaintenanceWindowTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            MaintenanceWindowTypeEnum::MAINTENANCE_WINDOW => write!(f, "maintenance_window"),
            MaintenanceWindowTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for MaintenanceWindowTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "maintenance_window" => Ok(MaintenanceWindowTypeEnum::MAINTENANCE_WINDOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for MaintenanceWindowTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            MaintenanceWindowTypeEnum::MAINTENANCE_WINDOW => "maintenance_window",
            MaintenanceWindowTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for MaintenanceWindowTypeEnum {
    fn default() -> Self {
        MaintenanceWindowTypeEnum::MAINTENANCE_WINDOW
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct MaintenanceWindowReference {
    /// The label of the tag.
    #[serde(default = "MaintenanceWindowReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: MaintenanceWindowReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for MaintenanceWindowReference {
    fn default() -> Self {
        Self {
            label: String::from("MaintenanceWindowReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl MaintenanceWindowReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("MaintenanceWindowReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("maintenance_window_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum MaintenanceWindowReferenceTypeEnum {
    #[serde(rename = "maintenance_window_reference")]
    MAINTENANCE_WINDOW_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for MaintenanceWindowReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            MaintenanceWindowReferenceTypeEnum::MAINTENANCE_WINDOW_REFERENCE => write!(f, "maintenance_window_reference"),
            MaintenanceWindowReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for MaintenanceWindowReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "maintenance_window_reference" => Ok(MaintenanceWindowReferenceTypeEnum::MAINTENANCE_WINDOW_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for MaintenanceWindowReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            MaintenanceWindowReferenceTypeEnum::MAINTENANCE_WINDOW_REFERENCE => "maintenance_window_reference",
            MaintenanceWindowReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for MaintenanceWindowReferenceTypeEnum {
    fn default() -> Self {
        MaintenanceWindowReferenceTypeEnum::MAINTENANCE_WINDOW_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateMaintenanceWindow {
    pub maintenance_window: MaintenanceWindow,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateMaintenanceWindow {
    pub maintenance_window: MaintenanceWindow,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct MatchPredicate {
    #[serde(rename = "type")]
    pub _type: MatchPredicateTypeEnum,
    /// Required if the type is `contains`, `exactly` or `regex`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub matcher: Option<String>,
    /// The email field that will attempt to use the matcher expression. Required if the type is `contains`, `exactly` or `regex`.
    pub part: MatchPredicatePartEnum,
    /// Additional matchers to be run. Must be not empty if the type is `all`, `any`, or `not`.
    pub children: Vec<MatchPredicate>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum MatchPredicateTypeEnum {
    #[serde(rename = "all")]
    ALL,
    #[serde(rename = "any")]
    ANY,
    #[serde(rename = "not")]
    NOT,
    #[serde(rename = "contains")]
    CONTAINS,
    #[serde(rename = "exactly")]
    EXACTLY,
    #[serde(rename = "regex")]
    REGEX,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for MatchPredicateTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            MatchPredicateTypeEnum::ALL => write!(f, "all"),
            MatchPredicateTypeEnum::ANY => write!(f, "any"),
            MatchPredicateTypeEnum::NOT => write!(f, "not"),
            MatchPredicateTypeEnum::CONTAINS => write!(f, "contains"),
            MatchPredicateTypeEnum::EXACTLY => write!(f, "exactly"),
            MatchPredicateTypeEnum::REGEX => write!(f, "regex"),
            MatchPredicateTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for MatchPredicateTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "all" => Ok(MatchPredicateTypeEnum::ALL),
            "any" => Ok(MatchPredicateTypeEnum::ANY),
            "not" => Ok(MatchPredicateTypeEnum::NOT),
            "contains" => Ok(MatchPredicateTypeEnum::CONTAINS),
            "exactly" => Ok(MatchPredicateTypeEnum::EXACTLY),
            "regex" => Ok(MatchPredicateTypeEnum::REGEX),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for MatchPredicateTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            MatchPredicateTypeEnum::ALL => "all",
            MatchPredicateTypeEnum::ANY => "any",
            MatchPredicateTypeEnum::NOT => "not",
            MatchPredicateTypeEnum::CONTAINS => "contains",
            MatchPredicateTypeEnum::EXACTLY => "exactly",
            MatchPredicateTypeEnum::REGEX => "regex",
            MatchPredicateTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for MatchPredicateTypeEnum {
    fn default() -> Self {
        MatchPredicateTypeEnum::ALL
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum MatchPredicatePartEnum {
    #[serde(rename = "body")]
    BODY,
    #[serde(rename = "subject")]
    SUBJECT,
    #[serde(rename = "from_addresses")]
    FROM_ADDRESSES,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for MatchPredicatePartEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            MatchPredicatePartEnum::BODY => write!(f, "body"),
            MatchPredicatePartEnum::SUBJECT => write!(f, "subject"),
            MatchPredicatePartEnum::FROM_ADDRESSES => write!(f, "from_addresses"),
            MatchPredicatePartEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for MatchPredicatePartEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "body" => Ok(MatchPredicatePartEnum::BODY),
            "subject" => Ok(MatchPredicatePartEnum::SUBJECT),
            "from_addresses" => Ok(MatchPredicatePartEnum::FROM_ADDRESSES),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for MatchPredicatePartEnum {
    fn as_ref(&self) -> &str {
        match self {
            MatchPredicatePartEnum::BODY => "body",
            MatchPredicatePartEnum::SUBJECT => "subject",
            MatchPredicatePartEnum::FROM_ADDRESSES => "from_addresses",
            MatchPredicatePartEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for MatchPredicatePartEnum {
    fn default() -> Self {
        MatchPredicatePartEnum::BODY
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ModelOverride {
    /// The label of the tag.
    #[serde(default = "ModelOverride::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default = "ModelOverride::_type_default")]
    pub _type: String,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The start date and time for the override.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<chrono::DateTime<chrono::Utc>>,
    /// The end date and time for the override.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<chrono::DateTime<chrono::Utc>>,
    pub user: UserReference,
}

#[allow(clippy::derivable_impls)]
impl Default for ModelOverride {
    fn default() -> Self {
        Self {
            label: String::from("Override"),
            html_url: Default::default(),
            _self: Default::default(),
            _type: String::from("override"),
            summary: Default::default(),
            id: Default::default(),
            start: Default::default(),
            end: Default::default(),
            user: Default::default(),
        }
    }
}

impl ModelOverride {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Override")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("override")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Notification {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of notification.
    #[serde(rename = "type")]
    pub _type: NotificationTypeEnum,
    /// The time at which the notification was sent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The address where the notification was sent. This will be null for notification type `push_notification`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<UserReference>,
    /// The address of the conference bridge
    #[serde(rename = "conferenceAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conference_address: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationTypeEnum {
    #[serde(rename = "sms_notification")]
    SMS_NOTIFICATION,
    #[serde(rename = "email_notification")]
    EMAIL_NOTIFICATION,
    #[serde(rename = "phone_notification")]
    PHONE_NOTIFICATION,
    #[serde(rename = "push_notification")]
    PUSH_NOTIFICATION,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            NotificationTypeEnum::SMS_NOTIFICATION => write!(f, "sms_notification"),
            NotificationTypeEnum::EMAIL_NOTIFICATION => write!(f, "email_notification"),
            NotificationTypeEnum::PHONE_NOTIFICATION => write!(f, "phone_notification"),
            NotificationTypeEnum::PUSH_NOTIFICATION => write!(f, "push_notification"),
            NotificationTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "sms_notification" => Ok(NotificationTypeEnum::SMS_NOTIFICATION),
            "email_notification" => Ok(NotificationTypeEnum::EMAIL_NOTIFICATION),
            "phone_notification" => Ok(NotificationTypeEnum::PHONE_NOTIFICATION),
            "push_notification" => Ok(NotificationTypeEnum::PUSH_NOTIFICATION),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            NotificationTypeEnum::SMS_NOTIFICATION => "sms_notification",
            NotificationTypeEnum::EMAIL_NOTIFICATION => "email_notification",
            NotificationTypeEnum::PHONE_NOTIFICATION => "phone_notification",
            NotificationTypeEnum::PUSH_NOTIFICATION => "push_notification",
            NotificationTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationTypeEnum {
    fn default() -> Self {
        NotificationTypeEnum::SMS_NOTIFICATION
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct NotificationRule {
    /// The label of the tag.
    #[serde(default = "NotificationRule::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: NotificationRuleTypeEnum,
    /// The delay before firing the rule, in minutes.
    pub start_delay_in_minutes: usize,
    pub contact_method: ContactMethodReference,
    /// Which incident urgency this rule is used for. Account must have the `urgencies` ability to have a low urgency notification rule.
    pub urgency: NotificationRuleUrgencyEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for NotificationRule {
    fn default() -> Self {
        Self {
            label: String::from("NotificationRule"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            start_delay_in_minutes: Default::default(),
            contact_method: Default::default(),
            urgency: Default::default(),
        }
    }
}

impl NotificationRule {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("NotificationRule")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("notification_rule")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationRuleTypeEnum {
    #[serde(rename = "assignment_notification_rule")]
    ASSIGNMENT_NOTIFICATION_RULE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationRuleTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            NotificationRuleTypeEnum::ASSIGNMENT_NOTIFICATION_RULE => write!(f, "assignment_notification_rule"),
            NotificationRuleTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationRuleTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "assignment_notification_rule" => Ok(NotificationRuleTypeEnum::ASSIGNMENT_NOTIFICATION_RULE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationRuleTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            NotificationRuleTypeEnum::ASSIGNMENT_NOTIFICATION_RULE => "assignment_notification_rule",
            NotificationRuleTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationRuleTypeEnum {
    fn default() -> Self {
        NotificationRuleTypeEnum::ASSIGNMENT_NOTIFICATION_RULE
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationRuleUrgencyEnum {
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationRuleUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            NotificationRuleUrgencyEnum::HIGH => write!(f, "high"),
            NotificationRuleUrgencyEnum::LOW => write!(f, "low"),
            NotificationRuleUrgencyEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationRuleUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "high" => Ok(NotificationRuleUrgencyEnum::HIGH),
            "low" => Ok(NotificationRuleUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationRuleUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self {
            NotificationRuleUrgencyEnum::HIGH => "high",
            NotificationRuleUrgencyEnum::LOW => "low",
            NotificationRuleUrgencyEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationRuleUrgencyEnum {
    fn default() -> Self {
        NotificationRuleUrgencyEnum::HIGH
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct NotificationRuleReference {
    /// The label of the tag.
    #[serde(default = "NotificationRuleReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: NotificationRuleReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for NotificationRuleReference {
    fn default() -> Self {
        Self {
            label: String::from("NotificationRuleReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl NotificationRuleReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("NotificationRuleReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("notification_rule_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationRuleReferenceTypeEnum {
    #[serde(rename = "assignment_notification_rule_reference")]
    ASSIGNMENT_NOTIFICATION_RULE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationRuleReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            NotificationRuleReferenceTypeEnum::ASSIGNMENT_NOTIFICATION_RULE_REFERENCE => write!(f, "assignment_notification_rule_reference"),
            NotificationRuleReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationRuleReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "assignment_notification_rule_reference" => Ok(NotificationRuleReferenceTypeEnum::ASSIGNMENT_NOTIFICATION_RULE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationRuleReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            NotificationRuleReferenceTypeEnum::ASSIGNMENT_NOTIFICATION_RULE_REFERENCE => "assignment_notification_rule_reference",
            NotificationRuleReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationRuleReferenceTypeEnum {
    fn default() -> Self {
        NotificationRuleReferenceTypeEnum::ASSIGNMENT_NOTIFICATION_RULE_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateUserNotificationRule {
    pub notification_rule: NotificationRule,
}

/// A reference of a subscribable entity.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct NotificationSubscribable {
    /// The ID of the entity to subscribe to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribable_id: Option<String>,
    /// The type of the entity being subscribed to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribable_type: Option<NotificationSubscribableSubscribableTypeEnum>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationSubscribableSubscribableTypeEnum {
    #[serde(rename = "incident")]
    INCIDENT,
    #[serde(rename = "business_service")]
    BUSINESS_SERVICE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationSubscribableSubscribableTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            NotificationSubscribableSubscribableTypeEnum::INCIDENT => write!(f, "incident"),
            NotificationSubscribableSubscribableTypeEnum::BUSINESS_SERVICE => write!(f, "business_service"),
            NotificationSubscribableSubscribableTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationSubscribableSubscribableTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "incident" => Ok(NotificationSubscribableSubscribableTypeEnum::INCIDENT),
            "business_service" => Ok(NotificationSubscribableSubscribableTypeEnum::BUSINESS_SERVICE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationSubscribableSubscribableTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            NotificationSubscribableSubscribableTypeEnum::INCIDENT => "incident",
            NotificationSubscribableSubscribableTypeEnum::BUSINESS_SERVICE => "business_service",
            NotificationSubscribableSubscribableTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationSubscribableSubscribableTypeEnum {
    fn default() -> Self {
        NotificationSubscribableSubscribableTypeEnum::INCIDENT
    }
}

/// A reference of a subscriber entity.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct NotificationSubscriber {
    /// The ID of the entity being subscribed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscriber_id: Option<String>,
    /// The type of the entity being subscribed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscriber_type: Option<NotificationSubscriberSubscriberTypeEnum>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationSubscriberSubscriberTypeEnum {
    #[serde(rename = "user")]
    USER,
    #[serde(rename = "team")]
    TEAM,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationSubscriberSubscriberTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            NotificationSubscriberSubscriberTypeEnum::USER => write!(f, "user"),
            NotificationSubscriberSubscriberTypeEnum::TEAM => write!(f, "team"),
            NotificationSubscriberSubscriberTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationSubscriberSubscriberTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "user" => Ok(NotificationSubscriberSubscriberTypeEnum::USER),
            "team" => Ok(NotificationSubscriberSubscriberTypeEnum::TEAM),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationSubscriberSubscriberTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            NotificationSubscriberSubscriberTypeEnum::USER => "user",
            NotificationSubscriberSubscriberTypeEnum::TEAM => "team",
            NotificationSubscriberSubscriberTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationSubscriberSubscriberTypeEnum {
    fn default() -> Self {
        NotificationSubscriberSubscriberTypeEnum::USER
    }
}

/// A reference of a subscriber entity with additional subscription context.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct NotificationSubscriberWithContext {
    /// The ID of the entity being subscribed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscriber_id: Option<String>,
    /// The type of the entity being subscribed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscriber_type: Option<NotificationSubscriberWithContextSubscriberTypeEnum>,
    /// If this subcriber has an indirect subscription to this incident via another object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub has_indirect_subscription: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribed_via: Option<Vec<NotificationSubscriberWithContextSubscribedVia>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationSubscriberWithContextSubscriberTypeEnum {
    #[serde(rename = "user")]
    USER,
    #[serde(rename = "team")]
    TEAM,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationSubscriberWithContextSubscriberTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            NotificationSubscriberWithContextSubscriberTypeEnum::USER => write!(f, "user"),
            NotificationSubscriberWithContextSubscriberTypeEnum::TEAM => write!(f, "team"),
            NotificationSubscriberWithContextSubscriberTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationSubscriberWithContextSubscriberTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "user" => Ok(NotificationSubscriberWithContextSubscriberTypeEnum::USER),
            "team" => Ok(NotificationSubscriberWithContextSubscriberTypeEnum::TEAM),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationSubscriberWithContextSubscriberTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            NotificationSubscriberWithContextSubscriberTypeEnum::USER => "user",
            NotificationSubscriberWithContextSubscriberTypeEnum::TEAM => "team",
            NotificationSubscriberWithContextSubscriberTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationSubscriberWithContextSubscriberTypeEnum {
    fn default() -> Self {
        NotificationSubscriberWithContextSubscriberTypeEnum::USER
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct NotificationSubscriberWithContextSubscribedVia {
    /// The id of the object this subscriber is subscribed via
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of the object this subscriber is subscribed via
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// An object describing the relationship of a NotificationSubscriber and a NotificationSubscribable.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct NotificationSubscription {
    /// The ID of the entity being subscribed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscriber_id: Option<String>,
    /// The type of the entity being subscribed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscriber_type: Option<NotificationSubscriptionSubscriberTypeEnum>,
    /// The ID of the entity being subscribed to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribable_id: Option<String>,
    /// The type of the entity being subscribed to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribable_type: Option<NotificationSubscriptionSubscribableTypeEnum>,
    /// The ID of the account belonging to the subscriber entity
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationSubscriptionSubscriberTypeEnum {
    #[serde(rename = "user")]
    USER,
    #[serde(rename = "team")]
    TEAM,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationSubscriptionSubscriberTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            NotificationSubscriptionSubscriberTypeEnum::USER => write!(f, "user"),
            NotificationSubscriptionSubscriberTypeEnum::TEAM => write!(f, "team"),
            NotificationSubscriptionSubscriberTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationSubscriptionSubscriberTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "user" => Ok(NotificationSubscriptionSubscriberTypeEnum::USER),
            "team" => Ok(NotificationSubscriptionSubscriberTypeEnum::TEAM),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationSubscriptionSubscriberTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            NotificationSubscriptionSubscriberTypeEnum::USER => "user",
            NotificationSubscriptionSubscriberTypeEnum::TEAM => "team",
            NotificationSubscriptionSubscriberTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationSubscriptionSubscriberTypeEnum {
    fn default() -> Self {
        NotificationSubscriptionSubscriberTypeEnum::USER
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationSubscriptionSubscribableTypeEnum {
    #[serde(rename = "incident")]
    INCIDENT,
    #[serde(rename = "business_service")]
    BUSINESS_SERVICE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationSubscriptionSubscribableTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            NotificationSubscriptionSubscribableTypeEnum::INCIDENT => write!(f, "incident"),
            NotificationSubscriptionSubscribableTypeEnum::BUSINESS_SERVICE => write!(f, "business_service"),
            NotificationSubscriptionSubscribableTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationSubscriptionSubscribableTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "incident" => Ok(NotificationSubscriptionSubscribableTypeEnum::INCIDENT),
            "business_service" => Ok(NotificationSubscriptionSubscribableTypeEnum::BUSINESS_SERVICE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationSubscriptionSubscribableTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            NotificationSubscriptionSubscribableTypeEnum::INCIDENT => "incident",
            NotificationSubscriptionSubscribableTypeEnum::BUSINESS_SERVICE => "business_service",
            NotificationSubscriptionSubscribableTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationSubscriptionSubscribableTypeEnum {
    fn default() -> Self {
        NotificationSubscriptionSubscribableTypeEnum::INCIDENT
    }
}

/// An object describing the relationship of a NotificationSubscriber and a NotificationSubscribable with additional context on status of subscription attempt.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct NotificationSubscriptionWithContext {
    /// The ID of the entity being subscribed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscriber_id: Option<String>,
    /// The type of the entity being subscribed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscriber_type: Option<NotificationSubscriptionWithContextSubscriberTypeEnum>,
    /// The ID of the entity being subscribed to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribable_id: Option<String>,
    /// The type of the entity being subscribed to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribable_type: Option<NotificationSubscriptionWithContextSubscribableTypeEnum>,
    /// The type of the entity being subscribed to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_id: Option<String>,
    /// The resulting status of the subscription
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<NotificationSubscriptionWithContextResultEnum>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationSubscriptionWithContextSubscriberTypeEnum {
    #[serde(rename = "user")]
    USER,
    #[serde(rename = "team")]
    TEAM,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationSubscriptionWithContextSubscriberTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            NotificationSubscriptionWithContextSubscriberTypeEnum::USER => write!(f, "user"),
            NotificationSubscriptionWithContextSubscriberTypeEnum::TEAM => write!(f, "team"),
            NotificationSubscriptionWithContextSubscriberTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationSubscriptionWithContextSubscriberTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "user" => Ok(NotificationSubscriptionWithContextSubscriberTypeEnum::USER),
            "team" => Ok(NotificationSubscriptionWithContextSubscriberTypeEnum::TEAM),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationSubscriptionWithContextSubscriberTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            NotificationSubscriptionWithContextSubscriberTypeEnum::USER => "user",
            NotificationSubscriptionWithContextSubscriberTypeEnum::TEAM => "team",
            NotificationSubscriptionWithContextSubscriberTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationSubscriptionWithContextSubscriberTypeEnum {
    fn default() -> Self {
        NotificationSubscriptionWithContextSubscriberTypeEnum::USER
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationSubscriptionWithContextSubscribableTypeEnum {
    #[serde(rename = "incident")]
    INCIDENT,
    #[serde(rename = "business_service")]
    BUSINESS_SERVICE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationSubscriptionWithContextSubscribableTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            NotificationSubscriptionWithContextSubscribableTypeEnum::INCIDENT => write!(f, "incident"),
            NotificationSubscriptionWithContextSubscribableTypeEnum::BUSINESS_SERVICE => write!(f, "business_service"),
            NotificationSubscriptionWithContextSubscribableTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationSubscriptionWithContextSubscribableTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "incident" => Ok(NotificationSubscriptionWithContextSubscribableTypeEnum::INCIDENT),
            "business_service" => Ok(NotificationSubscriptionWithContextSubscribableTypeEnum::BUSINESS_SERVICE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationSubscriptionWithContextSubscribableTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            NotificationSubscriptionWithContextSubscribableTypeEnum::INCIDENT => "incident",
            NotificationSubscriptionWithContextSubscribableTypeEnum::BUSINESS_SERVICE => "business_service",
            NotificationSubscriptionWithContextSubscribableTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationSubscriptionWithContextSubscribableTypeEnum {
    fn default() -> Self {
        NotificationSubscriptionWithContextSubscribableTypeEnum::INCIDENT
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotificationSubscriptionWithContextResultEnum {
    #[serde(rename = "success")]
    SUCCESS,
    #[serde(rename = "duplicate")]
    DUPLICATE,
    #[serde(rename = "unauthorized")]
    UNAUTHORIZED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotificationSubscriptionWithContextResultEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            NotificationSubscriptionWithContextResultEnum::SUCCESS => write!(f, "success"),
            NotificationSubscriptionWithContextResultEnum::DUPLICATE => write!(f, "duplicate"),
            NotificationSubscriptionWithContextResultEnum::UNAUTHORIZED => write!(f, "unauthorized"),
            NotificationSubscriptionWithContextResultEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotificationSubscriptionWithContextResultEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "success" => Ok(NotificationSubscriptionWithContextResultEnum::SUCCESS),
            "duplicate" => Ok(NotificationSubscriptionWithContextResultEnum::DUPLICATE),
            "unauthorized" => Ok(NotificationSubscriptionWithContextResultEnum::UNAUTHORIZED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotificationSubscriptionWithContextResultEnum {
    fn as_ref(&self) -> &str {
        match self {
            NotificationSubscriptionWithContextResultEnum::SUCCESS => "success",
            NotificationSubscriptionWithContextResultEnum::DUPLICATE => "duplicate",
            NotificationSubscriptionWithContextResultEnum::UNAUTHORIZED => "unauthorized",
            NotificationSubscriptionWithContextResultEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotificationSubscriptionWithContextResultEnum {
    fn default() -> Self {
        NotificationSubscriptionWithContextResultEnum::SUCCESS
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct RemoveTeamNotificationSubscriptions {
    pub subscribables: Vec<NotificationSubscribable>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UnsubscribeUserNotificationSubscriptions {
    pub subscribables: Vec<NotificationSubscribable>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct NotifyLogEntry {
    #[serde(rename = "type")]
    pub _type: NotifyLogEntryTypeEnum,
    /// Time at which the log entry was created
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel: Option<Channel>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent: Option<AgentReference>,
    /// Optional field containing a note, if one was included with the log entry.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub note: Option<String>,
    /// Contexts to be included with the trigger such as links to graphs or images.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contexts: Option<Vec<Context>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service: Option<ServiceReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<UserReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<IncidentReference>,
    /// Will consist of references unless included
    #[serde(skip_serializing_if = "Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_details: Option<LogEntryEventDetails>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum NotifyLogEntryTypeEnum {
    #[serde(rename = "notify_log_entry")]
    NOTIFY_LOG_ENTRY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for NotifyLogEntryTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            NotifyLogEntryTypeEnum::NOTIFY_LOG_ENTRY => write!(f, "notify_log_entry"),
            NotifyLogEntryTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for NotifyLogEntryTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "notify_log_entry" => Ok(NotifyLogEntryTypeEnum::NOTIFY_LOG_ENTRY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for NotifyLogEntryTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            NotifyLogEntryTypeEnum::NOTIFY_LOG_ENTRY => "notify_log_entry",
            NotifyLogEntryTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for NotifyLogEntryTypeEnum {
    fn default() -> Self {
        NotifyLogEntryTypeEnum::NOTIFY_LOG_ENTRY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Oncall {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub escalation_policy: Option<EscalationPolicyReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<UserReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schedule: Option<ScheduleReference>,
    /// The escalation level for the on-call.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub escalation_level: Option<isize>,
    /// The start of the on-call. If `null`, the on-call is a permanent user on-call.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<chrono::DateTime<chrono::Utc>>,
    /// The end of the on-call. If `null`, the user does not go off-call.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateUserHandoffNotification {
    pub oncall_handoff_notification_rule: HandoffNotificationRule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Orchestration {
    /// ID of the Orchestration.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// Name of the Orchestration.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// A description of this Orchestration's purpose.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team: Option<OrchestrationTeam>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub integrations: Option<Vec<OrchestrationIntegrations>>,
    /// Number of different Service Orchestration being routed to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routes: Option<isize>,
    /// The date the Orchestration was created at.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_by: Option<OrchestrationCreatedBy>,
    /// The date the Orchestration was last updated.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated_by: Option<OrchestrationUpdatedBy>,
    /// Version of the Orchestration.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Reference to the user that has created the Orchestration.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationCreatedBy {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A string that determines the schema of the object
    #[serde(rename = "type")]
    #[serde(default = "OrchestrationCreatedBy::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for OrchestrationCreatedBy {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("orchestration_created_by"),
            _self: Default::default(),
        }
    }
}

impl OrchestrationCreatedBy {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("orchestration_created_by")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationIntegrations {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<OrchestrationParameters>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationParameters {
    /// Routing key that routes to this Orchestration
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_key: Option<String>,
    #[serde(rename = "type")]
    #[serde(default = "OrchestrationParameters::_type_default")]
    pub _type: String,
}

#[allow(clippy::derivable_impls)]
impl Default for OrchestrationParameters {
    fn default() -> Self {
        Self {
            routing_key: Default::default(),
            _type: String::from("orchestration_parameters"),
        }
    }
}

impl OrchestrationParameters {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("orchestration_parameters")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateOrchPathRouter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub orchestration_path: Option<OrchestrationRouterOrchestrationPath1>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPath {
    #[serde(rename = "type")]
    #[serde(default = "OrchestrationRouterOrchestrationPath::_type_default")]
    pub _type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<OrchestrationRouterOrchestrationPathParent>,
    /// Must contain at least a \"start\" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph of rules.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sets: Option<Vec<OrchestrationRouterOrchestrationPathSets>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub catch_all: Option<OrchestrationRouterOrchestrationPathCatchAll>,
    /// The date/time the object was created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_by: Option<OrchestrationRouterOrchestrationPathCreatedBy>,
    /// The date/time the object was last updated.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated_by: Option<OrchestrationRouterOrchestrationPathUpdatedBy>,
    /// Version of these Orchestration Rules
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for OrchestrationRouterOrchestrationPath {
    fn default() -> Self {
        Self {
            _type: String::from("orchestration_router_orchestration_path"),
            parent: Default::default(),
            sets: Default::default(),
            catch_all: Default::default(),
            created_at: Default::default(),
            created_by: Default::default(),
            updated_at: Default::default(),
            updated_by: Default::default(),
            version: Default::default(),
        }
    }
}

impl OrchestrationRouterOrchestrationPath {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("orchestration_router_orchestration_path")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPath1 {
    /// Indicates that these are a \"router\" type set of rules.
    #[serde(rename = "type")]
    #[serde(default = "OrchestrationRouterOrchestrationPath1::_type_default")]
    pub _type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<OrchestrationRouterOrchestrationPath1Parent>,
    /// The Router contains a single set of rules (the \"start\" set). The Router evaluates Events against these Rules, one at a time, and routes each Event to a specific Service based on the first rule that matches.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sets: Option<Vec<OrchestrationRouterOrchestrationPath1Sets>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub catch_all: Option<OrchestrationRouterOrchestrationPath1CatchAll>,
}

#[allow(clippy::derivable_impls)]
impl Default for OrchestrationRouterOrchestrationPath1 {
    fn default() -> Self {
        Self {
            _type: String::from("orchestration_router_orchestration_path_1"),
            parent: Default::default(),
            sets: Default::default(),
            catch_all: Default::default(),
        }
    }
}

impl OrchestrationRouterOrchestrationPath1 {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("orchestration_router_orchestration_path_1")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPath1Actions {
    /// The ID of the target Service for the resulting alert. You can find the service you want to route to by calling the services endpoint.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub route_to: Option<String>,
}

/// When none of the rules match an event, the event will be routed according to the catch_all settings.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPath1CatchAll {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<OrchestrationRouterOrchestrationPath1CatchAllActions>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPath1CatchAllActions {
    /// With a value of 'unrouted', all events are sent to the Unrouted Orchestration.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub route_to: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPath1Parent {
    /// ID of the Global Event Orchestration this Router belongs to.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<Value>,
    #[serde(rename = "type")]
    #[serde(default = "OrchestrationRouterOrchestrationPath1Parent::_type_default")]
    pub _type: String,
}

#[allow(clippy::derivable_impls)]
impl Default for OrchestrationRouterOrchestrationPath1Parent {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("orchestration_router_orchestration_path_1_parent"),
        }
    }
}

impl OrchestrationRouterOrchestrationPath1Parent {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("orchestration_router_orchestration_path_1_parent")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPath1Rules {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<OrchestrationRouterOrchestrationPath1Actions>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPath1Sets {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<OrchestrationRouterOrchestrationPath1Rules>>,
}

/// When none of the Rules in a set match an event, we apply the catch_all actions to the event.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPathCatchAll {
    /// These are the actions that will be taken to change the resulting alert and incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<HashMap<String, Value>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPathConditions {
    /// A PCL condition string
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,
}

/// Reference to the user that created the object.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPathCreatedBy {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default = "OrchestrationRouterOrchestrationPathCreatedBy::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for OrchestrationRouterOrchestrationPathCreatedBy {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("orchestration_router_orchestration_path_created_by"),
            _self: Default::default(),
        }
    }
}

impl OrchestrationRouterOrchestrationPathCreatedBy {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("orchestration_router_orchestration_path_created_by")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPathParent {
    /// ID of the object these Orchestration Rules belongs to.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A string that determines the schema of the parent object
    #[serde(rename = "type")]
    #[serde(default = "OrchestrationRouterOrchestrationPathParent::_type_default")]
    pub _type: String,
    /// The API show URL at which the parent object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for OrchestrationRouterOrchestrationPathParent {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("orchestration_router_orchestration_path_parent"),
            _self: Default::default(),
        }
    }
}

impl OrchestrationRouterOrchestrationPathParent {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("orchestration_router_orchestration_path_parent")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPathRules {
    /// ID of the rule
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A description of this rule's purpose.
    #[serde(default = "OrchestrationRouterOrchestrationPathRules::label_default")]
    pub label: String,
    /// Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if **any** of these conditions match.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<OrchestrationRouterOrchestrationPathConditions>>,
    /// When an event matches this rule, these are the actions that will be taken to change the resulting alert and incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<HashMap<String, Value>>,
    /// Indicates whether the rule is disabled and would therefore not be evaluated.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
}

#[allow(clippy::derivable_impls)]
impl Default for OrchestrationRouterOrchestrationPathRules {
    fn default() -> Self {
        Self {
            id: Default::default(),
            label: String::from("OrchestrationRouter_orchestration_path_rules"),
            conditions: Default::default(),
            actions: Default::default(),
            disabled: Default::default(),
        }
    }
}

impl OrchestrationRouterOrchestrationPathRules {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("OrchestrationRouter_orchestration_path_rules")
    }
}

/// A set of rules
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPathSets {
    /// The ID of this set of rules. Rules in other sets can route events into this set using the \"route_to\" properties.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<OrchestrationRouterOrchestrationPathRules>>,
}

/// Reference to the user that last updated the object.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationRouterOrchestrationPathUpdatedBy {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default = "OrchestrationRouterOrchestrationPathUpdatedBy::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for OrchestrationRouterOrchestrationPathUpdatedBy {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("orchestration_router_orchestration_path_updated_by"),
            _self: Default::default(),
        }
    }
}

impl OrchestrationRouterOrchestrationPathUpdatedBy {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("orchestration_router_orchestration_path_updated_by")
    }
}

/// Reference to the team that owns the Orchestration. If none is specified, only admins have access.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationTeam {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A string that determines the schema of the object
    #[serde(rename = "type")]
    #[serde(default = "OrchestrationTeam::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for OrchestrationTeam {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("orchestration_team"),
            _self: Default::default(),
        }
    }
}

impl OrchestrationTeam {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("orchestration_team")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateOrchPathUnrouted {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub orchestration_path: Option<OrchestrationUnroutedOrchestrationPath>,
}

#[allow(clippy::derivable_impls)]
impl Default for UpdateOrchPathUnrouted {
    fn default() -> Self {
        Self {
            orchestration_path: Default::default(),
        }
    }
}

impl UpdateOrchPathUnrouted {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("OrchestrationUnrouted")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("orchestration_unrouted")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationUnroutedOrchestrationPath {
    /// Indicates that these are a \"unrouted\" type set of rules.
    #[serde(rename = "type")]
    #[serde(default = "OrchestrationUnroutedOrchestrationPath::_type_default")]
    pub _type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<OrchestrationUnroutedOrchestrationPathParent>,
    /// An Unrouted Orchestration must contain at least a \"start\" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sets: Option<Vec<OrchestrationUnroutedOrchestrationPathSets>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub catch_all: Option<OrchestrationUnroutedOrchestrationPathCatchAll>,
}

#[allow(clippy::derivable_impls)]
impl Default for OrchestrationUnroutedOrchestrationPath {
    fn default() -> Self {
        Self {
            _type: String::from("orchestration_unrouted_orchestration_path"),
            parent: Default::default(),
            sets: Default::default(),
            catch_all: Default::default(),
        }
    }
}

impl OrchestrationUnroutedOrchestrationPath {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("orchestration_unrouted_orchestration_path")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationUnroutedOrchestrationPathCatchAll {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<OrchestrationUnroutedOrchestrationPathCatchAllActions>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationUnroutedOrchestrationPathCatchAllActions {
    /// Set the severity of the resulting alert.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub severity: Option<OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum>,
    /// Set whether the resulting alert status is trigger or resolve.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_action: Option<OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum>,
    /// Populate variables from event payloads and use those variables in other event actions.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variables: Option<Vec<OrchestrationUnroutedOrchestrationPathCatchAllActionsVariables>>,
    /// Dynamically extract values to set and modify new and existing PD-CEF fields.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extractions: Option<Vec<OrchestrationUnroutedOrchestrationPathCatchAllActionsExtractionsItems>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum {
    #[serde(rename = "info")]
    INFO,
    #[serde(rename = "error")]
    ERROR,
    #[serde(rename = "warning")]
    WARNING,
    #[serde(rename = "critical")]
    CRITICAL,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::INFO => write!(f, "info"),
            OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::ERROR => write!(f, "error"),
            OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::WARNING => write!(f, "warning"),
            OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::CRITICAL => write!(f, "critical"),
            OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "info" => Ok(OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::INFO),
            "error" => Ok(OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::ERROR),
            "warning" => Ok(OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::WARNING),
            "critical" => Ok(OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::CRITICAL),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum {
    fn as_ref(&self) -> &str {
        match self {
            OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::INFO => "info",
            OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::ERROR => "error",
            OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::WARNING => "warning",
            OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::CRITICAL => "critical",
            OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum {
    fn default() -> Self {
        OrchestrationUnroutedOrchestrationPathCatchAllActionsSeverityEnum::INFO
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum {
    #[serde(rename = "trigger")]
    TRIGGER,
    #[serde(rename = "resolve")]
    RESOLVE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum::TRIGGER => write!(f, "trigger"),
            OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum::RESOLVE => write!(f, "resolve"),
            OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "trigger" => Ok(OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum::TRIGGER),
            "resolve" => Ok(OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum::RESOLVE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum {
    fn as_ref(&self) -> &str {
        match self {
            OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum::TRIGGER => "trigger",
            OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum::RESOLVE => "resolve",
            OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum {
    fn default() -> Self {
        OrchestrationUnroutedOrchestrationPathCatchAllActionsEventActionEnum::TRIGGER
    }
}

#[allow(non_camel_case_types, clippy::derive_partial_eq_without_eq)]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrchestrationUnroutedOrchestrationPathCatchAllActionsExtractionsItems {
    ExtractionsItems0 { target: String, template: String },
    ExtractionsItems1 { target: String, regex: String, source: String },
}

impl Display for OrchestrationUnroutedOrchestrationPathCatchAllActionsExtractionsItems {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            OrchestrationUnroutedOrchestrationPathCatchAllActionsExtractionsItems::ExtractionsItems0 { target, template } => write!(f, "ExtractionsItems0{{ {:?}, {:?} }}", target, template),
            OrchestrationUnroutedOrchestrationPathCatchAllActionsExtractionsItems::ExtractionsItems1 { target, regex, source } => write!(f, "ExtractionsItems1{{ {:?}, {:?}, {:?} }}", target, regex, source),
        }
    }
}

impl std::default::Default for OrchestrationUnroutedOrchestrationPathCatchAllActionsExtractionsItems {
    fn default() -> Self {
        OrchestrationUnroutedOrchestrationPathCatchAllActionsExtractionsItems::ExtractionsItems0 { target: String::default(), template: String::default() }
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationUnroutedOrchestrationPathCatchAllActionsVariables {
    /// The name of the variable
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Path to a field in an event, in dot-notation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// The type of operation to populate the variable. Currently only Regex-based variable extraction is supported.
    #[serde(rename = "type")]
    pub _type: OrchestrationUnroutedOrchestrationPathCatchAllActionsVariablesTypeEnum,
    /// A RE2 regular expression. If it contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum OrchestrationUnroutedOrchestrationPathCatchAllActionsVariablesTypeEnum {
    #[serde(rename = "regex")]
    REGEX,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for OrchestrationUnroutedOrchestrationPathCatchAllActionsVariablesTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            OrchestrationUnroutedOrchestrationPathCatchAllActionsVariablesTypeEnum::REGEX => write!(f, "regex"),
            OrchestrationUnroutedOrchestrationPathCatchAllActionsVariablesTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for OrchestrationUnroutedOrchestrationPathCatchAllActionsVariablesTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "regex" => Ok(OrchestrationUnroutedOrchestrationPathCatchAllActionsVariablesTypeEnum::REGEX),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for OrchestrationUnroutedOrchestrationPathCatchAllActionsVariablesTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            OrchestrationUnroutedOrchestrationPathCatchAllActionsVariablesTypeEnum::REGEX => "regex",
            OrchestrationUnroutedOrchestrationPathCatchAllActionsVariablesTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for OrchestrationUnroutedOrchestrationPathCatchAllActionsVariablesTypeEnum {
    fn default() -> Self {
        OrchestrationUnroutedOrchestrationPathCatchAllActionsVariablesTypeEnum::REGEX
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationUnroutedOrchestrationPathParent {
    /// ID of the Global Event Orchestration this Unrouted Orchestration belongs to.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<Value>,
    #[serde(rename = "type")]
    #[serde(default = "OrchestrationUnroutedOrchestrationPathParent::_type_default")]
    pub _type: String,
}

#[allow(clippy::derivable_impls)]
impl Default for OrchestrationUnroutedOrchestrationPathParent {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("orchestration_unrouted_orchestration_path_parent"),
        }
    }
}

impl OrchestrationUnroutedOrchestrationPathParent {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("orchestration_unrouted_orchestration_path_parent")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationUnroutedOrchestrationPathRules {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<OrchestrationUnroutedOrchestrationPathRulesActions>,
}
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationUnroutedOrchestrationPathRulesActions {
    /// The ID of a Set from this Unrouted Orchestration whose rules you also want to use with event that match this rule.
    #[serde(rename = "route_to")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub route_to: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationUnroutedOrchestrationPathSets {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<OrchestrationUnroutedOrchestrationPathRules>>,
}

/// Reference to the user that has updated the Orchestration last.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OrchestrationUpdatedBy {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A string that determines the schema of the object
    #[serde(rename = "type")]
    #[serde(default = "OrchestrationUpdatedBy::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for OrchestrationUpdatedBy {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("orchestration_updated_by"),
            _self: Default::default(),
        }
    }
}

impl OrchestrationUpdatedBy {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("orchestration_updated_by")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct OutboundIntegrationReference {
    /// The label of the tag.
    #[serde(default = "OutboundIntegrationReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: OutboundIntegrationReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for OutboundIntegrationReference {
    fn default() -> Self {
        Self {
            label: String::from("OutboundIntegrationReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl OutboundIntegrationReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("OutboundIntegrationReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("outbound_integration_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum OutboundIntegrationReferenceTypeEnum {
    #[serde(rename = "outbound_integration_reference")]
    OUTBOUND_INTEGRATION_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for OutboundIntegrationReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            OutboundIntegrationReferenceTypeEnum::OUTBOUND_INTEGRATION_REFERENCE => write!(f, "outbound_integration_reference"),
            OutboundIntegrationReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for OutboundIntegrationReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "outbound_integration_reference" => Ok(OutboundIntegrationReferenceTypeEnum::OUTBOUND_INTEGRATION_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for OutboundIntegrationReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            OutboundIntegrationReferenceTypeEnum::OUTBOUND_INTEGRATION_REFERENCE => "outbound_integration_reference",
            OutboundIntegrationReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for OutboundIntegrationReferenceTypeEnum {
    fn default() -> Self {
        OutboundIntegrationReferenceTypeEnum::OUTBOUND_INTEGRATION_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Pagination {
    /// Echoes offset pagination property.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<isize>,
    /// Echoes limit pagination property.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<isize>,
    /// Indicates if there are additional records to return
    #[serde(skip_serializing_if = "Option::is_none")]
    pub more: Option<bool>,
    /// The total number of records matching the given query.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total: Option<isize>,
}

/// The Phone Contact Method of the User, used for Voice or SMS.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct PhoneContactMethod {
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: PhoneContactMethodTypeEnum,
    /// The label (e.g., \"Work\", \"Mobile\", etc.).
    #[serde(default = "PhoneContactMethod::label_default")]
    pub label: String,
    /// The \"address\" to deliver to: email, phone number, etc., depending on the type.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub address: String,
    /// The 1-to-3 digit country calling code.
    pub country_code: u16,
    /// If true, this phone is capable of receiving SMS messages.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// If true, this phone has been blacklisted by PagerDuty and no messages will be sent to it.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blacklisted: Option<bool>,
}

#[allow(clippy::derivable_impls)]
impl Default for PhoneContactMethod {
    fn default() -> Self {
        Self {
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            label: String::from("PhoneContactMethod"),
            address: Default::default(),
            country_code: Default::default(),
            enabled: Default::default(),
            blacklisted: Default::default(),
        }
    }
}

impl PhoneContactMethod {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("PhoneContactMethod")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("phone_contact_method")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum PhoneContactMethodTypeEnum {
    #[serde(rename = "phone_contact_method")]
    PHONE_CONTACT_METHOD,
    #[serde(rename = "sms_contact_method")]
    SMS_CONTACT_METHOD,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for PhoneContactMethodTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            PhoneContactMethodTypeEnum::PHONE_CONTACT_METHOD => write!(f, "phone_contact_method"),
            PhoneContactMethodTypeEnum::SMS_CONTACT_METHOD => write!(f, "sms_contact_method"),
            PhoneContactMethodTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for PhoneContactMethodTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "phone_contact_method" => Ok(PhoneContactMethodTypeEnum::PHONE_CONTACT_METHOD),
            "sms_contact_method" => Ok(PhoneContactMethodTypeEnum::SMS_CONTACT_METHOD),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for PhoneContactMethodTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            PhoneContactMethodTypeEnum::PHONE_CONTACT_METHOD => "phone_contact_method",
            PhoneContactMethodTypeEnum::SMS_CONTACT_METHOD => "sms_contact_method",
            PhoneContactMethodTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for PhoneContactMethodTypeEnum {
    fn default() -> Self {
        PhoneContactMethodTypeEnum::PHONE_CONTACT_METHOD
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Priority {
    /// The label of the tag.
    #[serde(default = "Priority::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default = "Priority::_type_default")]
    pub _type: String,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The user-provided short name of the priority.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The user-provided description of the priority.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for Priority {
    fn default() -> Self {
        Self {
            label: String::from("Priority"),
            html_url: Default::default(),
            _self: Default::default(),
            _type: String::from("priority"),
            summary: Default::default(),
            id: Default::default(),
            name: Default::default(),
            description: Default::default(),
        }
    }
}

impl Priority {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Priority")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("priority")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct PriorityReference {
    /// The label of the tag.
    #[serde(default = "PriorityReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: PriorityReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for PriorityReference {
    fn default() -> Self {
        Self {
            label: String::from("PriorityReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl PriorityReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("PriorityReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("priority_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum PriorityReferenceTypeEnum {
    #[serde(rename = "priority_reference")]
    PRIORITY_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for PriorityReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            PriorityReferenceTypeEnum::PRIORITY_REFERENCE => write!(f, "priority_reference"),
            PriorityReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for PriorityReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "priority_reference" => Ok(PriorityReferenceTypeEnum::PRIORITY_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for PriorityReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            PriorityReferenceTypeEnum::PRIORITY_REFERENCE => "priority_reference",
            PriorityReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for PriorityReferenceTypeEnum {
    fn default() -> Self {
        PriorityReferenceTypeEnum::PRIORITY_REFERENCE
    }
}

/// The Push Contact Method of the User.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct PushContactMethod {
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: PushContactMethodTypeEnum,
    /// The label (e.g., \"Work\", \"Mobile\", etc.).
    #[serde(default = "PushContactMethod::label_default")]
    pub label: String,
    /// The \"address\" to deliver to: email, phone number, etc., depending on the type.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub address: String,
    /// The type of device.
    pub device_type: PushContactMethodDeviceTypeEnum,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sounds: Option<Vec<PushContactMethodSound>>,
    /// Time at which the contact method was created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// If true, this phone has been blacklisted by PagerDuty and no messages will be sent to it.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blacklisted: Option<bool>,
}

#[allow(clippy::derivable_impls)]
impl Default for PushContactMethod {
    fn default() -> Self {
        Self {
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            label: String::from("PushContactMethod"),
            address: Default::default(),
            device_type: Default::default(),
            sounds: Default::default(),
            created_at: Default::default(),
            blacklisted: Default::default(),
        }
    }
}

impl PushContactMethod {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("PushContactMethod")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("push_contact_method")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum PushContactMethodTypeEnum {
    #[serde(rename = "push_notification_contact_method")]
    PUSH_NOTIFICATION_CONTACT_METHOD,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for PushContactMethodTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            PushContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD => write!(f, "push_notification_contact_method"),
            PushContactMethodTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for PushContactMethodTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "push_notification_contact_method" => Ok(PushContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for PushContactMethodTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            PushContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD => "push_notification_contact_method",
            PushContactMethodTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for PushContactMethodTypeEnum {
    fn default() -> Self {
        PushContactMethodTypeEnum::PUSH_NOTIFICATION_CONTACT_METHOD
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum PushContactMethodDeviceTypeEnum {
    #[serde(rename = "android")]
    ANDROID,
    #[serde(rename = "ios")]
    IOS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for PushContactMethodDeviceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            PushContactMethodDeviceTypeEnum::ANDROID => write!(f, "android"),
            PushContactMethodDeviceTypeEnum::IOS => write!(f, "ios"),
            PushContactMethodDeviceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for PushContactMethodDeviceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "android" => Ok(PushContactMethodDeviceTypeEnum::ANDROID),
            "ios" => Ok(PushContactMethodDeviceTypeEnum::IOS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for PushContactMethodDeviceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            PushContactMethodDeviceTypeEnum::ANDROID => "android",
            PushContactMethodDeviceTypeEnum::IOS => "ios",
            PushContactMethodDeviceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for PushContactMethodDeviceTypeEnum {
    fn default() -> Self {
        PushContactMethodDeviceTypeEnum::ANDROID
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct PushContactMethodSound {
    /// The type of sound.
    #[serde(rename = "type")]
    pub _type: PushContactMethodSoundTypeEnum,
    /// The sound file name.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file: Option<String>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum PushContactMethodSoundTypeEnum {
    #[serde(rename = "alert_high_urgency")]
    HIGH_URGENCY,
    #[serde(rename = "alert_low_urgency")]
    LOW_URGENCY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for PushContactMethodSoundTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            PushContactMethodSoundTypeEnum::HIGH_URGENCY => write!(f, "alert_high_urgency"),
            PushContactMethodSoundTypeEnum::LOW_URGENCY => write!(f, "alert_low_urgency"),
            PushContactMethodSoundTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for PushContactMethodSoundTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "alert_high_urgency" => Ok(PushContactMethodSoundTypeEnum::HIGH_URGENCY),
            "alert_low_urgency" => Ok(PushContactMethodSoundTypeEnum::LOW_URGENCY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for PushContactMethodSoundTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            PushContactMethodSoundTypeEnum::HIGH_URGENCY => "alert_high_urgency",
            PushContactMethodSoundTypeEnum::LOW_URGENCY => "alert_low_urgency",
            PushContactMethodSoundTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for PushContactMethodSoundTypeEnum {
    fn default() -> Self {
        PushContactMethodSoundTypeEnum::HIGH_URGENCY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct GetAnalyticsIncidents {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filters: Option<AnalyticsrawincidentsFilters>,
    /// A cursor to indicate the reference point that the results should follow
    #[serde(skip_serializing_if = "Option::is_none")]
    pub starting_after: Option<String>,
    /// A cursor to indicate the reference point that the results should precede
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ending_before: Option<String>,
    /// The order the results;  asc for ascending, desc for descending. Defaults to 'desc'.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub order: Option<GetAnalyticsIncidentsOrderEnum>,
    /// The column to use for ordering the results. Defaults to 'created_at'.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub order_by: Option<GetAnalyticsIncidentsOrderByEnum>,
    /// Number of results to include in each batch. Limits between 1 to 1000 are accepted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<u16>,
    /// The time zone to use for the results.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_zone: Option<String>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum GetAnalyticsIncidentsOrderEnum {
    #[serde(rename = "asc")]
    ASC,
    #[serde(rename = "desc")]
    DESC,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for GetAnalyticsIncidentsOrderEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            GetAnalyticsIncidentsOrderEnum::ASC => write!(f, "asc"),
            GetAnalyticsIncidentsOrderEnum::DESC => write!(f, "desc"),
            GetAnalyticsIncidentsOrderEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for GetAnalyticsIncidentsOrderEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "asc" => Ok(GetAnalyticsIncidentsOrderEnum::ASC),
            "desc" => Ok(GetAnalyticsIncidentsOrderEnum::DESC),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for GetAnalyticsIncidentsOrderEnum {
    fn as_ref(&self) -> &str {
        match self {
            GetAnalyticsIncidentsOrderEnum::ASC => "asc",
            GetAnalyticsIncidentsOrderEnum::DESC => "desc",
            GetAnalyticsIncidentsOrderEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for GetAnalyticsIncidentsOrderEnum {
    fn default() -> Self {
        GetAnalyticsIncidentsOrderEnum::ASC
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum GetAnalyticsIncidentsOrderByEnum {
    #[serde(rename = "created_at")]
    CREATED_AT,
    #[serde(rename = "seconds_to_resolve")]
    SECONDS_TO_RESOLVE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for GetAnalyticsIncidentsOrderByEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            GetAnalyticsIncidentsOrderByEnum::CREATED_AT => write!(f, "created_at"),
            GetAnalyticsIncidentsOrderByEnum::SECONDS_TO_RESOLVE => write!(f, "seconds_to_resolve"),
            GetAnalyticsIncidentsOrderByEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for GetAnalyticsIncidentsOrderByEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "created_at" => Ok(GetAnalyticsIncidentsOrderByEnum::CREATED_AT),
            "seconds_to_resolve" => Ok(GetAnalyticsIncidentsOrderByEnum::SECONDS_TO_RESOLVE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for GetAnalyticsIncidentsOrderByEnum {
    fn as_ref(&self) -> &str {
        match self {
            GetAnalyticsIncidentsOrderByEnum::CREATED_AT => "created_at",
            GetAnalyticsIncidentsOrderByEnum::SECONDS_TO_RESOLVE => "seconds_to_resolve",
            GetAnalyticsIncidentsOrderByEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for GetAnalyticsIncidentsOrderByEnum {
    fn default() -> Self {
        GetAnalyticsIncidentsOrderByEnum::CREATED_AT
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Reference {
    /// The label of the tag.
    #[serde(default = "Reference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default = "Reference::_type_default")]
    pub _type: String,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for Reference {
    fn default() -> Self {
        Self {
            label: String::from("Reference"),
            html_url: Default::default(),
            _self: Default::default(),
            _type: String::from("reference"),
            summary: Default::default(),
            id: Default::default(),
        }
    }
}

impl Reference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Reference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("reference")
    }
}

/// The data for a type of relationship where the Incident is related due to our machine learning algorithm. 
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct RelatedIncidentMachineLearningRelationship {
    /// The classification for why this Related Incident was grouped into this group. Values can be one of: [similar_contents, prior_feedback], where: similar_contents - The Related Incident was due to similar contents of the Incidents. prior_feedback - The Related Incident was determined to be related, based on User feedback or Incident merge/unmerge actions. 
    #[serde(skip_serializing_if = "Option::is_none")]
    pub grouping_classification: Option<RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_feedback: Option<RelatedIncidentMachineLearningRelationshipUserFeedback>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum {
    #[serde(rename = "similar_contents")]
    SIMILAR_CONTENTS,
    #[serde(rename = "prior_feedback")]
    PRIOR_FEEDBACK,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum::SIMILAR_CONTENTS => write!(f, "similar_contents"),
            RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum::PRIOR_FEEDBACK => write!(f, "prior_feedback"),
            RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "similar_contents" => Ok(RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum::SIMILAR_CONTENTS),
            "prior_feedback" => Ok(RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum::PRIOR_FEEDBACK),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum {
    fn as_ref(&self) -> &str {
        match self {
            RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum::SIMILAR_CONTENTS => "similar_contents",
            RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum::PRIOR_FEEDBACK => "prior_feedback",
            RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum {
    fn default() -> Self {
        RelatedIncidentMachineLearningRelationshipGroupingClassificationEnum::SIMILAR_CONTENTS
    }
}

/// The feedback provided from Users to influence the machine learning algorithm for future Related Incidents.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct RelatedIncidentMachineLearningRelationshipUserFeedback {
    /// The total number of times Users agreed that the Incidents are related.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub positive_feedback_count: Option<isize>,
    /// The total number of times Users disagreed that the Incidents are related.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub negative_feedback_count: Option<isize>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct RelatedIncidentServiceDependencyBase {
    /// The ID of the Service referenced.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of the related Service.
    #[serde(rename = "type")]
    pub _type: RelatedIncidentServiceDependencyBaseTypeEnum,
    /// The API show URL at which the object is accessible.
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RelatedIncidentServiceDependencyBaseTypeEnum {
    #[serde(rename = "business_service_reference")]
    BUSINESS_SERVICE_REFERENCE,
    #[serde(rename = "technical_service_reference")]
    TECHNICAL_SERVICE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for RelatedIncidentServiceDependencyBaseTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            RelatedIncidentServiceDependencyBaseTypeEnum::BUSINESS_SERVICE_REFERENCE => write!(f, "business_service_reference"),
            RelatedIncidentServiceDependencyBaseTypeEnum::TECHNICAL_SERVICE_REFERENCE => write!(f, "technical_service_reference"),
            RelatedIncidentServiceDependencyBaseTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for RelatedIncidentServiceDependencyBaseTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "business_service_reference" => Ok(RelatedIncidentServiceDependencyBaseTypeEnum::BUSINESS_SERVICE_REFERENCE),
            "technical_service_reference" => Ok(RelatedIncidentServiceDependencyBaseTypeEnum::TECHNICAL_SERVICE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for RelatedIncidentServiceDependencyBaseTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            RelatedIncidentServiceDependencyBaseTypeEnum::BUSINESS_SERVICE_REFERENCE => "business_service_reference",
            RelatedIncidentServiceDependencyBaseTypeEnum::TECHNICAL_SERVICE_REFERENCE => "technical_service_reference",
            RelatedIncidentServiceDependencyBaseTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for RelatedIncidentServiceDependencyBaseTypeEnum {
    fn default() -> Self {
        RelatedIncidentServiceDependencyBaseTypeEnum::BUSINESS_SERVICE_REFERENCE
    }
}

/// The data for a type of relationship where the Incident is related due to Business or Technical Service dependencies.  Both `dependent_services` and `supporting_services` are returned to signify the dependencies between the Services that the Incident and Related Incident belong to.  Each Service reference returned in the list of supporting and dependent Services has a type of: [business_service_reference, technical_service_reference]. 
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct RelatedIncidentServiceDependencyRelationship {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dependent_services: Option<Vec<RelatedIncidentServiceDependencyBase>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supporting_services: Option<Vec<RelatedIncidentServiceDependencyBase>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ResolveReason {
    /// The reason the incident was resolved. The only reason currently supported is merge.
    #[serde(rename = "type")]
    pub _type: ResolveReasonTypeEnum,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<IncidentReference>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ResolveReasonTypeEnum {
    #[serde(rename = "merge_resolve_reason")]
    MERGE_RESOLVE_REASON,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ResolveReasonTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ResolveReasonTypeEnum::MERGE_RESOLVE_REASON => write!(f, "merge_resolve_reason"),
            ResolveReasonTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ResolveReasonTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "merge_resolve_reason" => Ok(ResolveReasonTypeEnum::MERGE_RESOLVE_REASON),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ResolveReasonTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ResolveReasonTypeEnum::MERGE_RESOLVE_REASON => "merge_resolve_reason",
            ResolveReasonTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ResolveReasonTypeEnum {
    fn default() -> Self {
        ResolveReasonTypeEnum::MERGE_RESOLVE_REASON
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ResponderRequest {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<IncidentReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester: Option<UserReference>,
    /// The time the request was made
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requested_at: Option<String>,
    /// The message sent with the responder request
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// The array of targets the responder request is being sent to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub responder_request_targets: Option<Vec<ResponderRequestTargetReference>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ResponderRequestTargetReference {
    /// The type of target (either a user or an escalation policy)
    #[serde(rename = "type")]
    #[serde(default = "ResponderRequestTargetReference::_type_default")]
    pub _type: String,
    /// The id of the user or escalation policy
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    /// An array of responders associated with the specified incident
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident_responders: Option<Vec<IncidentsRespondersReference>>,
}

#[allow(clippy::derivable_impls)]
impl Default for ResponderRequestTargetReference {
    fn default() -> Self {
        Self {
            _type: String::from("responder_request_target_reference"),
            id: Default::default(),
            summary: Default::default(),
            incident_responders: Default::default(),
        }
    }
}

impl ResponderRequestTargetReference {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("responder_request_target_reference")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ResponsePlay {
    /// The label of the tag.
    #[serde(default = "ResponsePlay::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: ResponsePlayTypeEnum,
    /// The name of the response play.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The description of the response play.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team: Option<ResponsePlayTeamEnum>,
    /// An array containing the users and/or teams to be added as subscribers to any incident on which this response play is run.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribers: Option<Vec<ResponsePlaySubscribersEnum>>,
    /// The content of the notification that will be sent to all incident subscribers upon the running of this response play. Note that this includes any users who may have already been subscribed to the incident prior to the running of this response play. If empty, no notifications will be sent.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribers_message: Option<String>,
    /// An array containing the users and/or escalation policies to be requested as responders to any incident on which this response play is run.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub responders: Option<Vec<ResponsePlayRespondersEnum>>,
    /// The message body of the notification that will be sent to this response play's set of responders. If empty, a default response request notification will be sent.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub responders_message: Option<String>,
    /// String representing how this response play is allowed to be run. Valid options are:   - `services`: This response play cannot be manually run by any users. It will run automatically for new incidents triggered on any services that are configured with this response play.   - `teams`: This response play can be run manually on an incident only by members of its configured team. This option can only be selected when the `team` property for this response play is not empty.   - `responders`: This response play can be run manually on an incident by any responders in this account.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub runnability: Option<ResponsePlayRunnabilityEnum>,
    /// The telephone number that will be set as the conference number for any incident on which this response play is run.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conference_number: Option<String>,
    /// The URL that will be set as the conference URL for any incident on which this response play is run.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conference_url: Option<String>,
    /// This field has three possible values and indicates how the response play was created.   - `none` : The response play had no conference_number or conference_url set at time of creation.   - `manual` : The response play had one or both of conference_number and conference_url set at time of creation.   - `zoom` : Customers with the Zoom-Integration Entitelment can use this value to dynamicly configure conference number and url for zoom
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conference_type: Option<ResponsePlayConferenceTypeEnum>,
}

#[allow(clippy::derivable_impls)]
impl Default for ResponsePlay {
    fn default() -> Self {
        Self {
            label: String::from("ResponsePlay"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            name: Default::default(),
            description: Default::default(),
            team: Default::default(),
            subscribers: Default::default(),
            subscribers_message: Default::default(),
            responders: Default::default(),
            responders_message: Default::default(),
            runnability: Default::default(),
            conference_number: Default::default(),
            conference_url: Default::default(),
            conference_type: Default::default(),
        }
    }
}

impl ResponsePlay {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("ResponsePlay")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("response_play")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ResponsePlayTypeEnum {
    #[serde(rename = "response_play")]
    RESPONSE_PLAY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ResponsePlayTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ResponsePlayTypeEnum::RESPONSE_PLAY => write!(f, "response_play"),
            ResponsePlayTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ResponsePlayTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "response_play" => Ok(ResponsePlayTypeEnum::RESPONSE_PLAY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ResponsePlayTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ResponsePlayTypeEnum::RESPONSE_PLAY => "response_play",
            ResponsePlayTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ResponsePlayTypeEnum {
    fn default() -> Self {
        ResponsePlayTypeEnum::RESPONSE_PLAY
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResponsePlayTeamEnum {
    TEAM_REFERENCE(TeamReference),
}

impl Display for ResponsePlayTeamEnum {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            ResponsePlayTeamEnum::TEAM_REFERENCE(value) => write!(f, "{:?}", value),
        }
    }
}

impl std::default::Default for ResponsePlayTeamEnum {
    fn default() -> Self {
        ResponsePlayTeamEnum::TEAM_REFERENCE(TeamReference::default())
    }
}

#[allow(non_camel_case_types, clippy::derive_partial_eq_without_eq)]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResponsePlaySubscribersEnum {
    USER_REFERENCE(UserReference),
    TEAM_REFERENCE(TeamReference),
}

impl Display for ResponsePlaySubscribersEnum {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            ResponsePlaySubscribersEnum::USER_REFERENCE(value) => write!(f, "{:?}", value),
            ResponsePlaySubscribersEnum::TEAM_REFERENCE(value) => write!(f, "{:?}", value),
        }
    }
}

impl std::default::Default for ResponsePlaySubscribersEnum {
    fn default() -> Self {
        ResponsePlaySubscribersEnum::USER_REFERENCE(UserReference::default())
    }
}

#[allow(non_camel_case_types, clippy::derive_partial_eq_without_eq)]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResponsePlayRespondersEnum {
    USER_REFERENCE(UserReference),
    ESCALATION_POLICY_REFERENCE(EscalationPolicyReference),
}

impl Display for ResponsePlayRespondersEnum {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            ResponsePlayRespondersEnum::USER_REFERENCE(value) => write!(f, "{:?}", value),
            ResponsePlayRespondersEnum::ESCALATION_POLICY_REFERENCE(value) => write!(f, "{:?}", value),
        }
    }
}

impl std::default::Default for ResponsePlayRespondersEnum {
    fn default() -> Self {
        ResponsePlayRespondersEnum::USER_REFERENCE(UserReference::default())
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ResponsePlayRunnabilityEnum {
    #[serde(rename = "services")]
    SERVICES,
    #[serde(rename = "teams")]
    TEAMS,
    #[serde(rename = "responders")]
    RESPONDERS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ResponsePlayRunnabilityEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ResponsePlayRunnabilityEnum::SERVICES => write!(f, "services"),
            ResponsePlayRunnabilityEnum::TEAMS => write!(f, "teams"),
            ResponsePlayRunnabilityEnum::RESPONDERS => write!(f, "responders"),
            ResponsePlayRunnabilityEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ResponsePlayRunnabilityEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "services" => Ok(ResponsePlayRunnabilityEnum::SERVICES),
            "teams" => Ok(ResponsePlayRunnabilityEnum::TEAMS),
            "responders" => Ok(ResponsePlayRunnabilityEnum::RESPONDERS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ResponsePlayRunnabilityEnum {
    fn as_ref(&self) -> &str {
        match self {
            ResponsePlayRunnabilityEnum::SERVICES => "services",
            ResponsePlayRunnabilityEnum::TEAMS => "teams",
            ResponsePlayRunnabilityEnum::RESPONDERS => "responders",
            ResponsePlayRunnabilityEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ResponsePlayRunnabilityEnum {
    fn default() -> Self {
        ResponsePlayRunnabilityEnum::SERVICES
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ResponsePlayConferenceTypeEnum {
    #[serde(rename = "none")]
    NONE,
    #[serde(rename = "manual")]
    MANUAL,
    #[serde(rename = "zoom")]
    ZOOM,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ResponsePlayConferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ResponsePlayConferenceTypeEnum::NONE => write!(f, "none"),
            ResponsePlayConferenceTypeEnum::MANUAL => write!(f, "manual"),
            ResponsePlayConferenceTypeEnum::ZOOM => write!(f, "zoom"),
            ResponsePlayConferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ResponsePlayConferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "none" => Ok(ResponsePlayConferenceTypeEnum::NONE),
            "manual" => Ok(ResponsePlayConferenceTypeEnum::MANUAL),
            "zoom" => Ok(ResponsePlayConferenceTypeEnum::ZOOM),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ResponsePlayConferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ResponsePlayConferenceTypeEnum::NONE => "none",
            ResponsePlayConferenceTypeEnum::MANUAL => "manual",
            ResponsePlayConferenceTypeEnum::ZOOM => "zoom",
            ResponsePlayConferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ResponsePlayConferenceTypeEnum {
    fn default() -> Self {
        ResponsePlayConferenceTypeEnum::NONE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct RunResponsePlay {
    pub incident: IncidentReference,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateResponsePlay {
    pub response_play: ResponsePlay,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateResponsePlay {
    pub response_play: ResponsePlay,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Restriction {
    /// Specify the types of `restriction`.
    #[serde(rename = "type")]
    pub _type: RestrictionTypeEnum,
    /// The duration of the restriction in seconds.
    pub duration_seconds: isize,
    /// The start time in HH:mm:ss format.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub start_time_of_day: String,
    /// Only required for use with a `weekly_restriction` restriction type. The first day of the weekly rotation schedule as [ISO 8601 day](https://en.wikipedia.org/wiki/ISO_week_date) (1 is Monday, etc.)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_day_of_week: Option<u8>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RestrictionTypeEnum {
    #[serde(rename = "daily_restriction")]
    DAILY_RESTRICTION,
    #[serde(rename = "weekly_restriction")]
    WEEKLY_RESTRICTION,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for RestrictionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            RestrictionTypeEnum::DAILY_RESTRICTION => write!(f, "daily_restriction"),
            RestrictionTypeEnum::WEEKLY_RESTRICTION => write!(f, "weekly_restriction"),
            RestrictionTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for RestrictionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "daily_restriction" => Ok(RestrictionTypeEnum::DAILY_RESTRICTION),
            "weekly_restriction" => Ok(RestrictionTypeEnum::WEEKLY_RESTRICTION),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for RestrictionTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            RestrictionTypeEnum::DAILY_RESTRICTION => "daily_restriction",
            RestrictionTypeEnum::WEEKLY_RESTRICTION => "weekly_restriction",
            RestrictionTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for RestrictionTypeEnum {
    fn default() -> Self {
        RestrictionTypeEnum::DAILY_RESTRICTION
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateRulesetEventRule {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule: Option<EventRule>,
    /// The id of the Event Rule to update.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub rule_id: String,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateServiceEventRule {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule: Option<ServiceEventRule>,
    /// The id of the Event Rule to update on the Service.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub rule_id: String,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Ruleset {
    /// ID of the Ruleset.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    #[serde(rename = "type")]
    pub _type: RulesetTypeEnum,
    /// Name of the Ruleset.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Routing keys routed to this Ruleset.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_keys: Option<Vec<String>>,
    /// The date the Ruleset was created at.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creator: Option<RulesetCreator>,
    /// The date the Ruleset was last updated.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updater: Option<RulesetUpdater>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub team: Option<RulesetTeam>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RulesetTypeEnum {
    #[serde(rename = "global")]
    GLOBAL,
    #[serde(rename = "default_global")]
    DEFAULT_GLOBAL,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for RulesetTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            RulesetTypeEnum::GLOBAL => write!(f, "global"),
            RulesetTypeEnum::DEFAULT_GLOBAL => write!(f, "default_global"),
            RulesetTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for RulesetTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "global" => Ok(RulesetTypeEnum::GLOBAL),
            "default_global" => Ok(RulesetTypeEnum::DEFAULT_GLOBAL),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for RulesetTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            RulesetTypeEnum::GLOBAL => "global",
            RulesetTypeEnum::DEFAULT_GLOBAL => "default_global",
            RulesetTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for RulesetTypeEnum {
    fn default() -> Self {
        RulesetTypeEnum::GLOBAL
    }
}

/// Reference to the user that has created the Ruleset.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct RulesetCreator {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A string that determines the schema of the object
    #[serde(rename = "type")]
    #[serde(default = "RulesetCreator::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for RulesetCreator {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("ruleset_creator"),
            _self: Default::default(),
        }
    }
}

impl RulesetCreator {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("ruleset_creator")
    }
}

/// Reference to the team that owns the Ruleset. If none is specified, only admins have access.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct RulesetTeam {
    #[serde(skip_serializing_if = "String::is_empty")]
    pub id: String,
    /// A string that determines the schema of the object
    #[serde(rename = "type")]
    #[serde(default = "RulesetTeam::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for RulesetTeam {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("ruleset_team"),
            _self: Default::default(),
        }
    }
}

impl RulesetTeam {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("ruleset_team")
    }
}

/// Reference to the user that has updated the Ruleset last.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct RulesetUpdater {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// A string that determines the schema of the object
    #[serde(rename = "type")]
    #[serde(default = "RulesetUpdater::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for RulesetUpdater {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("ruleset_updater"),
            _self: Default::default(),
        }
    }
}

impl RulesetUpdater {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("ruleset_updater")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateRuleset {
    pub ruleset: AllOfrulesetsBodyRuleset,
}
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateRulesetRuleset {
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateRuleset {
    pub ruleset: Ruleset,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Schedule {
    /// The label of the tag.
    #[serde(default = "Schedule::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: ScheduleTypeEnum,
    /// A list of schedule layers.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schedule_layers: Option<Vec<ScheduleLayer>>,
    /// The time zone of the schedule.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub time_zone: String,
    /// The name of the schedule
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The description of the schedule
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub final_schedule: Option<SubSchedule>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub overrides_subschedule: Option<SubSchedule>,
    /// An array of all of the escalation policies that uses this schedule.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub escalation_policies: Option<Vec<EscalationPolicyReference>>,
    /// An array of all of the users on the schedule.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub users: Option<Vec<UserReference>>,
    /// An array of all of the teams on the schedule.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
}

#[allow(clippy::derivable_impls)]
impl Default for Schedule {
    fn default() -> Self {
        Self {
            label: String::from("Schedule"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            schedule_layers: Default::default(),
            time_zone: Default::default(),
            name: Default::default(),
            description: Default::default(),
            final_schedule: Default::default(),
            overrides_subschedule: Default::default(),
            escalation_policies: Default::default(),
            users: Default::default(),
            teams: Default::default(),
        }
    }
}

impl Schedule {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Schedule")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("schedule")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ScheduleTypeEnum {
    #[serde(rename = "schedule")]
    SCHEDULE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ScheduleTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ScheduleTypeEnum::SCHEDULE => write!(f, "schedule"),
            ScheduleTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ScheduleTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "schedule" => Ok(ScheduleTypeEnum::SCHEDULE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ScheduleTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ScheduleTypeEnum::SCHEDULE => "schedule",
            ScheduleTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ScheduleTypeEnum {
    fn default() -> Self {
        ScheduleTypeEnum::SCHEDULE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ScheduleLayer {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The start time of this layer.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<chrono::DateTime<chrono::Utc>>,
    /// The end time of this layer. If `null`, the layer does not end.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<chrono::DateTime<chrono::Utc>>,
    /// The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
    pub users: Vec<ScheduleLayerUser>,
    /// An array of restrictions for the layer. A restriction is a limit on which period of the day or week the schedule layer can accept assignments.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub restrictions: Option<Vec<Restriction>>,
    /// The effective start time of the layer. This can be before the start time of the schedule.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rotation_virtual_start: Option<chrono::DateTime<chrono::Utc>>,
    /// The duration of each on-call shift in seconds.
    pub rotation_turn_length_seconds: isize,
    /// The name of the schedule layer.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// This is a list of entries on the computed layer for the current time range. Since or until must be set in order for this field to be populated.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rendered_schedule_entries: Option<Vec<ScheduleLayerEntry>>,
    /// The percentage of the time range covered by this layer. Returns null unless since or until are set.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rendered_coverage_percentage: Option<f64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ScheduleLayerEntry {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<UserReference>,
    /// The start time of this entry.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<chrono::DateTime<chrono::Utc>>,
    /// The end time of this entry. If null, the entry does not end.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ScheduleLayerUser {
    pub user: UserReference,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ScheduleReference {
    /// The label of the tag.
    #[serde(default = "ScheduleReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: ScheduleReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for ScheduleReference {
    fn default() -> Self {
        Self {
            label: String::from("ScheduleReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl ScheduleReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("ScheduleReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("schedule_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ScheduleReferenceTypeEnum {
    #[serde(rename = "schedule_reference")]
    SCHEDULE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ScheduleReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ScheduleReferenceTypeEnum::SCHEDULE_REFERENCE => write!(f, "schedule_reference"),
            ScheduleReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ScheduleReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "schedule_reference" => Ok(ScheduleReferenceTypeEnum::SCHEDULE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ScheduleReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ScheduleReferenceTypeEnum::SCHEDULE_REFERENCE => "schedule_reference",
            ScheduleReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ScheduleReferenceTypeEnum {
    fn default() -> Self {
        ScheduleReferenceTypeEnum::SCHEDULE_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ScheduledAction {
    /// The type of schedule action. Must be set to urgency_change.
    #[serde(rename = "type")]
    pub _type: ScheduledActionTypeEnum,
    pub at: ScheduledActionAt,
    /// Urgency level. Must be set to high.
    pub to_urgency: ScheduledActionToUrgencyEnum,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ScheduledActionTypeEnum {
    #[serde(rename = "urgency_change")]
    URGENCY_CHANGE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ScheduledActionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ScheduledActionTypeEnum::URGENCY_CHANGE => write!(f, "urgency_change"),
            ScheduledActionTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ScheduledActionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "urgency_change" => Ok(ScheduledActionTypeEnum::URGENCY_CHANGE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ScheduledActionTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ScheduledActionTypeEnum::URGENCY_CHANGE => "urgency_change",
            ScheduledActionTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ScheduledActionTypeEnum {
    fn default() -> Self {
        ScheduledActionTypeEnum::URGENCY_CHANGE
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ScheduledActionToUrgencyEnum {
    #[serde(rename = "high")]
    HIGH,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ScheduledActionToUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ScheduledActionToUrgencyEnum::HIGH => write!(f, "high"),
            ScheduledActionToUrgencyEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ScheduledActionToUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "high" => Ok(ScheduledActionToUrgencyEnum::HIGH),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ScheduledActionToUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self {
            ScheduledActionToUrgencyEnum::HIGH => "high",
            ScheduledActionToUrgencyEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ScheduledActionToUrgencyEnum {
    fn default() -> Self {
        ScheduledActionToUrgencyEnum::HIGH
    }
}

/// Represents when scheduled action will occur.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ScheduledActionAt {
    /// Must be set to named_time.
    #[serde(rename = "type")]
    pub _type: ScheduledActionAtTypeEnum,
    /// Designates either the start or the end of support hours.
    pub name: ScheduledActionAtNameEnum,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ScheduledActionAtTypeEnum {
    #[serde(rename = "named_time")]
    NAMED_TIME,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ScheduledActionAtTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ScheduledActionAtTypeEnum::NAMED_TIME => write!(f, "named_time"),
            ScheduledActionAtTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ScheduledActionAtTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "named_time" => Ok(ScheduledActionAtTypeEnum::NAMED_TIME),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ScheduledActionAtTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ScheduledActionAtTypeEnum::NAMED_TIME => "named_time",
            ScheduledActionAtTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ScheduledActionAtTypeEnum {
    fn default() -> Self {
        ScheduledActionAtTypeEnum::NAMED_TIME
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ScheduledActionAtNameEnum {
    #[serde(rename = "support_hours_start")]
    START,
    #[serde(rename = "support_hours_end")]
    END,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ScheduledActionAtNameEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ScheduledActionAtNameEnum::START => write!(f, "support_hours_start"),
            ScheduledActionAtNameEnum::END => write!(f, "support_hours_end"),
            ScheduledActionAtNameEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ScheduledActionAtNameEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "support_hours_start" => Ok(ScheduledActionAtNameEnum::START),
            "support_hours_end" => Ok(ScheduledActionAtNameEnum::END),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ScheduledActionAtNameEnum {
    fn as_ref(&self) -> &str {
        match self {
            ScheduledActionAtNameEnum::START => "support_hours_start",
            ScheduledActionAtNameEnum::END => "support_hours_end",
            ScheduledActionAtNameEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ScheduledActionAtNameEnum {
    fn default() -> Self {
        ScheduledActionAtNameEnum::START
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateSchedule {
    pub schedule: Schedule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateSchedule {
    pub schedule: Schedule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateSchedulePreview {
    pub schedule: Schedule,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Service {
    /// The label of the tag.
    #[serde(default = "Service::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: ServiceTypeEnum,
    /// The name of the service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The user-provided description of the service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Time in seconds that an incident is automatically resolved if left open for that long. Value is `null` if the feature is disabled. Value must not be negative. Setting this field to `0`, `null` (or unset in POST request) will disable the feature.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auto_resolve_timeout: Option<isize>,
    /// Time in seconds that an incident changes to the Triggered State after being Acknowledged. Value is `null` if the feature is disabled. Value must not be negative. Setting this field to `0`, `null` (or unset in POST request) will disable the feature.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub acknowledgement_timeout: Option<isize>,
    /// The date/time when this service was created
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The current state of the Service. Valid statuses are:   - `active`: The service is enabled and has no open incidents. This is the only status a service can be created with. - `warning`: The service is enabled and has one or more acknowledged incidents. - `critical`: The service is enabled and has one or more triggered incidents. - `maintenance`: The service is under maintenance, no new incidents will be triggered during maintenance mode. - `disabled`: The service is disabled and will not have any new triggered incidents. 
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ServiceStatusEnum>,
    /// The date/time when the most recent incident was created for this service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_incident_timestamp: Option<chrono::DateTime<chrono::Utc>>,
    pub escalation_policy: EscalationPolicyReference,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub response_play: Option<Value>,
    /// The set of teams associated with this service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    /// An array containing Integration objects that belong to this service. If `integrations` is passed as an argument, these are full objects - otherwise, these are references.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub integrations: Option<Vec<IntegrationReference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident_urgency_rule: Option<IncidentUrgencyRule>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub support_hours: Option<SupportHours>,
    /// An array containing scheduled actions for the service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_actions: Option<Vec<ScheduledAction>>,
    /// The array of Add-ons associated with this service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub addons: Option<Vec<AddonReference>>,
    /// Whether a service creates only incidents, or both alerts and incidents. A service must create alerts in order to enable incident merging. * \"create_incidents\" - The service will create one incident and zero alerts for each incoming event. * \"create_alerts_and_incidents\" - The service will create one incident and one associated alert for each incoming event. 
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_creation: Option<ServiceAlertCreationEnum>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_grouping_parameters: Option<AlertGroupingParameters>,
    /// Defines how alerts on this service will be automatically grouped into incidents. Note that the alert grouping features are available only on certain plans. There are three available options: * null - No alert grouping on the service. Each alert will create a separate incident; * \"time\" - All alerts within a specified duration will be grouped into the same incident. This duration is set in the `alert_grouping_timeout` setting (described below). Available on Standard, Enterprise, and Event Intelligence plans; * \"intelligent\" - Alerts will be intelligently grouped based on a machine learning model that looks at the alert summary, timing, and the history of grouped alerts. Available on Enterprise and Event Intelligence plans 
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_grouping: Option<ServiceAlertGroupingEnum>,
    /// The duration in minutes within which to automatically group incoming alerts. This setting applies only when `alert_grouping` is set to `time`. To continue grouping alerts until the Incident is resolved, set this value to `0`. 
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_grouping_timeout: Option<isize>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auto_pause_notifications_parameters: Option<AutoPauseNotificationsParameters>,
}

#[allow(clippy::derivable_impls)]
impl Default for Service {
    fn default() -> Self {
        Self {
            label: String::from("Service"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            name: Default::default(),
            description: Default::default(),
            auto_resolve_timeout: Default::default(),
            acknowledgement_timeout: Default::default(),
            created_at: Default::default(),
            status: Default::default(),
            last_incident_timestamp: Default::default(),
            escalation_policy: Default::default(),
            response_play: Default::default(),
            teams: Default::default(),
            integrations: Default::default(),
            incident_urgency_rule: Default::default(),
            support_hours: Default::default(),
            scheduled_actions: Default::default(),
            addons: Default::default(),
            alert_creation: Default::default(),
            alert_grouping_parameters: Default::default(),
            alert_grouping: Default::default(),
            alert_grouping_timeout: Default::default(),
            auto_pause_notifications_parameters: Default::default(),
        }
    }
}

impl Service {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Service")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("service")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ServiceTypeEnum {
    #[serde(rename = "service")]
    SERVICE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ServiceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ServiceTypeEnum::SERVICE => write!(f, "service"),
            ServiceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ServiceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "service" => Ok(ServiceTypeEnum::SERVICE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ServiceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ServiceTypeEnum::SERVICE => "service",
            ServiceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ServiceTypeEnum {
    fn default() -> Self {
        ServiceTypeEnum::SERVICE
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ServiceStatusEnum {
    #[serde(rename = "active")]
    ACTIVE,
    #[serde(rename = "warning")]
    WARNING,
    #[serde(rename = "critical")]
    CRITICAL,
    #[serde(rename = "maintenance")]
    MAINTENANCE,
    #[serde(rename = "disabled")]
    DISABLED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ServiceStatusEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ServiceStatusEnum::ACTIVE => write!(f, "active"),
            ServiceStatusEnum::WARNING => write!(f, "warning"),
            ServiceStatusEnum::CRITICAL => write!(f, "critical"),
            ServiceStatusEnum::MAINTENANCE => write!(f, "maintenance"),
            ServiceStatusEnum::DISABLED => write!(f, "disabled"),
            ServiceStatusEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ServiceStatusEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "active" => Ok(ServiceStatusEnum::ACTIVE),
            "warning" => Ok(ServiceStatusEnum::WARNING),
            "critical" => Ok(ServiceStatusEnum::CRITICAL),
            "maintenance" => Ok(ServiceStatusEnum::MAINTENANCE),
            "disabled" => Ok(ServiceStatusEnum::DISABLED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ServiceStatusEnum {
    fn as_ref(&self) -> &str {
        match self {
            ServiceStatusEnum::ACTIVE => "active",
            ServiceStatusEnum::WARNING => "warning",
            ServiceStatusEnum::CRITICAL => "critical",
            ServiceStatusEnum::MAINTENANCE => "maintenance",
            ServiceStatusEnum::DISABLED => "disabled",
            ServiceStatusEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ServiceStatusEnum {
    fn default() -> Self {
        ServiceStatusEnum::ACTIVE
    }
}
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ServiceResponsePlay {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _type: Option<String>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ServiceAlertCreationEnum {
    #[serde(rename = "create_incidents")]
    INCIDENTS,
    #[serde(rename = "create_alerts_and_incidents")]
    ALERTS_AND_INCIDENTS,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ServiceAlertCreationEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ServiceAlertCreationEnum::INCIDENTS => write!(f, "create_incidents"),
            ServiceAlertCreationEnum::ALERTS_AND_INCIDENTS => write!(f, "create_alerts_and_incidents"),
            ServiceAlertCreationEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ServiceAlertCreationEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "create_incidents" => Ok(ServiceAlertCreationEnum::INCIDENTS),
            "create_alerts_and_incidents" => Ok(ServiceAlertCreationEnum::ALERTS_AND_INCIDENTS),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ServiceAlertCreationEnum {
    fn as_ref(&self) -> &str {
        match self {
            ServiceAlertCreationEnum::INCIDENTS => "create_incidents",
            ServiceAlertCreationEnum::ALERTS_AND_INCIDENTS => "create_alerts_and_incidents",
            ServiceAlertCreationEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ServiceAlertCreationEnum {
    fn default() -> Self {
        ServiceAlertCreationEnum::INCIDENTS
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ServiceAlertGroupingEnum {
    #[serde(rename = "time")]
    TIME,
    #[serde(rename = "intelligent")]
    INTELLIGENT,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ServiceAlertGroupingEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ServiceAlertGroupingEnum::TIME => write!(f, "time"),
            ServiceAlertGroupingEnum::INTELLIGENT => write!(f, "intelligent"),
            ServiceAlertGroupingEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ServiceAlertGroupingEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "time" => Ok(ServiceAlertGroupingEnum::TIME),
            "intelligent" => Ok(ServiceAlertGroupingEnum::INTELLIGENT),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ServiceAlertGroupingEnum {
    fn as_ref(&self) -> &str {
        match self {
            ServiceAlertGroupingEnum::TIME => "time",
            ServiceAlertGroupingEnum::INTELLIGENT => "intelligent",
            ServiceAlertGroupingEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ServiceAlertGroupingEnum {
    fn default() -> Self {
        ServiceAlertGroupingEnum::TIME
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateServiceDependency {
    /// List of all service dependencies to be created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub relationships: Option<Vec<ServiceDependenciesassociateRelationships>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct DeleteServiceDependency {
    /// List of all service dependencies to be deleted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub relationships: Option<Vec<ServiceDependenciesassociateRelationships>>,
}

/// The reference to the service that is dependent on the supporting service.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ServiceDependenciesassociateDependentService {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    #[serde(default = "ServiceDependenciesassociateDependentService::_type_default")]
    pub _type: String,
}

#[allow(clippy::derivable_impls)]
impl Default for ServiceDependenciesassociateDependentService {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("service_dependenciesassociate_dependent_service"),
        }
    }
}

impl ServiceDependenciesassociateDependentService {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("service_dependenciesassociate_dependent_service")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ServiceDependenciesassociateRelationships {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supporting_service: Option<ServiceDependenciesassociateSupportingService>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dependent_service: Option<ServiceDependenciesassociateDependentService>,
}

/// The reference to the service that supports the dependent service.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ServiceDependenciesassociateSupportingService {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    #[serde(default = "ServiceDependenciesassociateSupportingService::_type_default")]
    pub _type: String,
}

#[allow(clippy::derivable_impls)]
impl Default for ServiceDependenciesassociateSupportingService {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("service_dependenciesassociate_supporting_service"),
        }
    }
}

impl ServiceDependenciesassociateSupportingService {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("service_dependenciesassociate_supporting_service")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ServiceEventRule {
    /// Indicates whether the Event Rule is the last Event Rule of the Ruleset that serves as a catch-all. It has limited functionality compared to other rules and always matches.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub catch_all: Option<bool>,
    /// [Early Access] Populate variables from event payloads and use those variables in other event actions.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variables: Option<Vec<EventRuleVariables>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_frame: Option<EventRuleTimeFrame>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conditions: Option<EventRuleConditions>,
    /// Indicates whether the Event Rule is disabled and would therefore not be evaluated.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disabled: Option<bool>,
    /// the API show URL at which the object is accessible.
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// ID of the Event Rule.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Position/index of the Event Rule on the Service.  Starting from position 0 (the first rule), rules are evaluated one-by-one until a matching Event Rule is found or the end of the list is reached.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<isize>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<EventRuleActionsCommon>,
}

#[allow(clippy::derivable_impls)]
impl Default for ServiceEventRule {
    fn default() -> Self {
        Self {
            catch_all: Default::default(),
            variables: Default::default(),
            time_frame: Default::default(),
            conditions: Default::default(),
            disabled: Default::default(),
            _self: Default::default(),
            id: Default::default(),
            position: Default::default(),
            actions: Default::default(),
        }
    }
}

impl ServiceEventRule {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("ServiceEventRule")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("service_event_rule")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateOrchPathService {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub orchestration_path: Option<ServiceOrchestrationOrchestrationPath>,
}

#[allow(clippy::derivable_impls)]
impl Default for UpdateOrchPathService {
    fn default() -> Self {
        Self {
            orchestration_path: Default::default(),
        }
    }
}

impl UpdateOrchPathService {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("ServiceOrchestration")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("service_orchestration")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ServiceOrchestrationOrchestrationPath {
    /// Indicates that these are sets of rules belonging to a service.
    #[serde(rename = "type")]
    #[serde(default = "ServiceOrchestrationOrchestrationPath::_type_default")]
    pub _type: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<ServiceOrchestrationOrchestrationPathParent>,
    /// A Service Orchestration must contain at least a \"start\" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sets: Option<Vec<ServiceOrchestrationOrchestrationPathSets>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub catch_all: Option<ServiceOrchestrationOrchestrationPathCatchAll>,
}

#[allow(clippy::derivable_impls)]
impl Default for ServiceOrchestrationOrchestrationPath {
    fn default() -> Self {
        Self {
            _type: String::from("service_orchestration_orchestration_path"),
            parent: Default::default(),
            sets: Default::default(),
            catch_all: Default::default(),
        }
    }
}

impl ServiceOrchestrationOrchestrationPath {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("service_orchestration_orchestration_path")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ServiceOrchestrationOrchestrationPathCatchAll {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<ServiceOrchestrationOrchestrationPathCatchAllActions>,
}
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ServiceOrchestrationOrchestrationPathCatchAllActions {
    /// Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
    #[serde(rename = "suppress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suppress: Option<bool>,
    /// The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a resolve event arrives before the alert triggers then PagerDuty won't create an incident for this the resulting alert.
    #[serde(rename = "suspend")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suspend: Option<isize>,
    /// The ID of the priority you want to set on resulting incident. You can find the list of priority IDs for your account by calling the priorities endpoint.
    #[serde(rename = "priority")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<String>,
    /// Add this text as a note on the resulting incident.
    #[serde(rename = "annotate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub annotate: Option<String>,
    /// Configure an Automation Action associated with the resulting incident.
    #[serde(rename = "pagerduty_automation_actions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pagerduty_automation_actions: Option<Vec<Value>>,
    /// Create a Webhoook associated with the resulting incident.
    #[serde(rename = "automation_actions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub automation_actions: Option<Vec<Value>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ServiceOrchestrationOrchestrationPathParent {
    /// The ID of the Service this Orchestration belongs to.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<Value>,
    #[serde(rename = "type")]
    #[serde(default = "ServiceOrchestrationOrchestrationPathParent::_type_default")]
    pub _type: String,
}

#[allow(clippy::derivable_impls)]
impl Default for ServiceOrchestrationOrchestrationPathParent {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("service_orchestration_orchestration_path_parent"),
        }
    }
}

impl ServiceOrchestrationOrchestrationPathParent {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("service_orchestration_orchestration_path_parent")
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ServiceOrchestrationOrchestrationPathRules {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<ServiceOrchestrationOrchestrationPathRulesActions>,
}
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ServiceOrchestrationOrchestrationPathRulesActions {
    /// The ID of a Set from this Service Orchestration whose rules you also want to use with event that match this rule.
    #[serde(rename = "route_to")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub route_to: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ServiceOrchestrationOrchestrationPathSets {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<ServiceOrchestrationOrchestrationPathRules>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct ServiceReference {
    /// The label of the tag.
    #[serde(default = "ServiceReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: ServiceReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for ServiceReference {
    fn default() -> Self {
        Self {
            label: String::from("ServiceReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl ServiceReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("ServiceReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("service_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ServiceReferenceTypeEnum {
    #[serde(rename = "service_reference")]
    SERVICE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for ServiceReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            ServiceReferenceTypeEnum::SERVICE_REFERENCE => write!(f, "service_reference"),
            ServiceReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for ServiceReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "service_reference" => Ok(ServiceReferenceTypeEnum::SERVICE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for ServiceReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            ServiceReferenceTypeEnum::SERVICE_REFERENCE => "service_reference",
            ServiceReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for ServiceReferenceTypeEnum {
    fn default() -> Self {
        ServiceReferenceTypeEnum::SERVICE_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateService {
    pub service: Service,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateService {
    pub service: Service,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct SnoozeLogEntry {
    #[serde(rename = "type")]
    pub _type: SnoozeLogEntryTypeEnum,
    /// Time at which the log entry was created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel: Option<Channel>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent: Option<AgentReference>,
    /// Optional field containing a note, if one was included with the log entry.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub note: Option<String>,
    /// Contexts to be included with the trigger such as links to graphs or images.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contexts: Option<Vec<Context>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service: Option<ServiceReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<UserReference>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<IncidentReference>,
    /// Will consist of references unless included
    #[serde(skip_serializing_if = "Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_details: Option<LogEntryEventDetails>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub changed_actions: Option<Vec<IncidentAction>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum SnoozeLogEntryTypeEnum {
    #[serde(rename = "snooze_log_entry")]
    SNOOZE_LOG_ENTRY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for SnoozeLogEntryTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            SnoozeLogEntryTypeEnum::SNOOZE_LOG_ENTRY => write!(f, "snooze_log_entry"),
            SnoozeLogEntryTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for SnoozeLogEntryTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "snooze_log_entry" => Ok(SnoozeLogEntryTypeEnum::SNOOZE_LOG_ENTRY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for SnoozeLogEntryTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            SnoozeLogEntryTypeEnum::SNOOZE_LOG_ENTRY => "snooze_log_entry",
            SnoozeLogEntryTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for SnoozeLogEntryTypeEnum {
    fn default() -> Self {
        SnoozeLogEntryTypeEnum::SNOOZE_LOG_ENTRY
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct StatusDashboard {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url_slug: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct StatusUpdate {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The message of the status update.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// The date/time when this status update was created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sender: Option<UserReference>,
    /// The subject of the custom html email status update. Present if included in request body.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subject: Option<String>,
    /// The html content of the custom html email status update. Present if included in request body.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_message: Option<String>,
}

/// A rule for contacting the user for Incident Status Updates.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct StatusUpdateNotificationRule {
    pub contact_method: ContactMethodReference,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateUserStatusUpdateNotificationRule {
    pub status_update_notification_rule: StatusUpdateNotificationRule,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateIncidentNotificationSubscribers {
    pub subscribers: Vec<NotificationSubscriber>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct RemoveIncidentNotificationSubscribers {
    pub subscribers: Vec<NotificationSubscriber>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct SubSchedule {
    /// The name of the subschedule
    pub name: SubScheduleNameEnum,
    /// This is a list of entries on the computed layer for the current time range. Since or until must be set in order for this field to be populated.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rendered_schedule_entries: Option<Vec<ScheduleLayerEntry>>,
    /// The percentage of the time range covered by this layer. Returns null unless since or until are set.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rendered_coverage_percentage: Option<f64>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum SubScheduleNameEnum {
    #[serde(rename = "Final Schedule")]
    FINAL_SCHEDULE,
    #[serde(rename = "Overrides")]
    OVERRIDES,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for SubScheduleNameEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            SubScheduleNameEnum::FINAL_SCHEDULE => write!(f, "Final Schedule"),
            SubScheduleNameEnum::OVERRIDES => write!(f, "Overrides"),
            SubScheduleNameEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for SubScheduleNameEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Final Schedule" => Ok(SubScheduleNameEnum::FINAL_SCHEDULE),
            "Overrides" => Ok(SubScheduleNameEnum::OVERRIDES),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for SubScheduleNameEnum {
    fn as_ref(&self) -> &str {
        match self {
            SubScheduleNameEnum::FINAL_SCHEDULE => "Final Schedule",
            SubScheduleNameEnum::OVERRIDES => "Overrides",
            SubScheduleNameEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for SubScheduleNameEnum {
    fn default() -> Self {
        SubScheduleNameEnum::FINAL_SCHEDULE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct SupportHours {
    /// The type of support hours
    #[serde(rename = "type")]
    pub _type: SupportHoursTypeEnum,
    /// The time zone for the support hours
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_zone: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub days_of_week: Option<Vec<i32>>,
    /// The support hours' starting time of day (date portion is ignored)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_time: Option<String>,
    /// The support hours' ending time of day (date portion is ignored)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum SupportHoursTypeEnum {
    #[serde(rename = "fixed_time_per_day")]
    FIXED_TIME_PER_DAY,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for SupportHoursTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            SupportHoursTypeEnum::FIXED_TIME_PER_DAY => write!(f, "fixed_time_per_day"),
            SupportHoursTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for SupportHoursTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "fixed_time_per_day" => Ok(SupportHoursTypeEnum::FIXED_TIME_PER_DAY),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for SupportHoursTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            SupportHoursTypeEnum::FIXED_TIME_PER_DAY => "fixed_time_per_day",
            SupportHoursTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for SupportHoursTypeEnum {
    fn default() -> Self {
        SupportHoursTypeEnum::FIXED_TIME_PER_DAY
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Tag {
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: TagTypeEnum,
    /// The label of the tag.
    #[serde(default = "Tag::label_default")]
    pub label: String,
}

#[allow(clippy::derivable_impls)]
impl Default for Tag {
    fn default() -> Self {
        Self {
            _type: Default::default(),
            label: String::from("Tag"),
        }
    }
}

impl Tag {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Tag")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum TagTypeEnum {
    #[serde(rename = "tag")]
    TAG,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for TagTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            TagTypeEnum::TAG => write!(f, "tag"),
            TagTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for TagTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "tag" => Ok(TagTypeEnum::TAG),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for TagTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            TagTypeEnum::TAG => "tag",
            TagTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for TagTypeEnum {
    fn default() -> Self {
        TagTypeEnum::TAG
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct TagReference {
    /// The label of the tag.
    #[serde(default = "TagReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: TagReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for TagReference {
    fn default() -> Self {
        Self {
            label: String::from("TagReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl TagReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("TagReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("tag_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum TagReferenceTypeEnum {
    #[serde(rename = "tag_reference")]
    TAG_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for TagReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            TagReferenceTypeEnum::TAG_REFERENCE => write!(f, "tag_reference"),
            TagReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for TagReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "tag_reference" => Ok(TagReferenceTypeEnum::TAG_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for TagReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            TagReferenceTypeEnum::TAG_REFERENCE => "tag_reference",
            TagReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for TagReferenceTypeEnum {
    fn default() -> Self {
        TagReferenceTypeEnum::TAG_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateTags {
    pub tag: Tag,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct TagsToAdd {
    #[serde(rename = "type")]
    pub _type: TagsToAddTypeEnum,
    /// The label of the tag. Should be used when type is \"tag\".
    #[serde(default = "TagsToAdd::label_default")]
    pub label: String,
    /// The id of the tag. Should be used when type is \"tag_reference\".
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for TagsToAdd {
    fn default() -> Self {
        Self {
            _type: Default::default(),
            label: String::from("Tags to add"),
            id: Default::default(),
        }
    }
}

impl TagsToAdd {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Tags to add")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum TagsToAddTypeEnum {
    #[serde(rename = "tag")]
    TAG,
    #[serde(rename = "tag_reference")]
    TAG_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for TagsToAddTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            TagsToAddTypeEnum::TAG => write!(f, "tag"),
            TagsToAddTypeEnum::TAG_REFERENCE => write!(f, "tag_reference"),
            TagsToAddTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for TagsToAddTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "tag" => Ok(TagsToAddTypeEnum::TAG),
            "tag_reference" => Ok(TagsToAddTypeEnum::TAG_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for TagsToAddTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            TagsToAddTypeEnum::TAG => "tag",
            TagsToAddTypeEnum::TAG_REFERENCE => "tag_reference",
            TagsToAddTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for TagsToAddTypeEnum {
    fn default() -> Self {
        TagsToAddTypeEnum::TAG
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct TagsToRemove_ {
    #[serde(rename = "type")]
    pub _type: TagsToRemove_TypeEnum,
    /// The id of the tag
    #[serde(skip_serializing_if = "String::is_empty")]
    pub id: String,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum TagsToRemove_TypeEnum {
    #[serde(rename = "tag_reference")]
    TAG_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for TagsToRemove_TypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            TagsToRemove_TypeEnum::TAG_REFERENCE => write!(f, "tag_reference"),
            TagsToRemove_TypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for TagsToRemove_TypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "tag_reference" => Ok(TagsToRemove_TypeEnum::TAG_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for TagsToRemove_TypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            TagsToRemove_TypeEnum::TAG_REFERENCE => "tag_reference",
            TagsToRemove_TypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for TagsToRemove_TypeEnum {
    fn default() -> Self {
        TagsToRemove_TypeEnum::TAG_REFERENCE
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Team {
    /// The label of the tag.
    #[serde(default = "Team::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: TeamTypeEnum,
    /// The name of the team.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub name: String,
    /// The description of the team.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<TeamReference>,
}

#[allow(clippy::derivable_impls)]
impl Default for Team {
    fn default() -> Self {
        Self {
            label: String::from("Team"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
            name: Default::default(),
            description: Default::default(),
            parent: Default::default(),
        }
    }
}

impl Team {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Team")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("team")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum TeamTypeEnum {
    #[serde(rename = "team")]
    TEAM,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for TeamTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            TeamTypeEnum::TEAM => write!(f, "team"),
            TeamTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for TeamTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "team" => Ok(TeamTypeEnum::TEAM),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for TeamTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            TeamTypeEnum::TEAM => "team",
            TeamTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for TeamTypeEnum {
    fn default() -> Self {
        TeamTypeEnum::TEAM
    }
}

/// Reference to the team that owns the Business Service.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Team1 {
    /// The Team ID
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// Reference to the team that owns the Business Service.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Team2 {
    /// The team ID
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// Reference to the team that owns the business service.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Team3 {
    #[serde(skip_serializing_if = "String::is_empty")]
    pub id: String,
    /// A string that determines the schema of the object.
    #[serde(rename = "type")]
    #[serde(default = "Team3::_type_default")]
    pub _type: String,
    /// The API show URL at which the object is accessible.
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for Team3 {
    fn default() -> Self {
        Self {
            id: Default::default(),
            _type: String::from("team_3"),
            _self: Default::default(),
        }
    }
}

impl Team3 {
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("team_3")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct TeamReference {
    /// The label of the tag.
    #[serde(default = "TeamReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: TeamReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for TeamReference {
    fn default() -> Self {
        Self {
            label: String::from("TeamReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl TeamReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("TeamReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("team_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum TeamReferenceTypeEnum {
    #[serde(rename = "team_reference")]
    TEAM_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for TeamReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            TeamReferenceTypeEnum::TEAM_REFERENCE => write!(f, "team_reference"),
            TeamReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for TeamReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "team_reference" => Ok(TeamReferenceTypeEnum::TEAM_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for TeamReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            TeamReferenceTypeEnum::TEAM_REFERENCE => "team_reference",
            TeamReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for TeamReferenceTypeEnum {
    fn default() -> Self {
        TeamReferenceTypeEnum::TEAM_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateTeam {
    pub team: Team,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateTeam {
    pub team: Team,
}

/// The configuration for Time Based Alert Grouping
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct TimeBasedAlertGroupingConfiguration {
    /// The duration in minutes within which to automatically group incoming Alerts.  To continue grouping Alerts until the Incident is resolved, set this value to 0.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<isize>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct User {
    /// The label of the tag.
    #[serde(default = "User::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The name of the user.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub name: String,
    /// The type of object being created.
    #[serde(rename = "type")]
    pub _type: UserTypeEnum,
    /// The user's email address.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub email: String,
    /// The preferred time zone name. If null, the account's time zone will be used.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_zone: Option<String>,
    /// The schedule color.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<String>,
    /// The user role. Account must have the `read_only_users` ability to set a user as a `read_only_user` or a `read_only_limited_user`, and must have advanced permissions abilities to set a user as `observer` or `restricted_access`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<UserRoleEnum>,
    /// The URL of the user's avatar.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub avatar_url: Option<String>,
    /// The user's bio.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// If true, the user has an outstanding invitation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invitation_sent: Option<bool>,
    /// The user's title.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_title: Option<String>,
    /// The list of teams to which the user belongs. Account must have the `teams` ability to set this.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub teams: Option<Vec<TeamReference>>,
    /// The list of contact methods for the user.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contact_methods: Option<Vec<ContactMethodReference>>,
    /// The list of notification rules for the user.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notification_rules: Option<Vec<NotificationRuleReference>>,
}

#[allow(clippy::derivable_impls)]
impl Default for User {
    fn default() -> Self {
        Self {
            label: String::from("User"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            name: Default::default(),
            _type: Default::default(),
            email: Default::default(),
            time_zone: Default::default(),
            color: Default::default(),
            role: Default::default(),
            avatar_url: Default::default(),
            description: Default::default(),
            invitation_sent: Default::default(),
            job_title: Default::default(),
            teams: Default::default(),
            contact_methods: Default::default(),
            notification_rules: Default::default(),
        }
    }
}

impl User {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("User")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("user")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum UserTypeEnum {
    #[serde(rename = "user")]
    USER,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for UserTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            UserTypeEnum::USER => write!(f, "user"),
            UserTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for UserTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "user" => Ok(UserTypeEnum::USER),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for UserTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            UserTypeEnum::USER => "user",
            UserTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for UserTypeEnum {
    fn default() -> Self {
        UserTypeEnum::USER
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum UserRoleEnum {
    #[serde(rename = "admin")]
    ADMIN,
    #[serde(rename = "limited_user")]
    LIMITED_USER,
    #[serde(rename = "observer")]
    OBSERVER,
    #[serde(rename = "owner")]
    OWNER,
    #[serde(rename = "read_only_user")]
    READ_ONLY_USER,
    #[serde(rename = "restricted_access")]
    RESTRICTED_ACCESS,
    #[serde(rename = "read_only_limited_user")]
    READ_ONLY_LIMITED_USER,
    #[serde(rename = "user")]
    USER,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for UserRoleEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            UserRoleEnum::ADMIN => write!(f, "admin"),
            UserRoleEnum::LIMITED_USER => write!(f, "limited_user"),
            UserRoleEnum::OBSERVER => write!(f, "observer"),
            UserRoleEnum::OWNER => write!(f, "owner"),
            UserRoleEnum::READ_ONLY_USER => write!(f, "read_only_user"),
            UserRoleEnum::RESTRICTED_ACCESS => write!(f, "restricted_access"),
            UserRoleEnum::READ_ONLY_LIMITED_USER => write!(f, "read_only_limited_user"),
            UserRoleEnum::USER => write!(f, "user"),
            UserRoleEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for UserRoleEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "admin" => Ok(UserRoleEnum::ADMIN),
            "limited_user" => Ok(UserRoleEnum::LIMITED_USER),
            "observer" => Ok(UserRoleEnum::OBSERVER),
            "owner" => Ok(UserRoleEnum::OWNER),
            "read_only_user" => Ok(UserRoleEnum::READ_ONLY_USER),
            "restricted_access" => Ok(UserRoleEnum::RESTRICTED_ACCESS),
            "read_only_limited_user" => Ok(UserRoleEnum::READ_ONLY_LIMITED_USER),
            "user" => Ok(UserRoleEnum::USER),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for UserRoleEnum {
    fn as_ref(&self) -> &str {
        match self {
            UserRoleEnum::ADMIN => "admin",
            UserRoleEnum::LIMITED_USER => "limited_user",
            UserRoleEnum::OBSERVER => "observer",
            UserRoleEnum::OWNER => "owner",
            UserRoleEnum::READ_ONLY_USER => "read_only_user",
            UserRoleEnum::RESTRICTED_ACCESS => "restricted_access",
            UserRoleEnum::READ_ONLY_LIMITED_USER => "read_only_limited_user",
            UserRoleEnum::USER => "user",
            UserRoleEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for UserRoleEnum {
    fn default() -> Self {
        UserRoleEnum::ADMIN
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UserReference {
    /// The label of the tag.
    #[serde(default = "UserReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: UserReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for UserReference {
    fn default() -> Self {
        Self {
            label: String::from("UserReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl UserReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("UserReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("user_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum UserReferenceTypeEnum {
    #[serde(rename = "user_reference")]
    USER_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for UserReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            UserReferenceTypeEnum::USER_REFERENCE => write!(f, "user_reference"),
            UserReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for UserReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "user_reference" => Ok(UserReferenceTypeEnum::USER_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for UserReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            UserReferenceTypeEnum::USER_REFERENCE => "user_reference",
            UserReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for UserReferenceTypeEnum {
    fn default() -> Self {
        UserReferenceTypeEnum::USER_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UserRole {
    /// The role of the user for a set of resources.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<UserRoleRoleEnum>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<Reference>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum UserRoleRoleEnum {
    #[serde(rename = "observer")]
    OBSERVER,
    #[serde(rename = "responder")]
    RESPONDER,
    #[serde(rename = "manager")]
    MANAGER,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for UserRoleRoleEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            UserRoleRoleEnum::OBSERVER => write!(f, "observer"),
            UserRoleRoleEnum::RESPONDER => write!(f, "responder"),
            UserRoleRoleEnum::MANAGER => write!(f, "manager"),
            UserRoleRoleEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for UserRoleRoleEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "observer" => Ok(UserRoleRoleEnum::OBSERVER),
            "responder" => Ok(UserRoleRoleEnum::RESPONDER),
            "manager" => Ok(UserRoleRoleEnum::MANAGER),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for UserRoleRoleEnum {
    fn as_ref(&self) -> &str {
        match self {
            UserRoleRoleEnum::OBSERVER => "observer",
            UserRoleRoleEnum::RESPONDER => "responder",
            UserRoleRoleEnum::MANAGER => "manager",
            UserRoleRoleEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for UserRoleRoleEnum {
    fn default() -> Self {
        UserRoleRoleEnum::OBSERVER
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UserSession {
    #[serde(skip_serializing_if = "String::is_empty")]
    pub id: String,
    #[serde(skip_serializing_if = "String::is_empty")]
    pub user_id: String,
    /// The date/time the user session was first created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The type of the session
    #[serde(rename = "type")]
    pub _type: UserSessionTypeEnum,
    /// The summary of the session
    #[serde(skip_serializing_if = "String::is_empty")]
    pub summary: String,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum UserSessionTypeEnum {
    #[serde(rename = "browser")]
    BROWSER,
    #[serde(rename = "oauth")]
    OAUTH,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for UserSessionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            UserSessionTypeEnum::BROWSER => write!(f, "browser"),
            UserSessionTypeEnum::OAUTH => write!(f, "oauth"),
            UserSessionTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for UserSessionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "browser" => Ok(UserSessionTypeEnum::BROWSER),
            "oauth" => Ok(UserSessionTypeEnum::OAUTH),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for UserSessionTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            UserSessionTypeEnum::BROWSER => "browser",
            UserSessionTypeEnum::OAUTH => "oauth",
            UserSessionTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for UserSessionTypeEnum {
    fn default() -> Self {
        UserSessionTypeEnum::BROWSER
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateUser {
    pub user: User,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateUser {
    pub user: User,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateTeamUser {
    /// The role of the user on the team.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<UpdateTeamUserRoleEnum>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum UpdateTeamUserRoleEnum {
    #[serde(rename = "observer")]
    OBSERVER,
    #[serde(rename = "responder")]
    RESPONDER,
    #[serde(rename = "manager")]
    MANAGER,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for UpdateTeamUserRoleEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            UpdateTeamUserRoleEnum::OBSERVER => write!(f, "observer"),
            UpdateTeamUserRoleEnum::RESPONDER => write!(f, "responder"),
            UpdateTeamUserRoleEnum::MANAGER => write!(f, "manager"),
            UpdateTeamUserRoleEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for UpdateTeamUserRoleEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "observer" => Ok(UpdateTeamUserRoleEnum::OBSERVER),
            "responder" => Ok(UpdateTeamUserRoleEnum::RESPONDER),
            "manager" => Ok(UpdateTeamUserRoleEnum::MANAGER),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for UpdateTeamUserRoleEnum {
    fn as_ref(&self) -> &str {
        match self {
            UpdateTeamUserRoleEnum::OBSERVER => "observer",
            UpdateTeamUserRoleEnum::RESPONDER => "responder",
            UpdateTeamUserRoleEnum::MANAGER => "manager",
            UpdateTeamUserRoleEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for UpdateTeamUserRoleEnum {
    fn default() -> Self {
        UpdateTeamUserRoleEnum::OBSERVER
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Vendor {
    /// The label of the tag.
    #[serde(default = "Vendor::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
    #[serde(rename = "type")]
    #[serde(default = "Vendor::_type_default")]
    pub _type: String,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The short name of the vendor
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// URL of the vendor's main website
    #[serde(skip_serializing_if = "Option::is_none")]
    pub website_url: Option<String>,
    /// URL of a logo identifying the vendor
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logo_url: Option<String>,
    /// URL of a small thumbnail image identifying the vendor
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thumbnail_url: Option<String>,
    /// A short description of this vendor, and common use-cases of integrations for this vendor.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// URL of an integration guide for this vendor
    #[serde(skip_serializing_if = "Option::is_none")]
    pub integration_guide_url: Option<String>,
}

#[allow(clippy::derivable_impls)]
impl Default for Vendor {
    fn default() -> Self {
        Self {
            label: String::from("Vendor"),
            html_url: Default::default(),
            _self: Default::default(),
            _type: String::from("vendor"),
            summary: Default::default(),
            id: Default::default(),
            name: Default::default(),
            website_url: Default::default(),
            logo_url: Default::default(),
            thumbnail_url: Default::default(),
            description: Default::default(),
            integration_guide_url: Default::default(),
        }
    }
}

impl Vendor {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("Vendor")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("vendor")
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct VendorReference {
    /// The label of the tag.
    #[serde(default = "VendorReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: VendorReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for VendorReference {
    fn default() -> Self {
        Self {
            label: String::from("VendorReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl VendorReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("VendorReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("vendor_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum VendorReferenceTypeEnum {
    #[serde(rename = "vendor_reference")]
    VENDOR_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for VendorReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            VendorReferenceTypeEnum::VENDOR_REFERENCE => write!(f, "vendor_reference"),
            VendorReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for VendorReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "vendor_reference" => Ok(VendorReferenceTypeEnum::VENDOR_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for VendorReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            VendorReferenceTypeEnum::VENDOR_REFERENCE => "vendor_reference",
            VendorReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for VendorReferenceTypeEnum {
    fn default() -> Self {
        VendorReferenceTypeEnum::VENDOR_REFERENCE
    }
}

/// Information about the configured webhook.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct Webhook {
    /// The url endpoint the webhook payload is sent to.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint_url: Option<String>,
    /// The name of the webhook.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub webhook_object: Option<WebhookObject>,
    /// The object that contains webhook configuration values depending on the webhook type specification.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub config: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub outbound_integration: Option<OutboundIntegrationReference>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhookIncidentAction {
    /// Uniquely identifies this outgoing webhook message; can be used for idempotency when processing the messages.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<uuid::Uuid>,
    /// The date/time when this message was was sent.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub triggered_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub webhook: Option<Webhook>,
    /// The type of action being reported by this message. * `incident.trigger` - Sent when an incident is newly created/triggered. * `incident.acknowledge` - Sent when an incident is acknowledged by a user. * `incident.unacknowledge` - Sent when an incident is unacknowledged due to its acknowledgement timing out. * `incident.resolve` - Sent when an incident has been resolved. * `incident.assign` - Sent when an incident has been assigned to another user. Often occurs in concert with an `acknowledge`. * `incident.escalate` - Sent when an incident has been escalated to another user in the same escalation chain. * `incident.delegate` - Sent when an incident has been reassigned to another escalation policy. * `incident.annotate` - Sent when a note is created on an incident. 
    #[serde(rename = "type")]
    pub _type: WebhookIncidentActionTypeEnum,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<Incident>,
    /// Log Entries that correspond to the action this Webhook is reporting. Includes the channels.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub log_entries: Option<Vec<LogEntry>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhookIncidentActionTypeEnum {
    #[serde(rename = "incident.trigger")]
    TRIGGER,
    #[serde(rename = "incident.acknowledge")]
    ACKNOWLEDGE,
    #[serde(rename = "incident.unacknowledge")]
    UNACKNOWLEDGE,
    #[serde(rename = "incident.resolve")]
    RESOLVE,
    #[serde(rename = "incident.assign")]
    ASSIGN,
    #[serde(rename = "incident.escalate")]
    ESCALATE,
    #[serde(rename = "incident.delegate")]
    DELEGATE,
    #[serde(rename = "incident.annotate")]
    ANNOTATE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhookIncidentActionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            WebhookIncidentActionTypeEnum::TRIGGER => write!(f, "incident.trigger"),
            WebhookIncidentActionTypeEnum::ACKNOWLEDGE => write!(f, "incident.acknowledge"),
            WebhookIncidentActionTypeEnum::UNACKNOWLEDGE => write!(f, "incident.unacknowledge"),
            WebhookIncidentActionTypeEnum::RESOLVE => write!(f, "incident.resolve"),
            WebhookIncidentActionTypeEnum::ASSIGN => write!(f, "incident.assign"),
            WebhookIncidentActionTypeEnum::ESCALATE => write!(f, "incident.escalate"),
            WebhookIncidentActionTypeEnum::DELEGATE => write!(f, "incident.delegate"),
            WebhookIncidentActionTypeEnum::ANNOTATE => write!(f, "incident.annotate"),
            WebhookIncidentActionTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhookIncidentActionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "incident.trigger" => Ok(WebhookIncidentActionTypeEnum::TRIGGER),
            "incident.acknowledge" => Ok(WebhookIncidentActionTypeEnum::ACKNOWLEDGE),
            "incident.unacknowledge" => Ok(WebhookIncidentActionTypeEnum::UNACKNOWLEDGE),
            "incident.resolve" => Ok(WebhookIncidentActionTypeEnum::RESOLVE),
            "incident.assign" => Ok(WebhookIncidentActionTypeEnum::ASSIGN),
            "incident.escalate" => Ok(WebhookIncidentActionTypeEnum::ESCALATE),
            "incident.delegate" => Ok(WebhookIncidentActionTypeEnum::DELEGATE),
            "incident.annotate" => Ok(WebhookIncidentActionTypeEnum::ANNOTATE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhookIncidentActionTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            WebhookIncidentActionTypeEnum::TRIGGER => "incident.trigger",
            WebhookIncidentActionTypeEnum::ACKNOWLEDGE => "incident.acknowledge",
            WebhookIncidentActionTypeEnum::UNACKNOWLEDGE => "incident.unacknowledge",
            WebhookIncidentActionTypeEnum::RESOLVE => "incident.resolve",
            WebhookIncidentActionTypeEnum::ASSIGN => "incident.assign",
            WebhookIncidentActionTypeEnum::ESCALATE => "incident.escalate",
            WebhookIncidentActionTypeEnum::DELEGATE => "incident.delegate",
            WebhookIncidentActionTypeEnum::ANNOTATE => "incident.annotate",
            WebhookIncidentActionTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhookIncidentActionTypeEnum {
    fn default() -> Self {
        WebhookIncidentActionTypeEnum::TRIGGER
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhookObject {
    /// The label of the tag.
    #[serde(default = "WebhookObject::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: WebhookObjectTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for WebhookObject {
    fn default() -> Self {
        Self {
            label: String::from("WebhookObject"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl WebhookObject {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("WebhookObject")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("webhook_object")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhookObjectTypeEnum {
    #[serde(rename = "service")]
    SERVICE,
    #[serde(rename = "service_reference")]
    SERVICE_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhookObjectTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            WebhookObjectTypeEnum::SERVICE => write!(f, "service"),
            WebhookObjectTypeEnum::SERVICE_REFERENCE => write!(f, "service_reference"),
            WebhookObjectTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhookObjectTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "service" => Ok(WebhookObjectTypeEnum::SERVICE),
            "service_reference" => Ok(WebhookObjectTypeEnum::SERVICE_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhookObjectTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            WebhookObjectTypeEnum::SERVICE => "service",
            WebhookObjectTypeEnum::SERVICE_REFERENCE => "service_reference",
            WebhookObjectTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhookObjectTypeEnum {
    fn default() -> Self {
        WebhookObjectTypeEnum::SERVICE
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhookReference {
    /// The label of the tag.
    #[serde(default = "WebhookReference::label_default")]
    pub label: String,
    /// a URL at which the entity is uniquely displayed in the Web app
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// the API show URL at which the object is accessible
    #[serde(rename = "self")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _self: Option<String>,
    /// A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    pub _type: WebhookReferenceTypeEnum,
}

#[allow(clippy::derivable_impls)]
impl Default for WebhookReference {
    fn default() -> Self {
        Self {
            label: String::from("WebhookReference"),
            html_url: Default::default(),
            _self: Default::default(),
            summary: Default::default(),
            id: Default::default(),
            _type: Default::default(),
        }
    }
}

impl WebhookReference {
    #[allow(dead_code)]
    fn label_default() -> String {
        String::from("WebhookReference")
    }
    #[allow(dead_code)]
    fn _type_default() -> String {
        String::from("webhook_reference")
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhookReferenceTypeEnum {
    #[serde(rename = "webhook_reference")]
    WEBHOOK_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhookReferenceTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            WebhookReferenceTypeEnum::WEBHOOK_REFERENCE => write!(f, "webhook_reference"),
            WebhookReferenceTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhookReferenceTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "webhook_reference" => Ok(WebhookReferenceTypeEnum::WEBHOOK_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhookReferenceTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            WebhookReferenceTypeEnum::WEBHOOK_REFERENCE => "webhook_reference",
            WebhookReferenceTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhookReferenceTypeEnum {
    fn default() -> Self {
        WebhookReferenceTypeEnum::WEBHOOK_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhookSubscription {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type indicating the schema of the object.
    #[serde(rename = "type")]
    pub _type: WebhookSubscriptionTypeEnum,
    /// Determines whether this subscription will produce webhook events.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub active: Option<bool>,
    pub delivery_method: WebhookSubscriptionDeliveryMethod,
    /// A short description of the webhook subscription.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The set of outbound event types the webhook will receive.
    pub events: Vec<String>,
    pub filter: WebhookSubscriptionFilter,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhookSubscriptionTypeEnum {
    #[serde(rename = "webhook_subscription")]
    WEBHOOK_SUBSCRIPTION,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhookSubscriptionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            WebhookSubscriptionTypeEnum::WEBHOOK_SUBSCRIPTION => write!(f, "webhook_subscription"),
            WebhookSubscriptionTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhookSubscriptionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "webhook_subscription" => Ok(WebhookSubscriptionTypeEnum::WEBHOOK_SUBSCRIPTION),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhookSubscriptionTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            WebhookSubscriptionTypeEnum::WEBHOOK_SUBSCRIPTION => "webhook_subscription",
            WebhookSubscriptionTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhookSubscriptionTypeEnum {
    fn default() -> Self {
        WebhookSubscriptionTypeEnum::WEBHOOK_SUBSCRIPTION
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhookSubscriptionDeliveryMethod {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The secret used to sign webhook payloads. Only provided on the initial create response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secret: Option<String>,
    /// Whether or not this webhook subscription is temporarily disabled. Becomes `true` if the delivery method URL is repeatedly rejected by the server.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temporarily_disabled: Option<bool>,
    /// Indicates the type of the delivery method.
    #[serde(rename = "type")]
    pub _type: WebhookSubscriptionDeliveryMethodTypeEnum,
    /// The destination URL for webhook delivery.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub url: String,
    /// Optional headers to be set on this webhook subscription when sent. The header values are redacted in GET requests, but are not redacted on the webhook when delivered to the webhook's endpoint.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custom_headers: Option<Vec<Value>>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhookSubscriptionDeliveryMethodTypeEnum {
    #[serde(rename = "http_delivery_method")]
    HTTP_DELIVERY_METHOD,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhookSubscriptionDeliveryMethodTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            WebhookSubscriptionDeliveryMethodTypeEnum::HTTP_DELIVERY_METHOD => write!(f, "http_delivery_method"),
            WebhookSubscriptionDeliveryMethodTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhookSubscriptionDeliveryMethodTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "http_delivery_method" => Ok(WebhookSubscriptionDeliveryMethodTypeEnum::HTTP_DELIVERY_METHOD),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhookSubscriptionDeliveryMethodTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            WebhookSubscriptionDeliveryMethodTypeEnum::HTTP_DELIVERY_METHOD => "http_delivery_method",
            WebhookSubscriptionDeliveryMethodTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhookSubscriptionDeliveryMethodTypeEnum {
    fn default() -> Self {
        WebhookSubscriptionDeliveryMethodTypeEnum::HTTP_DELIVERY_METHOD
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhookSubscriptionFilter {
    /// The id of the object being used as the filter.  This field is required for all filter types except account_reference.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of object being used as the filter.
    #[serde(rename = "type")]
    pub _type: WebhookSubscriptionFilterTypeEnum,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhookSubscriptionFilterTypeEnum {
    #[serde(rename = "account_reference")]
    ACCOUNT_REFERENCE,
    #[serde(rename = "service_reference")]
    SERVICE_REFERENCE,
    #[serde(rename = "team_reference")]
    TEAM_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhookSubscriptionFilterTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            WebhookSubscriptionFilterTypeEnum::ACCOUNT_REFERENCE => write!(f, "account_reference"),
            WebhookSubscriptionFilterTypeEnum::SERVICE_REFERENCE => write!(f, "service_reference"),
            WebhookSubscriptionFilterTypeEnum::TEAM_REFERENCE => write!(f, "team_reference"),
            WebhookSubscriptionFilterTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhookSubscriptionFilterTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "account_reference" => Ok(WebhookSubscriptionFilterTypeEnum::ACCOUNT_REFERENCE),
            "service_reference" => Ok(WebhookSubscriptionFilterTypeEnum::SERVICE_REFERENCE),
            "team_reference" => Ok(WebhookSubscriptionFilterTypeEnum::TEAM_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhookSubscriptionFilterTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            WebhookSubscriptionFilterTypeEnum::ACCOUNT_REFERENCE => "account_reference",
            WebhookSubscriptionFilterTypeEnum::SERVICE_REFERENCE => "service_reference",
            WebhookSubscriptionFilterTypeEnum::TEAM_REFERENCE => "team_reference",
            WebhookSubscriptionFilterTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhookSubscriptionFilterTypeEnum {
    fn default() -> Self {
        WebhookSubscriptionFilterTypeEnum::ACCOUNT_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct UpdateWebhookSubscription {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub webhook_subscription: Option<WebhookSubscriptionUpdateWebhookSubscription>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhookSubscriptionUpdateWebhookSubscription {
    /// A short description of the webhook subscription.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The set of outbound event types the subscription will receive.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filter: Option<WebhookSubscriptionUpdateWebhookSubscriptionFilter>,
    /// If true, a webhook will be sent. True is the default state. If false, a webhook will not be sent.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub active: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhookSubscriptionUpdateWebhookSubscriptionFilter {
    /// The id of the object being used as the filter.  This field is required for all filter types except account_reference.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The type of object being used as the filter.
    #[serde(rename = "type")]
    pub _type: WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum {
    #[serde(rename = "account_reference")]
    ACCOUNT_REFERENCE,
    #[serde(rename = "service_reference")]
    SERVICE_REFERENCE,
    #[serde(rename = "team_reference")]
    TEAM_REFERENCE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum::ACCOUNT_REFERENCE => write!(f, "account_reference"),
            WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum::SERVICE_REFERENCE => write!(f, "service_reference"),
            WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum::TEAM_REFERENCE => write!(f, "team_reference"),
            WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "account_reference" => Ok(WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum::ACCOUNT_REFERENCE),
            "service_reference" => Ok(WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum::SERVICE_REFERENCE),
            "team_reference" => Ok(WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum::TEAM_REFERENCE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum::ACCOUNT_REFERENCE => "account_reference",
            WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum::SERVICE_REFERENCE => "service_reference",
            WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum::TEAM_REFERENCE => "team_reference",
            WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum {
    fn default() -> Self {
        WebhookSubscriptionUpdateWebhookSubscriptionFilterTypeEnum::ACCOUNT_REFERENCE
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct CreateWebhookSubscription {
    pub webhook_subscription: WebhookSubscription,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhooksV1AssignedTo {
    /// Time at which the assignment was created.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub object: Option<AllOfWebhooksV1AssignedToObject>,
}
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhooksV1AssignedToObject {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub _type: Option<String>,
}

/// The user assigned to the incident.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhooksV1AssignedToUser {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The user's name.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The user's email address.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
}

/// The incident details at the time of the state change.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhooksV1IncidentData {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The number of the incident. This is unique across the account.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident_number: Option<isize>,
    /// The date/time the incident was first triggered.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_on: Option<chrono::DateTime<chrono::Utc>>,
    /// The current status of the incident.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<WebhooksV1IncidentDataStatusEnum>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// The incident's de-duplication key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident_key: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service: Option<WebhooksV1Service>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assigned_to_user: Option<WebhooksV1AssignedToUser>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assigned_to: Option<Vec<WebhooksV1AssignedTo>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger_summary_data: Option<WebhooksV1IncidentDataTriggerSummaryData>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger_details_html_url: Option<String>,
    /// The time at which the status of the incident last changed.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_status_change_on: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_status_change_by: Option<WebhooksV1AssignedToUser>,
    /// Number of times the incident has been escalated.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_escalations: Option<usize>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub urgency: Option<WebhooksV1IncidentDataUrgencyEnum>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhooksV1IncidentDataStatusEnum {
    #[serde(rename = "triggered")]
    TRIGGERED,
    #[serde(rename = "acknowledged")]
    ACKNOWLEDGED,
    #[serde(rename = "resolved")]
    RESOLVED,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhooksV1IncidentDataStatusEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            WebhooksV1IncidentDataStatusEnum::TRIGGERED => write!(f, "triggered"),
            WebhooksV1IncidentDataStatusEnum::ACKNOWLEDGED => write!(f, "acknowledged"),
            WebhooksV1IncidentDataStatusEnum::RESOLVED => write!(f, "resolved"),
            WebhooksV1IncidentDataStatusEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhooksV1IncidentDataStatusEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "triggered" => Ok(WebhooksV1IncidentDataStatusEnum::TRIGGERED),
            "acknowledged" => Ok(WebhooksV1IncidentDataStatusEnum::ACKNOWLEDGED),
            "resolved" => Ok(WebhooksV1IncidentDataStatusEnum::RESOLVED),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhooksV1IncidentDataStatusEnum {
    fn as_ref(&self) -> &str {
        match self {
            WebhooksV1IncidentDataStatusEnum::TRIGGERED => "triggered",
            WebhooksV1IncidentDataStatusEnum::ACKNOWLEDGED => "acknowledged",
            WebhooksV1IncidentDataStatusEnum::RESOLVED => "resolved",
            WebhooksV1IncidentDataStatusEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhooksV1IncidentDataStatusEnum {
    fn default() -> Self {
        WebhooksV1IncidentDataStatusEnum::TRIGGERED
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhooksV1IncidentDataUrgencyEnum {
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "low")]
    LOW,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhooksV1IncidentDataUrgencyEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            WebhooksV1IncidentDataUrgencyEnum::HIGH => write!(f, "high"),
            WebhooksV1IncidentDataUrgencyEnum::LOW => write!(f, "low"),
            WebhooksV1IncidentDataUrgencyEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhooksV1IncidentDataUrgencyEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "high" => Ok(WebhooksV1IncidentDataUrgencyEnum::HIGH),
            "low" => Ok(WebhooksV1IncidentDataUrgencyEnum::LOW),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhooksV1IncidentDataUrgencyEnum {
    fn as_ref(&self) -> &str {
        match self {
            WebhooksV1IncidentDataUrgencyEnum::HIGH => "high",
            WebhooksV1IncidentDataUrgencyEnum::LOW => "low",
            WebhooksV1IncidentDataUrgencyEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhooksV1IncidentDataUrgencyEnum {
    fn default() -> Self {
        WebhooksV1IncidentDataUrgencyEnum::HIGH
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhooksV1IncidentDataTriggerSummaryData {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subject: Option<String>,
}

/// A message containing information about a single PagerDuty action.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhooksV1Message {
    /// Uniquely identifies this outgoing webhook message; can be used for idempotency when processing the messages.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<uuid::Uuid>,
    /// The type of action being reported by this message.
    #[serde(rename = "type")]
    pub _type: WebhooksV1MessageTypeEnum,
    /// The date/time when the incident changed state.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_on: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<WebhooksV1MessageData>,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhooksV1MessageTypeEnum {
    #[serde(rename = "incident.trigger")]
    TRIGGER,
    #[serde(rename = "incident.acknowledge")]
    ACKNOWLEDGE,
    #[serde(rename = "incident.unacknowledge")]
    UNACKNOWLEDGE,
    #[serde(rename = "incident.resolve")]
    RESOLVE,
    #[serde(rename = "incident.assign")]
    ASSIGN,
    #[serde(rename = "incident.escalate")]
    ESCALATE,
    #[serde(rename = "incident.delegate")]
    DELEGATE,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WebhooksV1MessageTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            WebhooksV1MessageTypeEnum::TRIGGER => write!(f, "incident.trigger"),
            WebhooksV1MessageTypeEnum::ACKNOWLEDGE => write!(f, "incident.acknowledge"),
            WebhooksV1MessageTypeEnum::UNACKNOWLEDGE => write!(f, "incident.unacknowledge"),
            WebhooksV1MessageTypeEnum::RESOLVE => write!(f, "incident.resolve"),
            WebhooksV1MessageTypeEnum::ASSIGN => write!(f, "incident.assign"),
            WebhooksV1MessageTypeEnum::ESCALATE => write!(f, "incident.escalate"),
            WebhooksV1MessageTypeEnum::DELEGATE => write!(f, "incident.delegate"),
            WebhooksV1MessageTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for WebhooksV1MessageTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "incident.trigger" => Ok(WebhooksV1MessageTypeEnum::TRIGGER),
            "incident.acknowledge" => Ok(WebhooksV1MessageTypeEnum::ACKNOWLEDGE),
            "incident.unacknowledge" => Ok(WebhooksV1MessageTypeEnum::UNACKNOWLEDGE),
            "incident.resolve" => Ok(WebhooksV1MessageTypeEnum::RESOLVE),
            "incident.assign" => Ok(WebhooksV1MessageTypeEnum::ASSIGN),
            "incident.escalate" => Ok(WebhooksV1MessageTypeEnum::ESCALATE),
            "incident.delegate" => Ok(WebhooksV1MessageTypeEnum::DELEGATE),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WebhooksV1MessageTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            WebhooksV1MessageTypeEnum::TRIGGER => "incident.trigger",
            WebhooksV1MessageTypeEnum::ACKNOWLEDGE => "incident.acknowledge",
            WebhooksV1MessageTypeEnum::UNACKNOWLEDGE => "incident.unacknowledge",
            WebhooksV1MessageTypeEnum::RESOLVE => "incident.resolve",
            WebhooksV1MessageTypeEnum::ASSIGN => "incident.assign",
            WebhooksV1MessageTypeEnum::ESCALATE => "incident.escalate",
            WebhooksV1MessageTypeEnum::DELEGATE => "incident.delegate",
            WebhooksV1MessageTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WebhooksV1MessageTypeEnum {
    fn default() -> Self {
        WebhooksV1MessageTypeEnum::TRIGGER
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhooksV1MessageData {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incident: Option<WebhooksV1IncidentData>,
}

/// The service on which the incident occurred.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WebhooksV1Service {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The name of the service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html_url: Option<String>,
    /// The date/time the service was deleted, if it has been removed.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deleted_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The description of the service.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
pub struct WeeklyRestriction {
    /// Specify the types of `restriction`.
    #[serde(rename = "type")]
    pub _type: WeeklyRestrictionTypeEnum,
    /// The duration of the restriction in seconds.
    pub duration_seconds: isize,
    /// The start time in HH:mm:ss format.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub start_time_of_day: String,
    /// The first day of the weekly rotation schedule as [ISO 8601 day](https://en.wikipedia.org/wiki/ISO_week_date) (1 is Monday, etc.)
    pub start_day_of_week: u8,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WeeklyRestrictionTypeEnum {
    #[serde(rename = "daily_restriction")]
    DAILY_RESTRICTION,
    #[serde(rename = "weekly_restriction")]
    WEEKLY_RESTRICTION,
    #[serde(other)]
    UNKNOWN,
}

impl ::std::fmt::Display for WeeklyRestrictionTypeEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            WeeklyRestrictionTypeEnum::DAILY_RESTRICTION => write!(f, "daily_restriction"),
            WeeklyRestrictionTypeEnum::WEEKLY_RESTRICTION => write!(f, "weekly_restriction"),
            WeeklyRestrictionTypeEnum::UNKNOWN => write!(f, "unknown"),
        }
    }
}

impl ::std::str::FromStr for WeeklyRestrictionTypeEnum {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "daily_restriction" => Ok(WeeklyRestrictionTypeEnum::DAILY_RESTRICTION),
            "weekly_restriction" => Ok(WeeklyRestrictionTypeEnum::WEEKLY_RESTRICTION),
            x => Err(format!("Invalid enum type: {}", x)),
        }
    }
}

impl ::std::convert::AsRef<str> for WeeklyRestrictionTypeEnum {
    fn as_ref(&self) -> &str {
        match self {
            WeeklyRestrictionTypeEnum::DAILY_RESTRICTION => "daily_restriction",
            WeeklyRestrictionTypeEnum::WEEKLY_RESTRICTION => "weekly_restriction",
            WeeklyRestrictionTypeEnum::UNKNOWN => "unknown",
        }
    }
}

// Pick the first enum var as default. Please report this as a bug if it's not correct.
impl std::default::Default for WeeklyRestrictionTypeEnum {
    fn default() -> Self {
        WeeklyRestrictionTypeEnum::DAILY_RESTRICTION
    }
}
