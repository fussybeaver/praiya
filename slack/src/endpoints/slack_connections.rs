//! Method, error and parameter types for the SlackConnections endpoint.
#![allow(
    unused_imports,
)]
/* 
 * PagerDuty Slack Integration API
 *
 * This is API documentation for PagerDuty's integration with Slack.   To begin the integration, you will need to map your PagerDuty account to your Slack Workspace. After configuring an Extension on each Service, Incident notifications will be posted in the configured Slack channel.  Additional integration documentation can be found here: https://support.pagerduty.com/docs/slack-integration-guide.  > ### Important > >  Ensure you are using a User API Token to make requests to this API. Also, check that your user has necessary >  permissions (Owner or Global Admin). See https://developer.pagerduty.com/docs/rest-api-v2/authentication/ for the >  details.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: support@pagerduty.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::adapters::{AdapterError, FromJson, GitHubRequest, GitHubRequestBuilder, GitHubResponseExt};
use crate::auth::Auth;
use crate::models::*;

use super::PerPage;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct SlackConnections<'api> {
    auth: &'api Auth
}

pub fn new(auth: &Auth) -> SlackConnections {
    SlackConnections { auth }
}

/// Errors for the [Create a Slack Connection](SlackConnections::create_connection_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SlackConnectionsCreateConnectionError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Caller provided invalid arguments. Please review the response for error details. Retrying with the same arguments will *not* work.")]
    Status400(Value),
    #[error("Caller did not supply credentials or did not provide the correct credentials. If you are using an API key, it may be invalid or your Authorization header may be malformed. ")]
    Status401(Value),
    #[error("Caller is not authorized to view the requested resource. While your authentication is valid, the authenticated user or token does not have permission to perform this action. ")]
    Status403(Value),
    #[error("The requested resource was not found.")]
    Status404(Value),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Delete a Slack Connection](SlackConnections::delete_connection_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SlackConnectionsDeleteConnectionError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Caller did not supply credentials or did not provide the correct credentials. If you are using an API key, it may be invalid or your Authorization header may be malformed. ")]
    Status401(Value),
    #[error("Caller is not authorized to view the requested resource. While your authentication is valid, the authenticated user or token does not have permission to perform this action. ")]
    Status403(Value),
    #[error("The requested resource was not found.")]
    Status404(Value),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get a Slack Connection](SlackConnections::get_connection_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SlackConnectionsGetConnectionError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Caller did not supply credentials or did not provide the correct credentials. If you are using an API key, it may be invalid or your Authorization header may be malformed. ")]
    Status401(Value),
    #[error("Caller is not authorized to view the requested resource. While your authentication is valid, the authenticated user or token does not have permission to perform this action. ")]
    Status403(Value),
    #[error("The requested resource was not found.")]
    Status404(Value),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List Slack Connections](SlackConnections::get_connections_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SlackConnectionsGetConnectionsError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Caller did not supply credentials or did not provide the correct credentials. If you are using an API key, it may be invalid or your Authorization header may be malformed. ")]
    Status401(Value),
    #[error("Caller is not authorized to view the requested resource. While your authentication is valid, the authenticated user or token does not have permission to perform this action. ")]
    Status403(Value),
    #[error("The requested resource was not found.")]
    Status404(Value),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Update a Slack Connection](SlackConnections::update_connection_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SlackConnectionsUpdateConnectionError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Caller provided invalid arguments. Please review the response for error details. Retrying with the same arguments will *not* work.")]
    Status400(Value),
    #[error("Caller did not supply credentials or did not provide the correct credentials. If you are using an API key, it may be invalid or your Authorization header may be malformed. ")]
    Status401(Value),
    #[error("Caller is not authorized to view the requested resource. While your authentication is valid, the authenticated user or token does not have permission to perform this action. ")]
    Status403(Value),
    #[error("The requested resource was not found.")]
    Status404(Value),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}


/// Query parameters for the [List Slack Connections](SlackConnections::get_connections_async()) endpoint.
#[derive(Default, Serialize)]
pub struct SlackConnectionsGetConnectionsParams {
    /// Set the maximum number of results matched by the query.
    limit: Option<i32>, 
    /// The number of items to skip before starting to collect the result set.
    offset: Option<i32>
}

impl SlackConnectionsGetConnectionsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// Set the maximum number of results matched by the query.
    pub fn limit(self, limit: i32) -> Self {
        Self { 
            limit: Some(limit),
            offset: self.offset, 
        }
    }

    /// The number of items to skip before starting to collect the result set.
    pub fn offset(self, offset: i32) -> Self {
        Self { 
            limit: self.limit, 
            offset: Some(offset),
        }
    }
}


impl<'api> SlackConnections<'api> {
    /// ---
    ///
    /// # Create a Slack Connection
    ///
    /// Creates a Slack Connection
    /// 
    /// > ### Important
    /// >
    /// >  Make sure that your PagerDuty account is linked to your Slack workspace and your PagerDuty user is linked to your Slack user. You can do this on the Slack extension page in your PagerDuty account.
    /// 
    
    ///
    /// ---
    pub async fn create_connection_async(&self, slack_team_id: &str, body: PostCreateConnection) -> Result<SlackTeamIdConnectionsBody, SlackConnectionsCreateConnectionError> {

        let request_uri = format!("{}/workspaces/{}/connections", super::GITHUB_BASE_API_URL, slack_team_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostCreateConnection::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                400 => Err(SlackConnectionsCreateConnectionError::Status400(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(SlackConnectionsCreateConnectionError::Status401(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(SlackConnectionsCreateConnectionError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(SlackConnectionsCreateConnectionError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SlackConnectionsCreateConnectionError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create a Slack Connection
    ///
    /// Creates a Slack Connection
    /// 
    /// > ### Important
    /// >
    /// >  Make sure that your PagerDuty account is linked to your Slack workspace and your PagerDuty user is linked to your Slack user. You can do this on the Slack extension page in your PagerDuty account.
    /// 
    
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_connection(&self, slack_team_id: &str, body: PostCreateConnection) -> Result<SlackTeamIdConnectionsBody, SlackConnectionsCreateConnectionError> {

        let request_uri = format!("{}/workspaces/{}/connections", super::GITHUB_BASE_API_URL, slack_team_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostCreateConnection::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                400 => Err(SlackConnectionsCreateConnectionError::Status400(crate::adapters::to_json(github_response)?)),
                401 => Err(SlackConnectionsCreateConnectionError::Status401(crate::adapters::to_json(github_response)?)),
                403 => Err(SlackConnectionsCreateConnectionError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(SlackConnectionsCreateConnectionError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(SlackConnectionsCreateConnectionError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete a Slack Connection
    ///
    /// Delete an existing Slack Connection.
    
    ///
    /// ---
    pub async fn delete_connection_async(&self, slack_team_id: &str, connection_id: &str) -> Result<ConnectionsConnectionIdBody, SlackConnectionsDeleteConnectionError> {

        let request_uri = format!("{}/workspaces/{}/connections/{}", super::GITHUB_BASE_API_URL, slack_team_id, connection_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                401 => Err(SlackConnectionsDeleteConnectionError::Status401(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(SlackConnectionsDeleteConnectionError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(SlackConnectionsDeleteConnectionError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SlackConnectionsDeleteConnectionError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete a Slack Connection
    ///
    /// Delete an existing Slack Connection.
    
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_connection(&self, slack_team_id: &str, connection_id: &str) -> Result<ConnectionsConnectionIdBody, SlackConnectionsDeleteConnectionError> {

        let request_uri = format!("{}/workspaces/{}/connections/{}", super::GITHUB_BASE_API_URL, slack_team_id, connection_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                401 => Err(SlackConnectionsDeleteConnectionError::Status401(crate::adapters::to_json(github_response)?)),
                403 => Err(SlackConnectionsDeleteConnectionError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(SlackConnectionsDeleteConnectionError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(SlackConnectionsDeleteConnectionError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a Slack Connection
    ///
    /// Get details about an existing Slack Connection.
    
    ///
    /// ---
    pub async fn get_connection_async(&self, slack_team_id: &str, connection_id: &str) -> Result<SlackTeamIdConnectionsBody, SlackConnectionsGetConnectionError> {

        let request_uri = format!("{}/workspaces/{}/connections/{}", super::GITHUB_BASE_API_URL, slack_team_id, connection_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                401 => Err(SlackConnectionsGetConnectionError::Status401(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(SlackConnectionsGetConnectionError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(SlackConnectionsGetConnectionError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SlackConnectionsGetConnectionError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a Slack Connection
    ///
    /// Get details about an existing Slack Connection.
    
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_connection(&self, slack_team_id: &str, connection_id: &str) -> Result<SlackTeamIdConnectionsBody, SlackConnectionsGetConnectionError> {

        let request_uri = format!("{}/workspaces/{}/connections/{}", super::GITHUB_BASE_API_URL, slack_team_id, connection_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                401 => Err(SlackConnectionsGetConnectionError::Status401(crate::adapters::to_json(github_response)?)),
                403 => Err(SlackConnectionsGetConnectionError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(SlackConnectionsGetConnectionError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(SlackConnectionsGetConnectionError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List Slack Connections
    ///
    /// Returns a list of Slack Connections.
    
    ///
    /// ---
    pub async fn get_connections_async(&self, slack_team_id: &str, query_params: Option<impl Into<SlackConnectionsGetConnectionsParams>>) -> Result<GetGetConnectionsResponse200, SlackConnectionsGetConnectionsError> {

        let mut request_uri = format!("{}/workspaces/{}/connections", super::GITHUB_BASE_API_URL, slack_team_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                401 => Err(SlackConnectionsGetConnectionsError::Status401(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(SlackConnectionsGetConnectionsError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(SlackConnectionsGetConnectionsError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SlackConnectionsGetConnectionsError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List Slack Connections
    ///
    /// Returns a list of Slack Connections.
    
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_connections(&self, slack_team_id: &str, query_params: Option<impl Into<SlackConnectionsGetConnectionsParams>>) -> Result<GetGetConnectionsResponse200, SlackConnectionsGetConnectionsError> {

        let mut request_uri = format!("{}/workspaces/{}/connections", super::GITHUB_BASE_API_URL, slack_team_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: SlackConnectionsGetConnectionsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                401 => Err(SlackConnectionsGetConnectionsError::Status401(crate::adapters::to_json(github_response)?)),
                403 => Err(SlackConnectionsGetConnectionsError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(SlackConnectionsGetConnectionsError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(SlackConnectionsGetConnectionsError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Update a Slack Connection
    ///
    /// Update an existing Slack Connection.
    
    ///
    /// ---
    pub async fn update_connection_async(&self, slack_team_id: &str, connection_id: &str, body: PutUpdateConnection) -> Result<ConnectionsConnectionIdBody, SlackConnectionsUpdateConnectionError> {

        let request_uri = format!("{}/workspaces/{}/connections/{}", super::GITHUB_BASE_API_URL, slack_team_id, connection_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PutUpdateConnection::from_json(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                400 => Err(SlackConnectionsUpdateConnectionError::Status400(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(SlackConnectionsUpdateConnectionError::Status401(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(SlackConnectionsUpdateConnectionError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(SlackConnectionsUpdateConnectionError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SlackConnectionsUpdateConnectionError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Update a Slack Connection
    ///
    /// Update an existing Slack Connection.
    
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update_connection(&self, slack_team_id: &str, connection_id: &str, body: PutUpdateConnection) -> Result<ConnectionsConnectionIdBody, SlackConnectionsUpdateConnectionError> {

        let request_uri = format!("{}/workspaces/{}/connections/{}", super::GITHUB_BASE_API_URL, slack_team_id, connection_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PutUpdateConnection::from_json(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                400 => Err(SlackConnectionsUpdateConnectionError::Status400(crate::adapters::to_json(github_response)?)),
                401 => Err(SlackConnectionsUpdateConnectionError::Status401(crate::adapters::to_json(github_response)?)),
                403 => Err(SlackConnectionsUpdateConnectionError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(SlackConnectionsUpdateConnectionError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(SlackConnectionsUpdateConnectionError::Generic { code }),
            }
        }
    }

}
